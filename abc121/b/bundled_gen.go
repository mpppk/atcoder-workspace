// Code generated by golang.org/x/tools/cmd/bundle. DO NOT EDIT.
//go:generate bundle -o abc121/b/bundled_gen.go -pkg main -dst github.com/mpppk/atcoder/abc121/b github.com/mpppk/atcoder/gen

// go:generate goofy mustify --file input.go
//

package main

import (
	"bufio"
	"errors"
	"fmt"
	"io"
	"math"
	"strconv"
	"strings"
)

func (i *lib_Input) GetIntLines() (newLines [][]int, err error) {
	return i.GetIntLinesFrom(0)
}

func (i *lib_Input) GetIntLinesFrom(fromIndex int) (newLines [][]int, err error) {
	for index := range i.lines {
		if index < fromIndex {
			continue
		}
		newLine, err := i.GetIntLine(index)
		if err != nil {
			return nil, err
		}
		newLines = append(newLines, newLine)
	}
	return
}

func (i *lib_Input) GetIntLine(index int) ([]int, error) {
	if err := i.validateRowIndex(index); err != nil {
		return nil, err
	}

	newLine, err := lib_StringSliceToIntSlice(i.lines[index])
	if err != nil {
		return nil, fmt.Errorf("%dth index: %v", index, err)
	}
	return newLine, nil
}

func (i *lib_Input) GetIntValue(rowIndex, colIndex int) (int, error) {
	line, err := i.GetLine(rowIndex)
	if err != nil {
		return 0, err
	}
	if colIndex < 0 || colIndex >= len(line) {
		return 0, fmt.Errorf("Invalid col index: %v ", colIndex)
	}

	v, err := strconv.ParseInt(line[colIndex], 10, 64)
	if err != nil {
		return 0, fmt.Errorf("failed to convert string to int: %v, %v", line[colIndex], err)
	}

	return int(v), nil
}

func (i *lib_Input) GetFirstIntValue(rowIndex int) (int, error) {
	return i.GetIntValue(rowIndex, 0)
}

func (i *lib_Input) GetColIntLine(colIndex int) (newLine []int, err error) {
	strLine, err := i.GetColLine(colIndex)
	if err != nil {
		return nil, err
	}
	newLine, err = lib_StringSliceToIntSlice(strLine)
	if err != nil {
		return nil, fmt.Errorf("%dth col index: %v", colIndex, err)
	}
	return
}

func (i *lib_Input) GetInt8Lines() (newLines [][]int8, err error) {
	return i.GetInt8LinesFrom(0)
}

func (i *lib_Input) GetInt8LinesFrom(fromIndex int) (newLines [][]int8, err error) {
	for index := range i.lines {
		if index < fromIndex {
			continue
		}
		newLine, err := i.GetInt8Line(index)
		if err != nil {
			return nil, err
		}
		newLines = append(newLines, newLine)
	}
	return
}

func (i *lib_Input) GetInt8Line(index int) ([]int8, error) {
	if err := i.validateRowIndex(index); err != nil {
		return nil, err
	}

	newLine, err := lib_StringSliceToInt8Slice(i.lines[index])
	if err != nil {
		return nil, fmt.Errorf("%dth index: %v", index, err)
	}
	return newLine, nil
}

func (i *lib_Input) GetInt8Value(rowIndex, colIndex int) (int8, error) {
	line, err := i.GetLine(rowIndex)
	if err != nil {
		return 0, err
	}
	if colIndex < 0 || colIndex >= len(line) {
		return 0, fmt.Errorf("Invalid col index: %v ", colIndex)
	}

	v, err := strconv.ParseInt(line[colIndex], 10, 64)
	if err != nil {
		return 0, fmt.Errorf("failed to convert string to int: %v, %v", line[colIndex], err)
	}

	return int8(v), nil
}

func (i *lib_Input) GetFirstInt8Value(rowIndex int) (int8, error) {
	return i.GetInt8Value(rowIndex, 0)
}

func (i *lib_Input) GetColInt8Line(colIndex int) (newLine []int8, err error) {
	strLine, err := i.GetColLine(colIndex)
	if err != nil {
		return nil, err
	}
	newLine, err = lib_StringSliceToInt8Slice(strLine)
	if err != nil {
		return nil, fmt.Errorf("%dth col index: %v", colIndex, err)
	}
	return
}

func (i *lib_Input) GetInt16Lines() (newLines [][]int16, err error) {
	return i.GetInt16LinesFrom(0)
}

func (i *lib_Input) GetInt16LinesFrom(fromIndex int) (newLines [][]int16, err error) {
	for index := range i.lines {
		if index < fromIndex {
			continue
		}
		newLine, err := i.GetInt16Line(index)
		if err != nil {
			return nil, err
		}
		newLines = append(newLines, newLine)
	}
	return
}

func (i *lib_Input) GetInt16Line(index int) ([]int16, error) {
	if err := i.validateRowIndex(index); err != nil {
		return nil, err
	}

	newLine, err := lib_StringSliceToInt16Slice(i.lines[index])
	if err != nil {
		return nil, fmt.Errorf("%dth index: %v", index, err)
	}
	return newLine, nil
}

func (i *lib_Input) GetInt16Value(rowIndex, colIndex int) (int16, error) {
	line, err := i.GetLine(rowIndex)
	if err != nil {
		return 0, err
	}
	if colIndex < 0 || colIndex >= len(line) {
		return 0, fmt.Errorf("Invalid col index: %v ", colIndex)
	}

	v, err := strconv.ParseInt(line[colIndex], 10, 64)
	if err != nil {
		return 0, fmt.Errorf("failed to convert string to int: %v, %v", line[colIndex], err)
	}

	return int16(v), nil
}

func (i *lib_Input) GetFirstInt16Value(rowIndex int) (int16, error) {
	return i.GetInt16Value(rowIndex, 0)
}

func (i *lib_Input) GetColInt16Line(colIndex int) (newLine []int16, err error) {
	strLine, err := i.GetColLine(colIndex)
	if err != nil {
		return nil, err
	}
	newLine, err = lib_StringSliceToInt16Slice(strLine)
	if err != nil {
		return nil, fmt.Errorf("%dth col index: %v", colIndex, err)
	}
	return
}

func (i *lib_Input) GetInt32Lines() (newLines [][]int32, err error) {
	return i.GetInt32LinesFrom(0)
}

func (i *lib_Input) GetInt32LinesFrom(fromIndex int) (newLines [][]int32, err error) {
	for index := range i.lines {
		if index < fromIndex {
			continue
		}
		newLine, err := i.GetInt32Line(index)
		if err != nil {
			return nil, err
		}
		newLines = append(newLines, newLine)
	}
	return
}

func (i *lib_Input) GetInt32Line(index int) ([]int32, error) {
	if err := i.validateRowIndex(index); err != nil {
		return nil, err
	}

	newLine, err := lib_StringSliceToInt32Slice(i.lines[index])
	if err != nil {
		return nil, fmt.Errorf("%dth index: %v", index, err)
	}
	return newLine, nil
}

func (i *lib_Input) GetInt32Value(rowIndex, colIndex int) (int32, error) {
	line, err := i.GetLine(rowIndex)
	if err != nil {
		return 0, err
	}
	if colIndex < 0 || colIndex >= len(line) {
		return 0, fmt.Errorf("Invalid col index: %v ", colIndex)
	}

	v, err := strconv.ParseInt(line[colIndex], 10, 64)
	if err != nil {
		return 0, fmt.Errorf("failed to convert string to int: %v, %v", line[colIndex], err)
	}

	return int32(v), nil
}

func (i *lib_Input) GetFirstInt32Value(rowIndex int) (int32, error) {
	return i.GetInt32Value(rowIndex, 0)
}

func (i *lib_Input) GetColInt32Line(colIndex int) (newLine []int32, err error) {
	strLine, err := i.GetColLine(colIndex)
	if err != nil {
		return nil, err
	}
	newLine, err = lib_StringSliceToInt32Slice(strLine)
	if err != nil {
		return nil, fmt.Errorf("%dth col index: %v", colIndex, err)
	}
	return
}

func (i *lib_Input) GetInt64Lines() (newLines [][]int64, err error) {
	return i.GetInt64LinesFrom(0)
}

func (i *lib_Input) GetInt64LinesFrom(fromIndex int) (newLines [][]int64, err error) {
	for index := range i.lines {
		if index < fromIndex {
			continue
		}
		newLine, err := i.GetInt64Line(index)
		if err != nil {
			return nil, err
		}
		newLines = append(newLines, newLine)
	}
	return
}

func (i *lib_Input) GetInt64Line(index int) ([]int64, error) {
	if err := i.validateRowIndex(index); err != nil {
		return nil, err
	}

	newLine, err := lib_StringSliceToInt64Slice(i.lines[index])
	if err != nil {
		return nil, fmt.Errorf("%dth index: %v", index, err)
	}
	return newLine, nil
}

func (i *lib_Input) GetInt64Value(rowIndex, colIndex int) (int64, error) {
	line, err := i.GetLine(rowIndex)
	if err != nil {
		return 0, err
	}
	if colIndex < 0 || colIndex >= len(line) {
		return 0, fmt.Errorf("Invalid col index: %v ", colIndex)
	}

	v, err := strconv.ParseInt(line[colIndex], 10, 64)
	if err != nil {
		return 0, fmt.Errorf("failed to convert string to int: %v, %v", line[colIndex], err)
	}

	return int64(v), nil
}

func (i *lib_Input) GetFirstInt64Value(rowIndex int) (int64, error) {
	return i.GetInt64Value(rowIndex, 0)
}

func (i *lib_Input) GetColInt64Line(colIndex int) (newLine []int64, err error) {
	strLine, err := i.GetColLine(colIndex)
	if err != nil {
		return nil, err
	}
	newLine, err = lib_StringSliceToInt64Slice(strLine)
	if err != nil {
		return nil, fmt.Errorf("%dth col index: %v", colIndex, err)
	}
	return
}

func (i *lib_Input) GetFloat32Lines() (newLines [][]float32, err error) {
	return i.GetFloat32LinesFrom(0)
}

func (i *lib_Input) GetFloat32LinesFrom(fromIndex int) (newLines [][]float32, err error) {
	for index := range i.lines {
		if index < fromIndex {
			continue
		}
		newLine, err := i.GetFloat32Line(index)
		if err != nil {
			return nil, err
		}
		newLines = append(newLines, newLine)
	}
	return
}

func (i *lib_Input) GetFloat32Line(index int) ([]float32, error) {
	if err := i.validateRowIndex(index); err != nil {
		return nil, err
	}

	newLine, err := lib_StringSliceToFloat32Slice(i.lines[index])
	if err != nil {
		return nil, fmt.Errorf("%dth index: %v", index, err)
	}
	return newLine, nil
}

func (i *lib_Input) GetFloat32Value(rowIndex, colIndex int) (float32, error) {
	line, err := i.GetLine(rowIndex)
	if err != nil {
		return 0, err
	}
	if colIndex < 0 || colIndex >= len(line) {
		return 0, fmt.Errorf("Invalid col index: %v ", colIndex)
	}

	v, err := strconv.ParseInt(line[colIndex], 10, 64)
	if err != nil {
		return 0, fmt.Errorf("failed to convert string to int: %v, %v", line[colIndex], err)
	}

	return float32(v), nil
}

func (i *lib_Input) GetFirstFloat32Value(rowIndex int) (float32, error) {
	return i.GetFloat32Value(rowIndex, 0)
}

func (i *lib_Input) GetColFloat32Line(colIndex int) (newLine []float32, err error) {
	strLine, err := i.GetColLine(colIndex)
	if err != nil {
		return nil, err
	}
	newLine, err = lib_StringSliceToFloat32Slice(strLine)
	if err != nil {
		return nil, fmt.Errorf("%dth col index: %v", colIndex, err)
	}
	return
}

func (i *lib_Input) GetFloat64Lines() (newLines [][]float64, err error) {
	return i.GetFloat64LinesFrom(0)
}

func (i *lib_Input) GetFloat64LinesFrom(fromIndex int) (newLines [][]float64, err error) {
	for index := range i.lines {
		if index < fromIndex {
			continue
		}
		newLine, err := i.GetFloat64Line(index)
		if err != nil {
			return nil, err
		}
		newLines = append(newLines, newLine)
	}
	return
}

func (i *lib_Input) GetFloat64Line(index int) ([]float64, error) {
	if err := i.validateRowIndex(index); err != nil {
		return nil, err
	}

	newLine, err := lib_StringSliceToFloat64Slice(i.lines[index])
	if err != nil {
		return nil, fmt.Errorf("%dth index: %v", index, err)
	}
	return newLine, nil
}

func (i *lib_Input) GetFloat64Value(rowIndex, colIndex int) (float64, error) {
	line, err := i.GetLine(rowIndex)
	if err != nil {
		return 0, err
	}
	if colIndex < 0 || colIndex >= len(line) {
		return 0, fmt.Errorf("Invalid col index: %v ", colIndex)
	}

	v, err := strconv.ParseInt(line[colIndex], 10, 64)
	if err != nil {
		return 0, fmt.Errorf("failed to convert string to int: %v, %v", line[colIndex], err)
	}

	return float64(v), nil
}

func (i *lib_Input) GetFirstFloat64Value(rowIndex int) (float64, error) {
	return i.GetFloat64Value(rowIndex, 0)
}

func (i *lib_Input) GetColFloat64Line(colIndex int) (newLine []float64, err error) {
	strLine, err := i.GetColLine(colIndex)
	if err != nil {
		return nil, err
	}
	newLine, err = lib_StringSliceToFloat64Slice(strLine)
	if err != nil {
		return nil, fmt.Errorf("%dth col index: %v", colIndex, err)
	}
	return
}

func lib_IntToBits(value int, minDigits int) (bits []bool) {
	bin := fmt.Sprintf("%b", int(value))
	digits := 0
	for _, b := range bin {
		digits++
		if b == '0' {
			bits = append(bits, false)
		} else if b == '1' {
			bits = append(bits, true)
		} else {
			panic("invalid bit:" + string(b) + ", " + string('0'))
		}
	}

	for minDigits > digits {
		bits = append([]bool{false}, bits...)
		digits++
	}

	return
}

func lib_Int8ToBits(value int8, minDigits int) (bits []bool) {
	bin := fmt.Sprintf("%b", int(value))
	digits := 0
	for _, b := range bin {
		digits++
		if b == '0' {
			bits = append(bits, false)
		} else if b == '1' {
			bits = append(bits, true)
		} else {
			panic("invalid bit:" + string(b) + ", " + string('0'))
		}
	}

	for minDigits > digits {
		bits = append([]bool{false}, bits...)
		digits++
	}

	return
}

func lib_Int16ToBits(value int16, minDigits int) (bits []bool) {
	bin := fmt.Sprintf("%b", int(value))
	digits := 0
	for _, b := range bin {
		digits++
		if b == '0' {
			bits = append(bits, false)
		} else if b == '1' {
			bits = append(bits, true)
		} else {
			panic("invalid bit:" + string(b) + ", " + string('0'))
		}
	}

	for minDigits > digits {
		bits = append([]bool{false}, bits...)
		digits++
	}

	return
}

func lib_Int32ToBits(value int32, minDigits int) (bits []bool) {
	bin := fmt.Sprintf("%b", int(value))
	digits := 0
	for _, b := range bin {
		digits++
		if b == '0' {
			bits = append(bits, false)
		} else if b == '1' {
			bits = append(bits, true)
		} else {
			panic("invalid bit:" + string(b) + ", " + string('0'))
		}
	}

	for minDigits > digits {
		bits = append([]bool{false}, bits...)
		digits++
	}

	return
}

func lib_Int64ToBits(value int64, minDigits int) (bits []bool) {
	bin := fmt.Sprintf("%b", int(value))
	digits := 0
	for _, b := range bin {
		digits++
		if b == '0' {
			bits = append(bits, false)
		} else if b == '1' {
			bits = append(bits, true)
		} else {
			panic("invalid bit:" + string(b) + ", " + string('0'))
		}
	}

	for minDigits > digits {
		bits = append([]bool{false}, bits...)
		digits++
	}

	return
}

func lib_GetEachDigitSumInt(n int) (sum int) {
	for _, digit := range lib_ToDigitSliceInt(n) {
		sum += int(digit)
	}
	return
}

func lib_ToDigitSliceInt(n int) (digits []int8) {
	nn := int64(n)
	for {
		if nn <= 0 {
			return lib_ReverseInt8(digits)
		}
		digit := int8(nn % 10) // FIXME
		digits = append(digits, digit)
		nn /= 10
	}
}

func lib_DigitsToInt(digits []int8) int {
	v := int(0)
	for i, digit := range digits {
		v += int(float64(digit) * math.Pow(10, float64(len(digits)-i-1)))
	}
	return v
}

func lib_GetEachDigitSumInt8(n int8) (sum int8) {
	for _, digit := range lib_ToDigitSliceInt8(n) {
		sum += int8(digit)
	}
	return
}

func lib_ToDigitSliceInt8(n int8) (digits []int8) {
	nn := int64(n)
	for {
		if nn <= 0 {
			return lib_ReverseInt8(digits)
		}
		digit := int8(nn % 10) // FIXME
		digits = append(digits, digit)
		nn /= 10
	}
}

func lib_DigitsToInt8(digits []int8) int8 {
	v := int8(0)
	for i, digit := range digits {
		v += int8(float64(digit) * math.Pow(10, float64(len(digits)-i-1)))
	}
	return v
}

func lib_GetEachDigitSumInt16(n int16) (sum int16) {
	for _, digit := range lib_ToDigitSliceInt16(n) {
		sum += int16(digit)
	}
	return
}

func lib_ToDigitSliceInt16(n int16) (digits []int8) {
	nn := int64(n)
	for {
		if nn <= 0 {
			return lib_ReverseInt8(digits)
		}
		digit := int8(nn % 10) // FIXME
		digits = append(digits, digit)
		nn /= 10
	}
}

func lib_DigitsToInt16(digits []int8) int16 {
	v := int16(0)
	for i, digit := range digits {
		v += int16(float64(digit) * math.Pow(10, float64(len(digits)-i-1)))
	}
	return v
}

func lib_GetEachDigitSumInt32(n int32) (sum int32) {
	for _, digit := range lib_ToDigitSliceInt32(n) {
		sum += int32(digit)
	}
	return
}

func lib_ToDigitSliceInt32(n int32) (digits []int8) {
	nn := int64(n)
	for {
		if nn <= 0 {
			return lib_ReverseInt8(digits)
		}
		digit := int8(nn % 10) // FIXME
		digits = append(digits, digit)
		nn /= 10
	}
}

func lib_DigitsToInt32(digits []int8) int32 {
	v := int32(0)
	for i, digit := range digits {
		v += int32(float64(digit) * math.Pow(10, float64(len(digits)-i-1)))
	}
	return v
}

func lib_GetEachDigitSumInt64(n int64) (sum int64) {
	for _, digit := range lib_ToDigitSliceInt64(n) {
		sum += int64(digit)
	}
	return
}

func lib_ToDigitSliceInt64(n int64) (digits []int8) {
	nn := int64(n)
	for {
		if nn <= 0 {
			return lib_ReverseInt8(digits)
		}
		digit := int8(nn % 10) // FIXME
		digits = append(digits, digit)
		nn /= 10
	}
}

func lib_DigitsToInt64(digits []int8) int64 {
	v := int64(0)
	for i, digit := range digits {
		v += int64(float64(digit) * math.Pow(10, float64(len(digits)-i-1)))
	}
	return v
}

func lib_GetEachDigitSumFloat32(n float32) (sum float32) {
	for _, digit := range lib_ToDigitSliceFloat32(n) {
		sum += float32(digit)
	}
	return
}

func lib_ToDigitSliceFloat32(n float32) (digits []int8) {
	nn := int64(n)
	for {
		if nn <= 0 {
			return lib_ReverseInt8(digits)
		}
		digit := int8(nn % 10) // FIXME
		digits = append(digits, digit)
		nn /= 10
	}
}

func lib_DigitsToFloat32(digits []int8) float32 {
	v := float32(0)
	for i, digit := range digits {
		v += float32(float64(digit) * math.Pow(10, float64(len(digits)-i-1)))
	}
	return v
}

func lib_GetEachDigitSumFloat64(n float64) (sum float64) {
	for _, digit := range lib_ToDigitSliceFloat64(n) {
		sum += float64(digit)
	}
	return
}

func lib_ToDigitSliceFloat64(n float64) (digits []int8) {
	nn := int64(n)
	for {
		if nn <= 0 {
			return lib_ReverseInt8(digits)
		}
		digit := int8(nn % 10) // FIXME
		digits = append(digits, digit)
		nn /= 10
	}
}

func lib_DigitsToFloat64(digits []int8) float64 {
	v := float64(0)
	for i, digit := range digits {
		v += float64(float64(digit) * math.Pow(10, float64(len(digits)-i-1)))
	}
	return v
}

func lib_SumInt(values []int) int {
	var sum int = 0
	for _, value := range values {
		sum += value
	}
	return sum
}

func lib_FilterInt(values []int, f func(v int) bool) (newValues []int) {
	for _, value := range values {
		if f(value) {
			newValues = append(newValues, value)
		}
	}
	return
}

func lib_UniqInt(values []int) (newValues []int) {
	m := map[int]bool{}
	for _, value := range values {
		m[value] = true
	}

	for key := range m {
		newValues = append(newValues, key)
	}
	return
}

func lib_SubtractIntBy(values1 []int, values2 []int, f func(v int) int) (newValues []int, err error) {
	if len(values1) != len(values2) {
		return nil, errors.New("two values lengths are different")
	}

	for i := 0; i < len(values1); i++ {
		fValue1 := f(values1[i])
		fValue2 := f(values2[i])
		newValues = append(newValues, fValue1-fValue2)
	}
	return newValues, nil
}

func lib_SubtractInt(values1 []int, values2 []int) (newValues []int, err error) {
	return lib_SubtractIntBy(values1, values2, func(v int) int {
		return v
	})
}

func lib_RDiffIntBy(values []int, f func(v int) int) (newValues []int, err error) {
	diffValues := append([]int{0}, values...)
	newValues, err = lib_SubtractIntBy(values, diffValues[:len(diffValues)-1], f)
	if err != nil {
		return nil, fmt.Errorf("failed to RDiff: %v", err)
	}
	return newValues[1:], nil
}

func lib_RDiffInt(values []int) (newValues []int, err error) {
	return lib_RDiffIntBy(values, func(v int) int {
		return v
	})
}

func lib_StringToIntSlice(s string) (ValueLine []int, err error) {
	for _, r := range s {
		v, err := strconv.ParseInt(string(r), 10, 64)
		if err != nil {
			return nil, err
		}
		ValueLine = append(ValueLine, int(v))
	}
	return
}

func lib_StringSliceToIntSlice(line []string) (ValueLine []int, err error) {
	newLine, err := lib_toSpecificBitIntLine(line, 64)
	if err != nil {
		return nil, err
	}
	for _, v := range newLine {
		ValueLine = append(ValueLine, int(v))
	}
	return
}

func lib_MaxInt(values []int) (max int, err error) {
	if len(values) == 0 {
		return 0, errors.New("empty slice is given")
	}

	max = values[0]
	for _, value := range values {
		if max < value {
			max = value
		}
	}
	return
}

func lib_MinInt(values []int) (min int, err error) {
	if len(values) == 0 {
		return 0, errors.New("empty slice is given")
	}

	min = values[0]
	for _, value := range values {
		if min > value {
			min = value
		}
	}
	return
}

func lib_NewIntGridMap(grid [][]string, defaultValue int) (m [][]int) {
	for _, line := range grid {
		var newLine []int
		for range line {
			newLine = append(newLine, defaultValue)
		}
		m = append(m, newLine)
	}
	return
}

func lib_IntRange(start, end, step int) []int {
	if end < start {
		return []int{}
	}
	s := make([]int, 0, int(1+(end-start)/step))
	for start < end {
		s = append(s, start)
		start += step
	}
	return s
}

func lib_SumInt8(values []int8) int8 {
	var sum int8 = 0
	for _, value := range values {
		sum += value
	}
	return sum
}

func lib_FilterInt8(values []int8, f func(v int8) bool) (newValues []int8) {
	for _, value := range values {
		if f(value) {
			newValues = append(newValues, value)
		}
	}
	return
}

func lib_UniqInt8(values []int8) (newValues []int8) {
	m := map[int8]bool{}
	for _, value := range values {
		m[value] = true
	}

	for key := range m {
		newValues = append(newValues, key)
	}
	return
}

func lib_SubtractInt8By(values1 []int8, values2 []int8, f func(v int8) int8) (newValues []int8, err error) {
	if len(values1) != len(values2) {
		return nil, errors.New("two values lengths are different")
	}

	for i := 0; i < len(values1); i++ {
		fValue1 := f(values1[i])
		fValue2 := f(values2[i])
		newValues = append(newValues, fValue1-fValue2)
	}
	return newValues, nil
}

func lib_SubtractInt8(values1 []int8, values2 []int8) (newValues []int8, err error) {
	return lib_SubtractInt8By(values1, values2, func(v int8) int8 {
		return v
	})
}

func lib_RDiffInt8By(values []int8, f func(v int8) int8) (newValues []int8, err error) {
	diffValues := append([]int8{0}, values...)
	newValues, err = lib_SubtractInt8By(values, diffValues[:len(diffValues)-1], f)
	if err != nil {
		return nil, fmt.Errorf("failed to RDiff: %v", err)
	}
	return newValues[1:], nil
}

func lib_RDiffInt8(values []int8) (newValues []int8, err error) {
	return lib_RDiffInt8By(values, func(v int8) int8 {
		return v
	})
}

func lib_StringToInt8Slice(s string) (ValueLine []int8, err error) {
	for _, r := range s {
		v, err := strconv.ParseInt(string(r), 10, 64)
		if err != nil {
			return nil, err
		}
		ValueLine = append(ValueLine, int8(v))
	}
	return
}

func lib_StringSliceToInt8Slice(line []string) (ValueLine []int8, err error) {
	newLine, err := lib_toSpecificBitIntLine(line, 64)
	if err != nil {
		return nil, err
	}
	for _, v := range newLine {
		ValueLine = append(ValueLine, int8(v))
	}
	return
}

func lib_MaxInt8(values []int8) (max int8, err error) {
	if len(values) == 0 {
		return 0, errors.New("empty slice is given")
	}

	max = values[0]
	for _, value := range values {
		if max < value {
			max = value
		}
	}
	return
}

func lib_MinInt8(values []int8) (min int8, err error) {
	if len(values) == 0 {
		return 0, errors.New("empty slice is given")
	}

	min = values[0]
	for _, value := range values {
		if min > value {
			min = value
		}
	}
	return
}

func lib_NewInt8GridMap(grid [][]string, defaultValue int8) (m [][]int8) {
	for _, line := range grid {
		var newLine []int8
		for range line {
			newLine = append(newLine, defaultValue)
		}
		m = append(m, newLine)
	}
	return
}

func lib_Int8Range(start, end, step int8) []int8 {
	if end < start {
		return []int8{}
	}
	s := make([]int8, 0, int(1+(end-start)/step))
	for start < end {
		s = append(s, start)
		start += step
	}
	return s
}

func lib_SumInt16(values []int16) int16 {
	var sum int16 = 0
	for _, value := range values {
		sum += value
	}
	return sum
}

func lib_FilterInt16(values []int16, f func(v int16) bool) (newValues []int16) {
	for _, value := range values {
		if f(value) {
			newValues = append(newValues, value)
		}
	}
	return
}

func lib_UniqInt16(values []int16) (newValues []int16) {
	m := map[int16]bool{}
	for _, value := range values {
		m[value] = true
	}

	for key := range m {
		newValues = append(newValues, key)
	}
	return
}

func lib_SubtractInt16By(values1 []int16, values2 []int16, f func(v int16) int16) (newValues []int16, err error) {
	if len(values1) != len(values2) {
		return nil, errors.New("two values lengths are different")
	}

	for i := 0; i < len(values1); i++ {
		fValue1 := f(values1[i])
		fValue2 := f(values2[i])
		newValues = append(newValues, fValue1-fValue2)
	}
	return newValues, nil
}

func lib_SubtractInt16(values1 []int16, values2 []int16) (newValues []int16, err error) {
	return lib_SubtractInt16By(values1, values2, func(v int16) int16 {
		return v
	})
}

func lib_RDiffInt16By(values []int16, f func(v int16) int16) (newValues []int16, err error) {
	diffValues := append([]int16{0}, values...)
	newValues, err = lib_SubtractInt16By(values, diffValues[:len(diffValues)-1], f)
	if err != nil {
		return nil, fmt.Errorf("failed to RDiff: %v", err)
	}
	return newValues[1:], nil
}

func lib_RDiffInt16(values []int16) (newValues []int16, err error) {
	return lib_RDiffInt16By(values, func(v int16) int16 {
		return v
	})
}

func lib_StringToInt16Slice(s string) (ValueLine []int16, err error) {
	for _, r := range s {
		v, err := strconv.ParseInt(string(r), 10, 64)
		if err != nil {
			return nil, err
		}
		ValueLine = append(ValueLine, int16(v))
	}
	return
}

func lib_StringSliceToInt16Slice(line []string) (ValueLine []int16, err error) {
	newLine, err := lib_toSpecificBitIntLine(line, 64)
	if err != nil {
		return nil, err
	}
	for _, v := range newLine {
		ValueLine = append(ValueLine, int16(v))
	}
	return
}

func lib_MaxInt16(values []int16) (max int16, err error) {
	if len(values) == 0 {
		return 0, errors.New("empty slice is given")
	}

	max = values[0]
	for _, value := range values {
		if max < value {
			max = value
		}
	}
	return
}

func lib_MinInt16(values []int16) (min int16, err error) {
	if len(values) == 0 {
		return 0, errors.New("empty slice is given")
	}

	min = values[0]
	for _, value := range values {
		if min > value {
			min = value
		}
	}
	return
}

func lib_NewInt16GridMap(grid [][]string, defaultValue int16) (m [][]int16) {
	for _, line := range grid {
		var newLine []int16
		for range line {
			newLine = append(newLine, defaultValue)
		}
		m = append(m, newLine)
	}
	return
}

func lib_Int16Range(start, end, step int16) []int16 {
	if end < start {
		return []int16{}
	}
	s := make([]int16, 0, int(1+(end-start)/step))
	for start < end {
		s = append(s, start)
		start += step
	}
	return s
}

func lib_SumInt32(values []int32) int32 {
	var sum int32 = 0
	for _, value := range values {
		sum += value
	}
	return sum
}

func lib_FilterInt32(values []int32, f func(v int32) bool) (newValues []int32) {
	for _, value := range values {
		if f(value) {
			newValues = append(newValues, value)
		}
	}
	return
}

func lib_UniqInt32(values []int32) (newValues []int32) {
	m := map[int32]bool{}
	for _, value := range values {
		m[value] = true
	}

	for key := range m {
		newValues = append(newValues, key)
	}
	return
}

func lib_SubtractInt32By(values1 []int32, values2 []int32, f func(v int32) int32) (newValues []int32, err error) {
	if len(values1) != len(values2) {
		return nil, errors.New("two values lengths are different")
	}

	for i := 0; i < len(values1); i++ {
		fValue1 := f(values1[i])
		fValue2 := f(values2[i])
		newValues = append(newValues, fValue1-fValue2)
	}
	return newValues, nil
}

func lib_SubtractInt32(values1 []int32, values2 []int32) (newValues []int32, err error) {
	return lib_SubtractInt32By(values1, values2, func(v int32) int32 {
		return v
	})
}

func lib_RDiffInt32By(values []int32, f func(v int32) int32) (newValues []int32, err error) {
	diffValues := append([]int32{0}, values...)
	newValues, err = lib_SubtractInt32By(values, diffValues[:len(diffValues)-1], f)
	if err != nil {
		return nil, fmt.Errorf("failed to RDiff: %v", err)
	}
	return newValues[1:], nil
}

func lib_RDiffInt32(values []int32) (newValues []int32, err error) {
	return lib_RDiffInt32By(values, func(v int32) int32 {
		return v
	})
}

func lib_StringToInt32Slice(s string) (ValueLine []int32, err error) {
	for _, r := range s {
		v, err := strconv.ParseInt(string(r), 10, 64)
		if err != nil {
			return nil, err
		}
		ValueLine = append(ValueLine, int32(v))
	}
	return
}

func lib_StringSliceToInt32Slice(line []string) (ValueLine []int32, err error) {
	newLine, err := lib_toSpecificBitIntLine(line, 64)
	if err != nil {
		return nil, err
	}
	for _, v := range newLine {
		ValueLine = append(ValueLine, int32(v))
	}
	return
}

func lib_MaxInt32(values []int32) (max int32, err error) {
	if len(values) == 0 {
		return 0, errors.New("empty slice is given")
	}

	max = values[0]
	for _, value := range values {
		if max < value {
			max = value
		}
	}
	return
}

func lib_MinInt32(values []int32) (min int32, err error) {
	if len(values) == 0 {
		return 0, errors.New("empty slice is given")
	}

	min = values[0]
	for _, value := range values {
		if min > value {
			min = value
		}
	}
	return
}

func lib_NewInt32GridMap(grid [][]string, defaultValue int32) (m [][]int32) {
	for _, line := range grid {
		var newLine []int32
		for range line {
			newLine = append(newLine, defaultValue)
		}
		m = append(m, newLine)
	}
	return
}

func lib_Int32Range(start, end, step int32) []int32 {
	if end < start {
		return []int32{}
	}
	s := make([]int32, 0, int(1+(end-start)/step))
	for start < end {
		s = append(s, start)
		start += step
	}
	return s
}

func lib_SumInt64(values []int64) int64 {
	var sum int64 = 0
	for _, value := range values {
		sum += value
	}
	return sum
}

func lib_FilterInt64(values []int64, f func(v int64) bool) (newValues []int64) {
	for _, value := range values {
		if f(value) {
			newValues = append(newValues, value)
		}
	}
	return
}

func lib_UniqInt64(values []int64) (newValues []int64) {
	m := map[int64]bool{}
	for _, value := range values {
		m[value] = true
	}

	for key := range m {
		newValues = append(newValues, key)
	}
	return
}

func lib_SubtractInt64By(values1 []int64, values2 []int64, f func(v int64) int64) (newValues []int64, err error) {
	if len(values1) != len(values2) {
		return nil, errors.New("two values lengths are different")
	}

	for i := 0; i < len(values1); i++ {
		fValue1 := f(values1[i])
		fValue2 := f(values2[i])
		newValues = append(newValues, fValue1-fValue2)
	}
	return newValues, nil
}

func lib_SubtractInt64(values1 []int64, values2 []int64) (newValues []int64, err error) {
	return lib_SubtractInt64By(values1, values2, func(v int64) int64 {
		return v
	})
}

func lib_RDiffInt64By(values []int64, f func(v int64) int64) (newValues []int64, err error) {
	diffValues := append([]int64{0}, values...)
	newValues, err = lib_SubtractInt64By(values, diffValues[:len(diffValues)-1], f)
	if err != nil {
		return nil, fmt.Errorf("failed to RDiff: %v", err)
	}
	return newValues[1:], nil
}

func lib_RDiffInt64(values []int64) (newValues []int64, err error) {
	return lib_RDiffInt64By(values, func(v int64) int64 {
		return v
	})
}

func lib_StringToInt64Slice(s string) (ValueLine []int64, err error) {
	for _, r := range s {
		v, err := strconv.ParseInt(string(r), 10, 64)
		if err != nil {
			return nil, err
		}
		ValueLine = append(ValueLine, int64(v))
	}
	return
}

func lib_StringSliceToInt64Slice(line []string) (ValueLine []int64, err error) {
	newLine, err := lib_toSpecificBitIntLine(line, 64)
	if err != nil {
		return nil, err
	}
	for _, v := range newLine {
		ValueLine = append(ValueLine, int64(v))
	}
	return
}

func lib_MaxInt64(values []int64) (max int64, err error) {
	if len(values) == 0 {
		return 0, errors.New("empty slice is given")
	}

	max = values[0]
	for _, value := range values {
		if max < value {
			max = value
		}
	}
	return
}

func lib_MinInt64(values []int64) (min int64, err error) {
	if len(values) == 0 {
		return 0, errors.New("empty slice is given")
	}

	min = values[0]
	for _, value := range values {
		if min > value {
			min = value
		}
	}
	return
}

func lib_NewInt64GridMap(grid [][]string, defaultValue int64) (m [][]int64) {
	for _, line := range grid {
		var newLine []int64
		for range line {
			newLine = append(newLine, defaultValue)
		}
		m = append(m, newLine)
	}
	return
}

func lib_Int64Range(start, end, step int64) []int64 {
	if end < start {
		return []int64{}
	}
	s := make([]int64, 0, int(1+(end-start)/step))
	for start < end {
		s = append(s, start)
		start += step
	}
	return s
}

func lib_SumFloat32(values []float32) float32 {
	var sum float32 = 0
	for _, value := range values {
		sum += value
	}
	return sum
}

func lib_FilterFloat32(values []float32, f func(v float32) bool) (newValues []float32) {
	for _, value := range values {
		if f(value) {
			newValues = append(newValues, value)
		}
	}
	return
}

func lib_UniqFloat32(values []float32) (newValues []float32) {
	m := map[float32]bool{}
	for _, value := range values {
		m[value] = true
	}

	for key := range m {
		newValues = append(newValues, key)
	}
	return
}

func lib_SubtractFloat32By(values1 []float32, values2 []float32, f func(v float32) float32) (newValues []float32, err error) {
	if len(values1) != len(values2) {
		return nil, errors.New("two values lengths are different")
	}

	for i := 0; i < len(values1); i++ {
		fValue1 := f(values1[i])
		fValue2 := f(values2[i])
		newValues = append(newValues, fValue1-fValue2)
	}
	return newValues, nil
}

func lib_SubtractFloat32(values1 []float32, values2 []float32) (newValues []float32, err error) {
	return lib_SubtractFloat32By(values1, values2, func(v float32) float32 {
		return v
	})
}

func lib_RDiffFloat32By(values []float32, f func(v float32) float32) (newValues []float32, err error) {
	diffValues := append([]float32{0}, values...)
	newValues, err = lib_SubtractFloat32By(values, diffValues[:len(diffValues)-1], f)
	if err != nil {
		return nil, fmt.Errorf("failed to RDiff: %v", err)
	}
	return newValues[1:], nil
}

func lib_RDiffFloat32(values []float32) (newValues []float32, err error) {
	return lib_RDiffFloat32By(values, func(v float32) float32 {
		return v
	})
}

func lib_StringToFloat32Slice(s string) (ValueLine []float32, err error) {
	for _, r := range s {
		v, err := strconv.ParseInt(string(r), 10, 64)
		if err != nil {
			return nil, err
		}
		ValueLine = append(ValueLine, float32(v))
	}
	return
}

func lib_StringSliceToFloat32Slice(line []string) (ValueLine []float32, err error) {
	newLine, err := lib_toSpecificBitIntLine(line, 64)
	if err != nil {
		return nil, err
	}
	for _, v := range newLine {
		ValueLine = append(ValueLine, float32(v))
	}
	return
}

func lib_MaxFloat32(values []float32) (max float32, err error) {
	if len(values) == 0 {
		return 0, errors.New("empty slice is given")
	}

	max = values[0]
	for _, value := range values {
		if max < value {
			max = value
		}
	}
	return
}

func lib_MinFloat32(values []float32) (min float32, err error) {
	if len(values) == 0 {
		return 0, errors.New("empty slice is given")
	}

	min = values[0]
	for _, value := range values {
		if min > value {
			min = value
		}
	}
	return
}

func lib_NewFloat32GridMap(grid [][]string, defaultValue float32) (m [][]float32) {
	for _, line := range grid {
		var newLine []float32
		for range line {
			newLine = append(newLine, defaultValue)
		}
		m = append(m, newLine)
	}
	return
}

func lib_Float32Range(start, end, step float32) []float32 {
	if end < start {
		return []float32{}
	}
	s := make([]float32, 0, int(1+(end-start)/step))
	for start < end {
		s = append(s, start)
		start += step
	}
	return s
}

func lib_SumFloat64(values []float64) float64 {
	var sum float64 = 0
	for _, value := range values {
		sum += value
	}
	return sum
}

func lib_FilterFloat64(values []float64, f func(v float64) bool) (newValues []float64) {
	for _, value := range values {
		if f(value) {
			newValues = append(newValues, value)
		}
	}
	return
}

func lib_UniqFloat64(values []float64) (newValues []float64) {
	m := map[float64]bool{}
	for _, value := range values {
		m[value] = true
	}

	for key := range m {
		newValues = append(newValues, key)
	}
	return
}

func lib_SubtractFloat64By(values1 []float64, values2 []float64, f func(v float64) float64) (newValues []float64, err error) {
	if len(values1) != len(values2) {
		return nil, errors.New("two values lengths are different")
	}

	for i := 0; i < len(values1); i++ {
		fValue1 := f(values1[i])
		fValue2 := f(values2[i])
		newValues = append(newValues, fValue1-fValue2)
	}
	return newValues, nil
}

func lib_SubtractFloat64(values1 []float64, values2 []float64) (newValues []float64, err error) {
	return lib_SubtractFloat64By(values1, values2, func(v float64) float64 {
		return v
	})
}

func lib_RDiffFloat64By(values []float64, f func(v float64) float64) (newValues []float64, err error) {
	diffValues := append([]float64{0}, values...)
	newValues, err = lib_SubtractFloat64By(values, diffValues[:len(diffValues)-1], f)
	if err != nil {
		return nil, fmt.Errorf("failed to RDiff: %v", err)
	}
	return newValues[1:], nil
}

func lib_RDiffFloat64(values []float64) (newValues []float64, err error) {
	return lib_RDiffFloat64By(values, func(v float64) float64 {
		return v
	})
}

func lib_StringToFloat64Slice(s string) (ValueLine []float64, err error) {
	for _, r := range s {
		v, err := strconv.ParseInt(string(r), 10, 64)
		if err != nil {
			return nil, err
		}
		ValueLine = append(ValueLine, float64(v))
	}
	return
}

func lib_StringSliceToFloat64Slice(line []string) (ValueLine []float64, err error) {
	newLine, err := lib_toSpecificBitIntLine(line, 64)
	if err != nil {
		return nil, err
	}
	for _, v := range newLine {
		ValueLine = append(ValueLine, float64(v))
	}
	return
}

func lib_MaxFloat64(values []float64) (max float64, err error) {
	if len(values) == 0 {
		return 0, errors.New("empty slice is given")
	}

	max = values[0]
	for _, value := range values {
		if max < value {
			max = value
		}
	}
	return
}

func lib_MinFloat64(values []float64) (min float64, err error) {
	if len(values) == 0 {
		return 0, errors.New("empty slice is given")
	}

	min = values[0]
	for _, value := range values {
		if min > value {
			min = value
		}
	}
	return
}

func lib_NewFloat64GridMap(grid [][]string, defaultValue float64) (m [][]float64) {
	for _, line := range grid {
		var newLine []float64
		for range line {
			newLine = append(newLine, defaultValue)
		}
		m = append(m, newLine)
	}
	return
}

func lib_Float64Range(start, end, step float64) []float64 {
	if end < start {
		return []float64{}
	}
	s := make([]float64, 0, int(1+(end-start)/step))
	for start < end {
		s = append(s, start)
		start += step
	}
	return s
}

func lib_SumIntByInt(values []int, f func(v int) int) int {
	var sum int = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_IntSliceToIntSlice(values []int) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, int(value))
	}
	return
}

func lib_MapIntSliceToInt(values [][]int, f func(v []int) int) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapIntSlice2ToInt(values [][][]int, f func(v [][]int) int) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxIntByIntSlice(values [][]int, f func(vs []int) int) (max int, err error) {
	return lib_MaxInt(lib_MapIntSliceToInt(values, f))
}

func lib_MaxIntByIntSlice2(values [][][]int, f func(vs [][]int) int) (max int, err error) {
	return lib_MaxInt(lib_MapIntSlice2ToInt(values, f))
}

func lib_SumIntByInt8(values []int, f func(v int) int8) int8 {
	var sum int8 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_IntSliceToInt8Slice(values []int) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, int8(value))
	}
	return
}

func lib_MapInt8SliceToInt(values [][]int8, f func(v []int8) int) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt8Slice2ToInt(values [][][]int8, f func(v [][]int8) int) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxIntByInt8Slice(values [][]int8, f func(vs []int8) int) (max int, err error) {
	return lib_MaxInt(lib_MapInt8SliceToInt(values, f))
}

func lib_MaxIntByInt8Slice2(values [][][]int8, f func(vs [][]int8) int) (max int, err error) {
	return lib_MaxInt(lib_MapInt8Slice2ToInt(values, f))
}

func lib_SumIntByInt16(values []int, f func(v int) int16) int16 {
	var sum int16 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_IntSliceToInt16Slice(values []int) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, int16(value))
	}
	return
}

func lib_MapInt16SliceToInt(values [][]int16, f func(v []int16) int) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt16Slice2ToInt(values [][][]int16, f func(v [][]int16) int) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxIntByInt16Slice(values [][]int16, f func(vs []int16) int) (max int, err error) {
	return lib_MaxInt(lib_MapInt16SliceToInt(values, f))
}

func lib_MaxIntByInt16Slice2(values [][][]int16, f func(vs [][]int16) int) (max int, err error) {
	return lib_MaxInt(lib_MapInt16Slice2ToInt(values, f))
}

func lib_SumIntByInt32(values []int, f func(v int) int32) int32 {
	var sum int32 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_IntSliceToInt32Slice(values []int) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, int32(value))
	}
	return
}

func lib_MapInt32SliceToInt(values [][]int32, f func(v []int32) int) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt32Slice2ToInt(values [][][]int32, f func(v [][]int32) int) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxIntByInt32Slice(values [][]int32, f func(vs []int32) int) (max int, err error) {
	return lib_MaxInt(lib_MapInt32SliceToInt(values, f))
}

func lib_MaxIntByInt32Slice2(values [][][]int32, f func(vs [][]int32) int) (max int, err error) {
	return lib_MaxInt(lib_MapInt32Slice2ToInt(values, f))
}

func lib_SumIntByInt64(values []int, f func(v int) int64) int64 {
	var sum int64 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_IntSliceToInt64Slice(values []int) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, int64(value))
	}
	return
}

func lib_MapInt64SliceToInt(values [][]int64, f func(v []int64) int) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt64Slice2ToInt(values [][][]int64, f func(v [][]int64) int) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxIntByInt64Slice(values [][]int64, f func(vs []int64) int) (max int, err error) {
	return lib_MaxInt(lib_MapInt64SliceToInt(values, f))
}

func lib_MaxIntByInt64Slice2(values [][][]int64, f func(vs [][]int64) int) (max int, err error) {
	return lib_MaxInt(lib_MapInt64Slice2ToInt(values, f))
}

func lib_SumIntByFloat32(values []int, f func(v int) float32) float32 {
	var sum float32 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_IntSliceToFloat32Slice(values []int) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, float32(value))
	}
	return
}

func lib_MapFloat32SliceToInt(values [][]float32, f func(v []float32) int) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapFloat32Slice2ToInt(values [][][]float32, f func(v [][]float32) int) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxIntByFloat32Slice(values [][]float32, f func(vs []float32) int) (max int, err error) {
	return lib_MaxInt(lib_MapFloat32SliceToInt(values, f))
}

func lib_MaxIntByFloat32Slice2(values [][][]float32, f func(vs [][]float32) int) (max int, err error) {
	return lib_MaxInt(lib_MapFloat32Slice2ToInt(values, f))
}

func lib_SumIntByFloat64(values []int, f func(v int) float64) float64 {
	var sum float64 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_IntSliceToFloat64Slice(values []int) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, float64(value))
	}
	return
}

func lib_MapFloat64SliceToInt(values [][]float64, f func(v []float64) int) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapFloat64Slice2ToInt(values [][][]float64, f func(v [][]float64) int) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxIntByFloat64Slice(values [][]float64, f func(vs []float64) int) (max int, err error) {
	return lib_MaxInt(lib_MapFloat64SliceToInt(values, f))
}

func lib_MaxIntByFloat64Slice2(values [][][]float64, f func(vs [][]float64) int) (max int, err error) {
	return lib_MaxInt(lib_MapFloat64Slice2ToInt(values, f))
}

func lib_SumInt8ByInt(values []int8, f func(v int8) int) int {
	var sum int = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int8SliceToIntSlice(values []int8) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, int(value))
	}
	return
}

func lib_MapIntSliceToInt8(values [][]int, f func(v []int) int8) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapIntSlice2ToInt8(values [][][]int, f func(v [][]int) int8) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt8ByIntSlice(values [][]int, f func(vs []int) int8) (max int8, err error) {
	return lib_MaxInt8(lib_MapIntSliceToInt8(values, f))
}

func lib_MaxInt8ByIntSlice2(values [][][]int, f func(vs [][]int) int8) (max int8, err error) {
	return lib_MaxInt8(lib_MapIntSlice2ToInt8(values, f))
}

func lib_SumInt8ByInt8(values []int8, f func(v int8) int8) int8 {
	var sum int8 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int8SliceToInt8Slice(values []int8) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, int8(value))
	}
	return
}

func lib_MapInt8SliceToInt8(values [][]int8, f func(v []int8) int8) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt8Slice2ToInt8(values [][][]int8, f func(v [][]int8) int8) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt8ByInt8Slice(values [][]int8, f func(vs []int8) int8) (max int8, err error) {
	return lib_MaxInt8(lib_MapInt8SliceToInt8(values, f))
}

func lib_MaxInt8ByInt8Slice2(values [][][]int8, f func(vs [][]int8) int8) (max int8, err error) {
	return lib_MaxInt8(lib_MapInt8Slice2ToInt8(values, f))
}

func lib_SumInt8ByInt16(values []int8, f func(v int8) int16) int16 {
	var sum int16 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int8SliceToInt16Slice(values []int8) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, int16(value))
	}
	return
}

func lib_MapInt16SliceToInt8(values [][]int16, f func(v []int16) int8) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt16Slice2ToInt8(values [][][]int16, f func(v [][]int16) int8) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt8ByInt16Slice(values [][]int16, f func(vs []int16) int8) (max int8, err error) {
	return lib_MaxInt8(lib_MapInt16SliceToInt8(values, f))
}

func lib_MaxInt8ByInt16Slice2(values [][][]int16, f func(vs [][]int16) int8) (max int8, err error) {
	return lib_MaxInt8(lib_MapInt16Slice2ToInt8(values, f))
}

func lib_SumInt8ByInt32(values []int8, f func(v int8) int32) int32 {
	var sum int32 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int8SliceToInt32Slice(values []int8) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, int32(value))
	}
	return
}

func lib_MapInt32SliceToInt8(values [][]int32, f func(v []int32) int8) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt32Slice2ToInt8(values [][][]int32, f func(v [][]int32) int8) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt8ByInt32Slice(values [][]int32, f func(vs []int32) int8) (max int8, err error) {
	return lib_MaxInt8(lib_MapInt32SliceToInt8(values, f))
}

func lib_MaxInt8ByInt32Slice2(values [][][]int32, f func(vs [][]int32) int8) (max int8, err error) {
	return lib_MaxInt8(lib_MapInt32Slice2ToInt8(values, f))
}

func lib_SumInt8ByInt64(values []int8, f func(v int8) int64) int64 {
	var sum int64 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int8SliceToInt64Slice(values []int8) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, int64(value))
	}
	return
}

func lib_MapInt64SliceToInt8(values [][]int64, f func(v []int64) int8) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt64Slice2ToInt8(values [][][]int64, f func(v [][]int64) int8) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt8ByInt64Slice(values [][]int64, f func(vs []int64) int8) (max int8, err error) {
	return lib_MaxInt8(lib_MapInt64SliceToInt8(values, f))
}

func lib_MaxInt8ByInt64Slice2(values [][][]int64, f func(vs [][]int64) int8) (max int8, err error) {
	return lib_MaxInt8(lib_MapInt64Slice2ToInt8(values, f))
}

func lib_SumInt8ByFloat32(values []int8, f func(v int8) float32) float32 {
	var sum float32 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int8SliceToFloat32Slice(values []int8) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, float32(value))
	}
	return
}

func lib_MapFloat32SliceToInt8(values [][]float32, f func(v []float32) int8) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapFloat32Slice2ToInt8(values [][][]float32, f func(v [][]float32) int8) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt8ByFloat32Slice(values [][]float32, f func(vs []float32) int8) (max int8, err error) {
	return lib_MaxInt8(lib_MapFloat32SliceToInt8(values, f))
}

func lib_MaxInt8ByFloat32Slice2(values [][][]float32, f func(vs [][]float32) int8) (max int8, err error) {
	return lib_MaxInt8(lib_MapFloat32Slice2ToInt8(values, f))
}

func lib_SumInt8ByFloat64(values []int8, f func(v int8) float64) float64 {
	var sum float64 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int8SliceToFloat64Slice(values []int8) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, float64(value))
	}
	return
}

func lib_MapFloat64SliceToInt8(values [][]float64, f func(v []float64) int8) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapFloat64Slice2ToInt8(values [][][]float64, f func(v [][]float64) int8) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt8ByFloat64Slice(values [][]float64, f func(vs []float64) int8) (max int8, err error) {
	return lib_MaxInt8(lib_MapFloat64SliceToInt8(values, f))
}

func lib_MaxInt8ByFloat64Slice2(values [][][]float64, f func(vs [][]float64) int8) (max int8, err error) {
	return lib_MaxInt8(lib_MapFloat64Slice2ToInt8(values, f))
}

func lib_SumInt16ByInt(values []int16, f func(v int16) int) int {
	var sum int = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int16SliceToIntSlice(values []int16) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, int(value))
	}
	return
}

func lib_MapIntSliceToInt16(values [][]int, f func(v []int) int16) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapIntSlice2ToInt16(values [][][]int, f func(v [][]int) int16) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt16ByIntSlice(values [][]int, f func(vs []int) int16) (max int16, err error) {
	return lib_MaxInt16(lib_MapIntSliceToInt16(values, f))
}

func lib_MaxInt16ByIntSlice2(values [][][]int, f func(vs [][]int) int16) (max int16, err error) {
	return lib_MaxInt16(lib_MapIntSlice2ToInt16(values, f))
}

func lib_SumInt16ByInt8(values []int16, f func(v int16) int8) int8 {
	var sum int8 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int16SliceToInt8Slice(values []int16) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, int8(value))
	}
	return
}

func lib_MapInt8SliceToInt16(values [][]int8, f func(v []int8) int16) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt8Slice2ToInt16(values [][][]int8, f func(v [][]int8) int16) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt16ByInt8Slice(values [][]int8, f func(vs []int8) int16) (max int16, err error) {
	return lib_MaxInt16(lib_MapInt8SliceToInt16(values, f))
}

func lib_MaxInt16ByInt8Slice2(values [][][]int8, f func(vs [][]int8) int16) (max int16, err error) {
	return lib_MaxInt16(lib_MapInt8Slice2ToInt16(values, f))
}

func lib_SumInt16ByInt16(values []int16, f func(v int16) int16) int16 {
	var sum int16 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int16SliceToInt16Slice(values []int16) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, int16(value))
	}
	return
}

func lib_MapInt16SliceToInt16(values [][]int16, f func(v []int16) int16) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt16Slice2ToInt16(values [][][]int16, f func(v [][]int16) int16) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt16ByInt16Slice(values [][]int16, f func(vs []int16) int16) (max int16, err error) {
	return lib_MaxInt16(lib_MapInt16SliceToInt16(values, f))
}

func lib_MaxInt16ByInt16Slice2(values [][][]int16, f func(vs [][]int16) int16) (max int16, err error) {
	return lib_MaxInt16(lib_MapInt16Slice2ToInt16(values, f))
}

func lib_SumInt16ByInt32(values []int16, f func(v int16) int32) int32 {
	var sum int32 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int16SliceToInt32Slice(values []int16) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, int32(value))
	}
	return
}

func lib_MapInt32SliceToInt16(values [][]int32, f func(v []int32) int16) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt32Slice2ToInt16(values [][][]int32, f func(v [][]int32) int16) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt16ByInt32Slice(values [][]int32, f func(vs []int32) int16) (max int16, err error) {
	return lib_MaxInt16(lib_MapInt32SliceToInt16(values, f))
}

func lib_MaxInt16ByInt32Slice2(values [][][]int32, f func(vs [][]int32) int16) (max int16, err error) {
	return lib_MaxInt16(lib_MapInt32Slice2ToInt16(values, f))
}

func lib_SumInt16ByInt64(values []int16, f func(v int16) int64) int64 {
	var sum int64 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int16SliceToInt64Slice(values []int16) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, int64(value))
	}
	return
}

func lib_MapInt64SliceToInt16(values [][]int64, f func(v []int64) int16) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt64Slice2ToInt16(values [][][]int64, f func(v [][]int64) int16) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt16ByInt64Slice(values [][]int64, f func(vs []int64) int16) (max int16, err error) {
	return lib_MaxInt16(lib_MapInt64SliceToInt16(values, f))
}

func lib_MaxInt16ByInt64Slice2(values [][][]int64, f func(vs [][]int64) int16) (max int16, err error) {
	return lib_MaxInt16(lib_MapInt64Slice2ToInt16(values, f))
}

func lib_SumInt16ByFloat32(values []int16, f func(v int16) float32) float32 {
	var sum float32 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int16SliceToFloat32Slice(values []int16) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, float32(value))
	}
	return
}

func lib_MapFloat32SliceToInt16(values [][]float32, f func(v []float32) int16) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapFloat32Slice2ToInt16(values [][][]float32, f func(v [][]float32) int16) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt16ByFloat32Slice(values [][]float32, f func(vs []float32) int16) (max int16, err error) {
	return lib_MaxInt16(lib_MapFloat32SliceToInt16(values, f))
}

func lib_MaxInt16ByFloat32Slice2(values [][][]float32, f func(vs [][]float32) int16) (max int16, err error) {
	return lib_MaxInt16(lib_MapFloat32Slice2ToInt16(values, f))
}

func lib_SumInt16ByFloat64(values []int16, f func(v int16) float64) float64 {
	var sum float64 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int16SliceToFloat64Slice(values []int16) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, float64(value))
	}
	return
}

func lib_MapFloat64SliceToInt16(values [][]float64, f func(v []float64) int16) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapFloat64Slice2ToInt16(values [][][]float64, f func(v [][]float64) int16) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt16ByFloat64Slice(values [][]float64, f func(vs []float64) int16) (max int16, err error) {
	return lib_MaxInt16(lib_MapFloat64SliceToInt16(values, f))
}

func lib_MaxInt16ByFloat64Slice2(values [][][]float64, f func(vs [][]float64) int16) (max int16, err error) {
	return lib_MaxInt16(lib_MapFloat64Slice2ToInt16(values, f))
}

func lib_SumInt32ByInt(values []int32, f func(v int32) int) int {
	var sum int = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int32SliceToIntSlice(values []int32) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, int(value))
	}
	return
}

func lib_MapIntSliceToInt32(values [][]int, f func(v []int) int32) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapIntSlice2ToInt32(values [][][]int, f func(v [][]int) int32) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt32ByIntSlice(values [][]int, f func(vs []int) int32) (max int32, err error) {
	return lib_MaxInt32(lib_MapIntSliceToInt32(values, f))
}

func lib_MaxInt32ByIntSlice2(values [][][]int, f func(vs [][]int) int32) (max int32, err error) {
	return lib_MaxInt32(lib_MapIntSlice2ToInt32(values, f))
}

func lib_SumInt32ByInt8(values []int32, f func(v int32) int8) int8 {
	var sum int8 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int32SliceToInt8Slice(values []int32) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, int8(value))
	}
	return
}

func lib_MapInt8SliceToInt32(values [][]int8, f func(v []int8) int32) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt8Slice2ToInt32(values [][][]int8, f func(v [][]int8) int32) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt32ByInt8Slice(values [][]int8, f func(vs []int8) int32) (max int32, err error) {
	return lib_MaxInt32(lib_MapInt8SliceToInt32(values, f))
}

func lib_MaxInt32ByInt8Slice2(values [][][]int8, f func(vs [][]int8) int32) (max int32, err error) {
	return lib_MaxInt32(lib_MapInt8Slice2ToInt32(values, f))
}

func lib_SumInt32ByInt16(values []int32, f func(v int32) int16) int16 {
	var sum int16 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int32SliceToInt16Slice(values []int32) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, int16(value))
	}
	return
}

func lib_MapInt16SliceToInt32(values [][]int16, f func(v []int16) int32) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt16Slice2ToInt32(values [][][]int16, f func(v [][]int16) int32) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt32ByInt16Slice(values [][]int16, f func(vs []int16) int32) (max int32, err error) {
	return lib_MaxInt32(lib_MapInt16SliceToInt32(values, f))
}

func lib_MaxInt32ByInt16Slice2(values [][][]int16, f func(vs [][]int16) int32) (max int32, err error) {
	return lib_MaxInt32(lib_MapInt16Slice2ToInt32(values, f))
}

func lib_SumInt32ByInt32(values []int32, f func(v int32) int32) int32 {
	var sum int32 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int32SliceToInt32Slice(values []int32) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, int32(value))
	}
	return
}

func lib_MapInt32SliceToInt32(values [][]int32, f func(v []int32) int32) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt32Slice2ToInt32(values [][][]int32, f func(v [][]int32) int32) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt32ByInt32Slice(values [][]int32, f func(vs []int32) int32) (max int32, err error) {
	return lib_MaxInt32(lib_MapInt32SliceToInt32(values, f))
}

func lib_MaxInt32ByInt32Slice2(values [][][]int32, f func(vs [][]int32) int32) (max int32, err error) {
	return lib_MaxInt32(lib_MapInt32Slice2ToInt32(values, f))
}

func lib_SumInt32ByInt64(values []int32, f func(v int32) int64) int64 {
	var sum int64 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int32SliceToInt64Slice(values []int32) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, int64(value))
	}
	return
}

func lib_MapInt64SliceToInt32(values [][]int64, f func(v []int64) int32) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt64Slice2ToInt32(values [][][]int64, f func(v [][]int64) int32) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt32ByInt64Slice(values [][]int64, f func(vs []int64) int32) (max int32, err error) {
	return lib_MaxInt32(lib_MapInt64SliceToInt32(values, f))
}

func lib_MaxInt32ByInt64Slice2(values [][][]int64, f func(vs [][]int64) int32) (max int32, err error) {
	return lib_MaxInt32(lib_MapInt64Slice2ToInt32(values, f))
}

func lib_SumInt32ByFloat32(values []int32, f func(v int32) float32) float32 {
	var sum float32 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int32SliceToFloat32Slice(values []int32) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, float32(value))
	}
	return
}

func lib_MapFloat32SliceToInt32(values [][]float32, f func(v []float32) int32) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapFloat32Slice2ToInt32(values [][][]float32, f func(v [][]float32) int32) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt32ByFloat32Slice(values [][]float32, f func(vs []float32) int32) (max int32, err error) {
	return lib_MaxInt32(lib_MapFloat32SliceToInt32(values, f))
}

func lib_MaxInt32ByFloat32Slice2(values [][][]float32, f func(vs [][]float32) int32) (max int32, err error) {
	return lib_MaxInt32(lib_MapFloat32Slice2ToInt32(values, f))
}

func lib_SumInt32ByFloat64(values []int32, f func(v int32) float64) float64 {
	var sum float64 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int32SliceToFloat64Slice(values []int32) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, float64(value))
	}
	return
}

func lib_MapFloat64SliceToInt32(values [][]float64, f func(v []float64) int32) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapFloat64Slice2ToInt32(values [][][]float64, f func(v [][]float64) int32) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt32ByFloat64Slice(values [][]float64, f func(vs []float64) int32) (max int32, err error) {
	return lib_MaxInt32(lib_MapFloat64SliceToInt32(values, f))
}

func lib_MaxInt32ByFloat64Slice2(values [][][]float64, f func(vs [][]float64) int32) (max int32, err error) {
	return lib_MaxInt32(lib_MapFloat64Slice2ToInt32(values, f))
}

func lib_SumInt64ByInt(values []int64, f func(v int64) int) int {
	var sum int = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int64SliceToIntSlice(values []int64) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, int(value))
	}
	return
}

func lib_MapIntSliceToInt64(values [][]int, f func(v []int) int64) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapIntSlice2ToInt64(values [][][]int, f func(v [][]int) int64) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt64ByIntSlice(values [][]int, f func(vs []int) int64) (max int64, err error) {
	return lib_MaxInt64(lib_MapIntSliceToInt64(values, f))
}

func lib_MaxInt64ByIntSlice2(values [][][]int, f func(vs [][]int) int64) (max int64, err error) {
	return lib_MaxInt64(lib_MapIntSlice2ToInt64(values, f))
}

func lib_SumInt64ByInt8(values []int64, f func(v int64) int8) int8 {
	var sum int8 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int64SliceToInt8Slice(values []int64) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, int8(value))
	}
	return
}

func lib_MapInt8SliceToInt64(values [][]int8, f func(v []int8) int64) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt8Slice2ToInt64(values [][][]int8, f func(v [][]int8) int64) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt64ByInt8Slice(values [][]int8, f func(vs []int8) int64) (max int64, err error) {
	return lib_MaxInt64(lib_MapInt8SliceToInt64(values, f))
}

func lib_MaxInt64ByInt8Slice2(values [][][]int8, f func(vs [][]int8) int64) (max int64, err error) {
	return lib_MaxInt64(lib_MapInt8Slice2ToInt64(values, f))
}

func lib_SumInt64ByInt16(values []int64, f func(v int64) int16) int16 {
	var sum int16 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int64SliceToInt16Slice(values []int64) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, int16(value))
	}
	return
}

func lib_MapInt16SliceToInt64(values [][]int16, f func(v []int16) int64) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt16Slice2ToInt64(values [][][]int16, f func(v [][]int16) int64) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt64ByInt16Slice(values [][]int16, f func(vs []int16) int64) (max int64, err error) {
	return lib_MaxInt64(lib_MapInt16SliceToInt64(values, f))
}

func lib_MaxInt64ByInt16Slice2(values [][][]int16, f func(vs [][]int16) int64) (max int64, err error) {
	return lib_MaxInt64(lib_MapInt16Slice2ToInt64(values, f))
}

func lib_SumInt64ByInt32(values []int64, f func(v int64) int32) int32 {
	var sum int32 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int64SliceToInt32Slice(values []int64) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, int32(value))
	}
	return
}

func lib_MapInt32SliceToInt64(values [][]int32, f func(v []int32) int64) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt32Slice2ToInt64(values [][][]int32, f func(v [][]int32) int64) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt64ByInt32Slice(values [][]int32, f func(vs []int32) int64) (max int64, err error) {
	return lib_MaxInt64(lib_MapInt32SliceToInt64(values, f))
}

func lib_MaxInt64ByInt32Slice2(values [][][]int32, f func(vs [][]int32) int64) (max int64, err error) {
	return lib_MaxInt64(lib_MapInt32Slice2ToInt64(values, f))
}

func lib_SumInt64ByInt64(values []int64, f func(v int64) int64) int64 {
	var sum int64 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int64SliceToInt64Slice(values []int64) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, int64(value))
	}
	return
}

func lib_MapInt64SliceToInt64(values [][]int64, f func(v []int64) int64) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt64Slice2ToInt64(values [][][]int64, f func(v [][]int64) int64) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt64ByInt64Slice(values [][]int64, f func(vs []int64) int64) (max int64, err error) {
	return lib_MaxInt64(lib_MapInt64SliceToInt64(values, f))
}

func lib_MaxInt64ByInt64Slice2(values [][][]int64, f func(vs [][]int64) int64) (max int64, err error) {
	return lib_MaxInt64(lib_MapInt64Slice2ToInt64(values, f))
}

func lib_SumInt64ByFloat32(values []int64, f func(v int64) float32) float32 {
	var sum float32 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int64SliceToFloat32Slice(values []int64) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, float32(value))
	}
	return
}

func lib_MapFloat32SliceToInt64(values [][]float32, f func(v []float32) int64) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapFloat32Slice2ToInt64(values [][][]float32, f func(v [][]float32) int64) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt64ByFloat32Slice(values [][]float32, f func(vs []float32) int64) (max int64, err error) {
	return lib_MaxInt64(lib_MapFloat32SliceToInt64(values, f))
}

func lib_MaxInt64ByFloat32Slice2(values [][][]float32, f func(vs [][]float32) int64) (max int64, err error) {
	return lib_MaxInt64(lib_MapFloat32Slice2ToInt64(values, f))
}

func lib_SumInt64ByFloat64(values []int64, f func(v int64) float64) float64 {
	var sum float64 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int64SliceToFloat64Slice(values []int64) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, float64(value))
	}
	return
}

func lib_MapFloat64SliceToInt64(values [][]float64, f func(v []float64) int64) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapFloat64Slice2ToInt64(values [][][]float64, f func(v [][]float64) int64) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt64ByFloat64Slice(values [][]float64, f func(vs []float64) int64) (max int64, err error) {
	return lib_MaxInt64(lib_MapFloat64SliceToInt64(values, f))
}

func lib_MaxInt64ByFloat64Slice2(values [][][]float64, f func(vs [][]float64) int64) (max int64, err error) {
	return lib_MaxInt64(lib_MapFloat64Slice2ToInt64(values, f))
}

func lib_SumFloat32ByInt(values []float32, f func(v float32) int) int {
	var sum int = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Float32SliceToIntSlice(values []float32) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, int(value))
	}
	return
}

func lib_MapIntSliceToFloat32(values [][]int, f func(v []int) float32) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapIntSlice2ToFloat32(values [][][]int, f func(v [][]int) float32) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxFloat32ByIntSlice(values [][]int, f func(vs []int) float32) (max float32, err error) {
	return lib_MaxFloat32(lib_MapIntSliceToFloat32(values, f))
}

func lib_MaxFloat32ByIntSlice2(values [][][]int, f func(vs [][]int) float32) (max float32, err error) {
	return lib_MaxFloat32(lib_MapIntSlice2ToFloat32(values, f))
}

func lib_SumFloat32ByInt8(values []float32, f func(v float32) int8) int8 {
	var sum int8 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Float32SliceToInt8Slice(values []float32) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, int8(value))
	}
	return
}

func lib_MapInt8SliceToFloat32(values [][]int8, f func(v []int8) float32) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt8Slice2ToFloat32(values [][][]int8, f func(v [][]int8) float32) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxFloat32ByInt8Slice(values [][]int8, f func(vs []int8) float32) (max float32, err error) {
	return lib_MaxFloat32(lib_MapInt8SliceToFloat32(values, f))
}

func lib_MaxFloat32ByInt8Slice2(values [][][]int8, f func(vs [][]int8) float32) (max float32, err error) {
	return lib_MaxFloat32(lib_MapInt8Slice2ToFloat32(values, f))
}

func lib_SumFloat32ByInt16(values []float32, f func(v float32) int16) int16 {
	var sum int16 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Float32SliceToInt16Slice(values []float32) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, int16(value))
	}
	return
}

func lib_MapInt16SliceToFloat32(values [][]int16, f func(v []int16) float32) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt16Slice2ToFloat32(values [][][]int16, f func(v [][]int16) float32) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxFloat32ByInt16Slice(values [][]int16, f func(vs []int16) float32) (max float32, err error) {
	return lib_MaxFloat32(lib_MapInt16SliceToFloat32(values, f))
}

func lib_MaxFloat32ByInt16Slice2(values [][][]int16, f func(vs [][]int16) float32) (max float32, err error) {
	return lib_MaxFloat32(lib_MapInt16Slice2ToFloat32(values, f))
}

func lib_SumFloat32ByInt32(values []float32, f func(v float32) int32) int32 {
	var sum int32 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Float32SliceToInt32Slice(values []float32) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, int32(value))
	}
	return
}

func lib_MapInt32SliceToFloat32(values [][]int32, f func(v []int32) float32) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt32Slice2ToFloat32(values [][][]int32, f func(v [][]int32) float32) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxFloat32ByInt32Slice(values [][]int32, f func(vs []int32) float32) (max float32, err error) {
	return lib_MaxFloat32(lib_MapInt32SliceToFloat32(values, f))
}

func lib_MaxFloat32ByInt32Slice2(values [][][]int32, f func(vs [][]int32) float32) (max float32, err error) {
	return lib_MaxFloat32(lib_MapInt32Slice2ToFloat32(values, f))
}

func lib_SumFloat32ByInt64(values []float32, f func(v float32) int64) int64 {
	var sum int64 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Float32SliceToInt64Slice(values []float32) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, int64(value))
	}
	return
}

func lib_MapInt64SliceToFloat32(values [][]int64, f func(v []int64) float32) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt64Slice2ToFloat32(values [][][]int64, f func(v [][]int64) float32) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxFloat32ByInt64Slice(values [][]int64, f func(vs []int64) float32) (max float32, err error) {
	return lib_MaxFloat32(lib_MapInt64SliceToFloat32(values, f))
}

func lib_MaxFloat32ByInt64Slice2(values [][][]int64, f func(vs [][]int64) float32) (max float32, err error) {
	return lib_MaxFloat32(lib_MapInt64Slice2ToFloat32(values, f))
}

func lib_SumFloat32ByFloat32(values []float32, f func(v float32) float32) float32 {
	var sum float32 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Float32SliceToFloat32Slice(values []float32) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, float32(value))
	}
	return
}

func lib_MapFloat32SliceToFloat32(values [][]float32, f func(v []float32) float32) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapFloat32Slice2ToFloat32(values [][][]float32, f func(v [][]float32) float32) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxFloat32ByFloat32Slice(values [][]float32, f func(vs []float32) float32) (max float32, err error) {
	return lib_MaxFloat32(lib_MapFloat32SliceToFloat32(values, f))
}

func lib_MaxFloat32ByFloat32Slice2(values [][][]float32, f func(vs [][]float32) float32) (max float32, err error) {
	return lib_MaxFloat32(lib_MapFloat32Slice2ToFloat32(values, f))
}

func lib_SumFloat32ByFloat64(values []float32, f func(v float32) float64) float64 {
	var sum float64 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Float32SliceToFloat64Slice(values []float32) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, float64(value))
	}
	return
}

func lib_MapFloat64SliceToFloat32(values [][]float64, f func(v []float64) float32) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapFloat64Slice2ToFloat32(values [][][]float64, f func(v [][]float64) float32) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxFloat32ByFloat64Slice(values [][]float64, f func(vs []float64) float32) (max float32, err error) {
	return lib_MaxFloat32(lib_MapFloat64SliceToFloat32(values, f))
}

func lib_MaxFloat32ByFloat64Slice2(values [][][]float64, f func(vs [][]float64) float32) (max float32, err error) {
	return lib_MaxFloat32(lib_MapFloat64Slice2ToFloat32(values, f))
}

func lib_SumFloat64ByInt(values []float64, f func(v float64) int) int {
	var sum int = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Float64SliceToIntSlice(values []float64) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, int(value))
	}
	return
}

func lib_MapIntSliceToFloat64(values [][]int, f func(v []int) float64) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapIntSlice2ToFloat64(values [][][]int, f func(v [][]int) float64) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxFloat64ByIntSlice(values [][]int, f func(vs []int) float64) (max float64, err error) {
	return lib_MaxFloat64(lib_MapIntSliceToFloat64(values, f))
}

func lib_MaxFloat64ByIntSlice2(values [][][]int, f func(vs [][]int) float64) (max float64, err error) {
	return lib_MaxFloat64(lib_MapIntSlice2ToFloat64(values, f))
}

func lib_SumFloat64ByInt8(values []float64, f func(v float64) int8) int8 {
	var sum int8 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Float64SliceToInt8Slice(values []float64) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, int8(value))
	}
	return
}

func lib_MapInt8SliceToFloat64(values [][]int8, f func(v []int8) float64) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt8Slice2ToFloat64(values [][][]int8, f func(v [][]int8) float64) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxFloat64ByInt8Slice(values [][]int8, f func(vs []int8) float64) (max float64, err error) {
	return lib_MaxFloat64(lib_MapInt8SliceToFloat64(values, f))
}

func lib_MaxFloat64ByInt8Slice2(values [][][]int8, f func(vs [][]int8) float64) (max float64, err error) {
	return lib_MaxFloat64(lib_MapInt8Slice2ToFloat64(values, f))
}

func lib_SumFloat64ByInt16(values []float64, f func(v float64) int16) int16 {
	var sum int16 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Float64SliceToInt16Slice(values []float64) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, int16(value))
	}
	return
}

func lib_MapInt16SliceToFloat64(values [][]int16, f func(v []int16) float64) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt16Slice2ToFloat64(values [][][]int16, f func(v [][]int16) float64) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxFloat64ByInt16Slice(values [][]int16, f func(vs []int16) float64) (max float64, err error) {
	return lib_MaxFloat64(lib_MapInt16SliceToFloat64(values, f))
}

func lib_MaxFloat64ByInt16Slice2(values [][][]int16, f func(vs [][]int16) float64) (max float64, err error) {
	return lib_MaxFloat64(lib_MapInt16Slice2ToFloat64(values, f))
}

func lib_SumFloat64ByInt32(values []float64, f func(v float64) int32) int32 {
	var sum int32 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Float64SliceToInt32Slice(values []float64) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, int32(value))
	}
	return
}

func lib_MapInt32SliceToFloat64(values [][]int32, f func(v []int32) float64) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt32Slice2ToFloat64(values [][][]int32, f func(v [][]int32) float64) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxFloat64ByInt32Slice(values [][]int32, f func(vs []int32) float64) (max float64, err error) {
	return lib_MaxFloat64(lib_MapInt32SliceToFloat64(values, f))
}

func lib_MaxFloat64ByInt32Slice2(values [][][]int32, f func(vs [][]int32) float64) (max float64, err error) {
	return lib_MaxFloat64(lib_MapInt32Slice2ToFloat64(values, f))
}

func lib_SumFloat64ByInt64(values []float64, f func(v float64) int64) int64 {
	var sum int64 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Float64SliceToInt64Slice(values []float64) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, int64(value))
	}
	return
}

func lib_MapInt64SliceToFloat64(values [][]int64, f func(v []int64) float64) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt64Slice2ToFloat64(values [][][]int64, f func(v [][]int64) float64) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxFloat64ByInt64Slice(values [][]int64, f func(vs []int64) float64) (max float64, err error) {
	return lib_MaxFloat64(lib_MapInt64SliceToFloat64(values, f))
}

func lib_MaxFloat64ByInt64Slice2(values [][][]int64, f func(vs [][]int64) float64) (max float64, err error) {
	return lib_MaxFloat64(lib_MapInt64Slice2ToFloat64(values, f))
}

func lib_SumFloat64ByFloat32(values []float64, f func(v float64) float32) float32 {
	var sum float32 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Float64SliceToFloat32Slice(values []float64) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, float32(value))
	}
	return
}

func lib_MapFloat32SliceToFloat64(values [][]float32, f func(v []float32) float64) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapFloat32Slice2ToFloat64(values [][][]float32, f func(v [][]float32) float64) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxFloat64ByFloat32Slice(values [][]float32, f func(vs []float32) float64) (max float64, err error) {
	return lib_MaxFloat64(lib_MapFloat32SliceToFloat64(values, f))
}

func lib_MaxFloat64ByFloat32Slice2(values [][][]float32, f func(vs [][]float32) float64) (max float64, err error) {
	return lib_MaxFloat64(lib_MapFloat32Slice2ToFloat64(values, f))
}

func lib_SumFloat64ByFloat64(values []float64, f func(v float64) float64) float64 {
	var sum float64 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Float64SliceToFloat64Slice(values []float64) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, float64(value))
	}
	return
}

func lib_MapFloat64SliceToFloat64(values [][]float64, f func(v []float64) float64) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapFloat64Slice2ToFloat64(values [][][]float64, f func(v [][]float64) float64) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxFloat64ByFloat64Slice(values [][]float64, f func(vs []float64) float64) (max float64, err error) {
	return lib_MaxFloat64(lib_MapFloat64SliceToFloat64(values, f))
}

func lib_MaxFloat64ByFloat64Slice2(values [][][]float64, f func(vs [][]float64) float64) (max float64, err error) {
	return lib_MaxFloat64(lib_MapFloat64Slice2ToFloat64(values, f))
}

func lib_ReduceRune(values []rune, f func(acc, cur rune) rune, initial rune) (newValue rune) {
	newValue = initial
	for _, value := range values {
		newValue = f(newValue, value)
	}
	return
}

func lib_ReduceRuneSlice(values [][]rune, f func(acc rune, cur []rune) rune, initial rune) (newValue rune) {
	newValue = initial
	for _, value := range values {
		newValue = f(newValue, value)
	}
	return
}

func lib_CopyRune(values []rune) []rune {
	dst := make([]rune, len(values))
	copy(dst, values)
	return dst
}

func lib_ReverseRune(values []rune) []rune {
	newValues := lib_CopyRune(values)
	for i, j := 0, len(values)-1; i < j; i, j = i+1, j-1 {
		newValues[i], newValues[j] = values[j], values[i]
	}
	return newValues
}

func lib_MapRune(values []rune, f func(v rune) rune) (newValues []rune) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapTypeRune(values [][]rune, f func(v []rune) rune) (newValues []rune) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_ZipRune(valuesList ...[]rune) (newValuesList [][]rune, err error) {
	if len(valuesList) == 0 {
		return nil, errors.New("empty values list are given to ZipRune")
	}
	valuesLen := len(valuesList[0])
	for _, values := range valuesList {
		if (len(values)) != valuesLen {
			return nil, errors.New("different lengths values are given to ZipRune")
		}
	}

	for i := 0; i < valuesLen; i++ {
		var newValues []rune
		for _, values := range valuesList {
			newValues = append(newValues, values[i])
		}
		newValuesList = append(newValuesList, newValues)
	}
	return
}

func lib_SomeRune(values []rune, f func(v rune) bool) bool {
	for _, value := range values {
		if f(value) {
			return true
		}
	}
	return false
}

func lib_SomeRuneSlice(valuesList [][]rune, f func(v []rune) bool) bool {
	for _, values := range valuesList {
		if f(values) {
			return true
		}
	}
	return false
}

func lib_EveryRune(values []rune, f func(v rune) bool) bool {
	for _, value := range values {
		if !f(value) {
			return false
		}
	}
	return true
}

func lib_EveryRuneSlice(valuesList [][]rune, f func(v []rune) bool) bool {
	for _, values := range valuesList {
		if !f(values) {
			return false
		}
	}
	return true
}

func lib_ChunkRuneByBits(values []rune, bits []bool) (newValues [][]rune, err error) {
	if len(values) != len(bits)+1 {
		return nil, errors.New(fmt.Sprintf("there are different length between values(%d) and bits(%d)", len(values), len(bits)))
	}

	var chunk []rune
	for i, bit := range bits {
		chunk = append(chunk, values[i])
		if bit {
			newValues = append(newValues, chunk)
			chunk = []rune{}
		}
	}
	chunk = append(chunk, values[len(values)-1])
	newValues = append(newValues, chunk)
	return
}

func lib_UnsetRune(values []rune, i int) ([]rune, error) {
	if i < 0 {
		return nil, fmt.Errorf("negative number index is given: %d", i)
	}

	if i >= len(values) {
		return nil, fmt.Errorf("index(%d) is larger than slice length(%d)", i, len(values))
	}

	if len(values) == 1 {
		return []rune{}, nil
	}

	if i == len(values)-1 {
		return values[:len(values)-1], nil
	}

	newValues := make([]rune, len(values))
	copy(newValues, values)
	return append(newValues[:i], newValues[i+1:]...), nil
}

func lib_RuneCombination(values []rune, r int) (combinations [][]rune, err error) {
	if r == 1 {
		for _, value := range values {
			combinations = append(combinations, []rune{value})
		}
		return
	}

	for i := range values {
		newValues := values
		for j := 0; j <= i; j++ {
			newValues = newValues[1:]
		}
		partialCombinations, err := lib_RuneCombination(newValues, r-1)
		if err != nil {
			return nil, err
		}

		for _, pc := range partialCombinations {
			newC := append(pc, values[i])
			combinations = append(combinations, newC)
		}
	}
	return
}

func lib_RunePermutation(values []rune, r int) (permutations [][]rune) {
	if r == 1 {
		for _, value := range values {
			permutations = append(permutations, []rune{value})
		}
		return
	}
	for i := range values {
		newValues := lib_RuneRemoveFromSlice(values, i)
		for _, pc := range lib_RunePermutation(newValues, r-1) {
			newC := append(pc, values[i])
			permutations = append(permutations, newC)
		}
	}
	return
}

func lib_RuneSliceCombination(values [][]rune, r int) (combinations [][][]rune, err error) {
	if r == 1 {
		for _, value := range values {
			combinations = append(combinations, [][]rune{value})
		}
		return
	}

	for i := range values {
		newValues := values
		for j := 0; j <= i; j++ {
			newValues = newValues[1:]
			if err != nil {
				return nil, err
			}
		}
		partialCombinations, err := lib_RuneSliceCombination(newValues, r-1)
		if err != nil {
			return nil, err
		}

		for _, pc := range partialCombinations {
			newC := append(pc, values[i])
			combinations = append(combinations, newC)
		}
	}
	return
}

func lib_RuneRemoveFromSlice(slice []rune, i int) []rune {
	n := make([]rune, len(slice))
	copy(n, slice)
	return append(n[:i], n[i+1:]...)
}

func lib_ReduceString(values []string, f func(acc, cur string) string, initial string) (newValue string) {
	newValue = initial
	for _, value := range values {
		newValue = f(newValue, value)
	}
	return
}

func lib_ReduceStringSlice(values [][]string, f func(acc string, cur []string) string, initial string) (newValue string) {
	newValue = initial
	for _, value := range values {
		newValue = f(newValue, value)
	}
	return
}

func lib_CopyString(values []string) []string {
	dst := make([]string, len(values))
	copy(dst, values)
	return dst
}

func lib_ReverseString(values []string) []string {
	newValues := lib_CopyString(values)
	for i, j := 0, len(values)-1; i < j; i, j = i+1, j-1 {
		newValues[i], newValues[j] = values[j], values[i]
	}
	return newValues
}

func lib_MapString(values []string, f func(v string) string) (newValues []string) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapTypeString(values [][]string, f func(v []string) string) (newValues []string) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_ZipString(valuesList ...[]string) (newValuesList [][]string, err error) {
	if len(valuesList) == 0 {
		return nil, errors.New("empty values list are given to ZipString")
	}
	valuesLen := len(valuesList[0])
	for _, values := range valuesList {
		if (len(values)) != valuesLen {
			return nil, errors.New("different lengths values are given to ZipString")
		}
	}

	for i := 0; i < valuesLen; i++ {
		var newValues []string
		for _, values := range valuesList {
			newValues = append(newValues, values[i])
		}
		newValuesList = append(newValuesList, newValues)
	}
	return
}

func lib_SomeString(values []string, f func(v string) bool) bool {
	for _, value := range values {
		if f(value) {
			return true
		}
	}
	return false
}

func lib_SomeStringSlice(valuesList [][]string, f func(v []string) bool) bool {
	for _, values := range valuesList {
		if f(values) {
			return true
		}
	}
	return false
}

func lib_EveryString(values []string, f func(v string) bool) bool {
	for _, value := range values {
		if !f(value) {
			return false
		}
	}
	return true
}

func lib_EveryStringSlice(valuesList [][]string, f func(v []string) bool) bool {
	for _, values := range valuesList {
		if !f(values) {
			return false
		}
	}
	return true
}

func lib_ChunkStringByBits(values []string, bits []bool) (newValues [][]string, err error) {
	if len(values) != len(bits)+1 {
		return nil, errors.New(fmt.Sprintf("there are different length between values(%d) and bits(%d)", len(values), len(bits)))
	}

	var chunk []string
	for i, bit := range bits {
		chunk = append(chunk, values[i])
		if bit {
			newValues = append(newValues, chunk)
			chunk = []string{}
		}
	}
	chunk = append(chunk, values[len(values)-1])
	newValues = append(newValues, chunk)
	return
}

func lib_UnsetString(values []string, i int) ([]string, error) {
	if i < 0 {
		return nil, fmt.Errorf("negative number index is given: %d", i)
	}

	if i >= len(values) {
		return nil, fmt.Errorf("index(%d) is larger than slice length(%d)", i, len(values))
	}

	if len(values) == 1 {
		return []string{}, nil
	}

	if i == len(values)-1 {
		return values[:len(values)-1], nil
	}

	newValues := make([]string, len(values))
	copy(newValues, values)
	return append(newValues[:i], newValues[i+1:]...), nil
}

func lib_StringCombination(values []string, r int) (combinations [][]string, err error) {
	if r == 1 {
		for _, value := range values {
			combinations = append(combinations, []string{value})
		}
		return
	}

	for i := range values {
		newValues := values
		for j := 0; j <= i; j++ {
			newValues = newValues[1:]
		}
		partialCombinations, err := lib_StringCombination(newValues, r-1)
		if err != nil {
			return nil, err
		}

		for _, pc := range partialCombinations {
			newC := append(pc, values[i])
			combinations = append(combinations, newC)
		}
	}
	return
}

func lib_StringPermutation(values []string, r int) (permutations [][]string) {
	if r == 1 {
		for _, value := range values {
			permutations = append(permutations, []string{value})
		}
		return
	}
	for i := range values {
		newValues := lib_StringRemoveFromSlice(values, i)
		for _, pc := range lib_StringPermutation(newValues, r-1) {
			newC := append(pc, values[i])
			permutations = append(permutations, newC)
		}
	}
	return
}

func lib_StringSliceCombination(values [][]string, r int) (combinations [][][]string, err error) {
	if r == 1 {
		for _, value := range values {
			combinations = append(combinations, [][]string{value})
		}
		return
	}

	for i := range values {
		newValues := values
		for j := 0; j <= i; j++ {
			newValues = newValues[1:]
			if err != nil {
				return nil, err
			}
		}
		partialCombinations, err := lib_StringSliceCombination(newValues, r-1)
		if err != nil {
			return nil, err
		}

		for _, pc := range partialCombinations {
			newC := append(pc, values[i])
			combinations = append(combinations, newC)
		}
	}
	return
}

func lib_StringRemoveFromSlice(slice []string, i int) []string {
	n := make([]string, len(slice))
	copy(n, slice)
	return append(n[:i], n[i+1:]...)
}

func lib_ReduceInt(values []int, f func(acc, cur int) int, initial int) (newValue int) {
	newValue = initial
	for _, value := range values {
		newValue = f(newValue, value)
	}
	return
}

func lib_ReduceIntSlice(values [][]int, f func(acc int, cur []int) int, initial int) (newValue int) {
	newValue = initial
	for _, value := range values {
		newValue = f(newValue, value)
	}
	return
}

func lib_CopyInt(values []int) []int {
	dst := make([]int, len(values))
	copy(dst, values)
	return dst
}

func lib_ReverseInt(values []int) []int {
	newValues := lib_CopyInt(values)
	for i, j := 0, len(values)-1; i < j; i, j = i+1, j-1 {
		newValues[i], newValues[j] = values[j], values[i]
	}
	return newValues
}

func lib_MapInt(values []int, f func(v int) int) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapTypeInt(values [][]int, f func(v []int) int) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_ZipInt(valuesList ...[]int) (newValuesList [][]int, err error) {
	if len(valuesList) == 0 {
		return nil, errors.New("empty values list are given to ZipInt")
	}
	valuesLen := len(valuesList[0])
	for _, values := range valuesList {
		if (len(values)) != valuesLen {
			return nil, errors.New("different lengths values are given to ZipInt")
		}
	}

	for i := 0; i < valuesLen; i++ {
		var newValues []int
		for _, values := range valuesList {
			newValues = append(newValues, values[i])
		}
		newValuesList = append(newValuesList, newValues)
	}
	return
}

func lib_SomeInt(values []int, f func(v int) bool) bool {
	for _, value := range values {
		if f(value) {
			return true
		}
	}
	return false
}

func lib_SomeIntSlice(valuesList [][]int, f func(v []int) bool) bool {
	for _, values := range valuesList {
		if f(values) {
			return true
		}
	}
	return false
}

func lib_EveryInt(values []int, f func(v int) bool) bool {
	for _, value := range values {
		if !f(value) {
			return false
		}
	}
	return true
}

func lib_EveryIntSlice(valuesList [][]int, f func(v []int) bool) bool {
	for _, values := range valuesList {
		if !f(values) {
			return false
		}
	}
	return true
}

func lib_ChunkIntByBits(values []int, bits []bool) (newValues [][]int, err error) {
	if len(values) != len(bits)+1 {
		return nil, errors.New(fmt.Sprintf("there are different length between values(%d) and bits(%d)", len(values), len(bits)))
	}

	var chunk []int
	for i, bit := range bits {
		chunk = append(chunk, values[i])
		if bit {
			newValues = append(newValues, chunk)
			chunk = []int{}
		}
	}
	chunk = append(chunk, values[len(values)-1])
	newValues = append(newValues, chunk)
	return
}

func lib_UnsetInt(values []int, i int) ([]int, error) {
	if i < 0 {
		return nil, fmt.Errorf("negative number index is given: %d", i)
	}

	if i >= len(values) {
		return nil, fmt.Errorf("index(%d) is larger than slice length(%d)", i, len(values))
	}

	if len(values) == 1 {
		return []int{}, nil
	}

	if i == len(values)-1 {
		return values[:len(values)-1], nil
	}

	newValues := make([]int, len(values))
	copy(newValues, values)
	return append(newValues[:i], newValues[i+1:]...), nil
}

func lib_IntCombination(values []int, r int) (combinations [][]int, err error) {
	if r == 1 {
		for _, value := range values {
			combinations = append(combinations, []int{value})
		}
		return
	}

	for i := range values {
		newValues := values
		for j := 0; j <= i; j++ {
			newValues = newValues[1:]
		}
		partialCombinations, err := lib_IntCombination(newValues, r-1)
		if err != nil {
			return nil, err
		}

		for _, pc := range partialCombinations {
			newC := append(pc, values[i])
			combinations = append(combinations, newC)
		}
	}
	return
}

func lib_IntPermutation(values []int, r int) (permutations [][]int) {
	if r == 1 {
		for _, value := range values {
			permutations = append(permutations, []int{value})
		}
		return
	}
	for i := range values {
		newValues := lib_IntRemoveFromSlice(values, i)
		for _, pc := range lib_IntPermutation(newValues, r-1) {
			newC := append(pc, values[i])
			permutations = append(permutations, newC)
		}
	}
	return
}

func lib_IntSliceCombination(values [][]int, r int) (combinations [][][]int, err error) {
	if r == 1 {
		for _, value := range values {
			combinations = append(combinations, [][]int{value})
		}
		return
	}

	for i := range values {
		newValues := values
		for j := 0; j <= i; j++ {
			newValues = newValues[1:]
			if err != nil {
				return nil, err
			}
		}
		partialCombinations, err := lib_IntSliceCombination(newValues, r-1)
		if err != nil {
			return nil, err
		}

		for _, pc := range partialCombinations {
			newC := append(pc, values[i])
			combinations = append(combinations, newC)
		}
	}
	return
}

func lib_IntRemoveFromSlice(slice []int, i int) []int {
	n := make([]int, len(slice))
	copy(n, slice)
	return append(n[:i], n[i+1:]...)
}

func lib_ReduceInt8(values []int8, f func(acc, cur int8) int8, initial int8) (newValue int8) {
	newValue = initial
	for _, value := range values {
		newValue = f(newValue, value)
	}
	return
}

func lib_ReduceInt8Slice(values [][]int8, f func(acc int8, cur []int8) int8, initial int8) (newValue int8) {
	newValue = initial
	for _, value := range values {
		newValue = f(newValue, value)
	}
	return
}

func lib_CopyInt8(values []int8) []int8 {
	dst := make([]int8, len(values))
	copy(dst, values)
	return dst
}

func lib_ReverseInt8(values []int8) []int8 {
	newValues := lib_CopyInt8(values)
	for i, j := 0, len(values)-1; i < j; i, j = i+1, j-1 {
		newValues[i], newValues[j] = values[j], values[i]
	}
	return newValues
}

func lib_MapInt8(values []int8, f func(v int8) int8) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapTypeInt8(values [][]int8, f func(v []int8) int8) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_ZipInt8(valuesList ...[]int8) (newValuesList [][]int8, err error) {
	if len(valuesList) == 0 {
		return nil, errors.New("empty values list are given to ZipInt8")
	}
	valuesLen := len(valuesList[0])
	for _, values := range valuesList {
		if (len(values)) != valuesLen {
			return nil, errors.New("different lengths values are given to ZipInt8")
		}
	}

	for i := 0; i < valuesLen; i++ {
		var newValues []int8
		for _, values := range valuesList {
			newValues = append(newValues, values[i])
		}
		newValuesList = append(newValuesList, newValues)
	}
	return
}

func lib_SomeInt8(values []int8, f func(v int8) bool) bool {
	for _, value := range values {
		if f(value) {
			return true
		}
	}
	return false
}

func lib_SomeInt8Slice(valuesList [][]int8, f func(v []int8) bool) bool {
	for _, values := range valuesList {
		if f(values) {
			return true
		}
	}
	return false
}

func lib_EveryInt8(values []int8, f func(v int8) bool) bool {
	for _, value := range values {
		if !f(value) {
			return false
		}
	}
	return true
}

func lib_EveryInt8Slice(valuesList [][]int8, f func(v []int8) bool) bool {
	for _, values := range valuesList {
		if !f(values) {
			return false
		}
	}
	return true
}

func lib_ChunkInt8ByBits(values []int8, bits []bool) (newValues [][]int8, err error) {
	if len(values) != len(bits)+1 {
		return nil, errors.New(fmt.Sprintf("there are different length between values(%d) and bits(%d)", len(values), len(bits)))
	}

	var chunk []int8
	for i, bit := range bits {
		chunk = append(chunk, values[i])
		if bit {
			newValues = append(newValues, chunk)
			chunk = []int8{}
		}
	}
	chunk = append(chunk, values[len(values)-1])
	newValues = append(newValues, chunk)
	return
}

func lib_UnsetInt8(values []int8, i int) ([]int8, error) {
	if i < 0 {
		return nil, fmt.Errorf("negative number index is given: %d", i)
	}

	if i >= len(values) {
		return nil, fmt.Errorf("index(%d) is larger than slice length(%d)", i, len(values))
	}

	if len(values) == 1 {
		return []int8{}, nil
	}

	if i == len(values)-1 {
		return values[:len(values)-1], nil
	}

	newValues := make([]int8, len(values))
	copy(newValues, values)
	return append(newValues[:i], newValues[i+1:]...), nil
}

func lib_Int8Combination(values []int8, r int) (combinations [][]int8, err error) {
	if r == 1 {
		for _, value := range values {
			combinations = append(combinations, []int8{value})
		}
		return
	}

	for i := range values {
		newValues := values
		for j := 0; j <= i; j++ {
			newValues = newValues[1:]
		}
		partialCombinations, err := lib_Int8Combination(newValues, r-1)
		if err != nil {
			return nil, err
		}

		for _, pc := range partialCombinations {
			newC := append(pc, values[i])
			combinations = append(combinations, newC)
		}
	}
	return
}

func lib_Int8Permutation(values []int8, r int) (permutations [][]int8) {
	if r == 1 {
		for _, value := range values {
			permutations = append(permutations, []int8{value})
		}
		return
	}
	for i := range values {
		newValues := lib_Int8RemoveFromSlice(values, i)
		for _, pc := range lib_Int8Permutation(newValues, r-1) {
			newC := append(pc, values[i])
			permutations = append(permutations, newC)
		}
	}
	return
}

func lib_Int8SliceCombination(values [][]int8, r int) (combinations [][][]int8, err error) {
	if r == 1 {
		for _, value := range values {
			combinations = append(combinations, [][]int8{value})
		}
		return
	}

	for i := range values {
		newValues := values
		for j := 0; j <= i; j++ {
			newValues = newValues[1:]
			if err != nil {
				return nil, err
			}
		}
		partialCombinations, err := lib_Int8SliceCombination(newValues, r-1)
		if err != nil {
			return nil, err
		}

		for _, pc := range partialCombinations {
			newC := append(pc, values[i])
			combinations = append(combinations, newC)
		}
	}
	return
}

func lib_Int8RemoveFromSlice(slice []int8, i int) []int8 {
	n := make([]int8, len(slice))
	copy(n, slice)
	return append(n[:i], n[i+1:]...)
}

func lib_ReduceInt16(values []int16, f func(acc, cur int16) int16, initial int16) (newValue int16) {
	newValue = initial
	for _, value := range values {
		newValue = f(newValue, value)
	}
	return
}

func lib_ReduceInt16Slice(values [][]int16, f func(acc int16, cur []int16) int16, initial int16) (newValue int16) {
	newValue = initial
	for _, value := range values {
		newValue = f(newValue, value)
	}
	return
}

func lib_CopyInt16(values []int16) []int16 {
	dst := make([]int16, len(values))
	copy(dst, values)
	return dst
}

func lib_ReverseInt16(values []int16) []int16 {
	newValues := lib_CopyInt16(values)
	for i, j := 0, len(values)-1; i < j; i, j = i+1, j-1 {
		newValues[i], newValues[j] = values[j], values[i]
	}
	return newValues
}

func lib_MapInt16(values []int16, f func(v int16) int16) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapTypeInt16(values [][]int16, f func(v []int16) int16) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_ZipInt16(valuesList ...[]int16) (newValuesList [][]int16, err error) {
	if len(valuesList) == 0 {
		return nil, errors.New("empty values list are given to ZipInt16")
	}
	valuesLen := len(valuesList[0])
	for _, values := range valuesList {
		if (len(values)) != valuesLen {
			return nil, errors.New("different lengths values are given to ZipInt16")
		}
	}

	for i := 0; i < valuesLen; i++ {
		var newValues []int16
		for _, values := range valuesList {
			newValues = append(newValues, values[i])
		}
		newValuesList = append(newValuesList, newValues)
	}
	return
}

func lib_SomeInt16(values []int16, f func(v int16) bool) bool {
	for _, value := range values {
		if f(value) {
			return true
		}
	}
	return false
}

func lib_SomeInt16Slice(valuesList [][]int16, f func(v []int16) bool) bool {
	for _, values := range valuesList {
		if f(values) {
			return true
		}
	}
	return false
}

func lib_EveryInt16(values []int16, f func(v int16) bool) bool {
	for _, value := range values {
		if !f(value) {
			return false
		}
	}
	return true
}

func lib_EveryInt16Slice(valuesList [][]int16, f func(v []int16) bool) bool {
	for _, values := range valuesList {
		if !f(values) {
			return false
		}
	}
	return true
}

func lib_ChunkInt16ByBits(values []int16, bits []bool) (newValues [][]int16, err error) {
	if len(values) != len(bits)+1 {
		return nil, errors.New(fmt.Sprintf("there are different length between values(%d) and bits(%d)", len(values), len(bits)))
	}

	var chunk []int16
	for i, bit := range bits {
		chunk = append(chunk, values[i])
		if bit {
			newValues = append(newValues, chunk)
			chunk = []int16{}
		}
	}
	chunk = append(chunk, values[len(values)-1])
	newValues = append(newValues, chunk)
	return
}

func lib_UnsetInt16(values []int16, i int) ([]int16, error) {
	if i < 0 {
		return nil, fmt.Errorf("negative number index is given: %d", i)
	}

	if i >= len(values) {
		return nil, fmt.Errorf("index(%d) is larger than slice length(%d)", i, len(values))
	}

	if len(values) == 1 {
		return []int16{}, nil
	}

	if i == len(values)-1 {
		return values[:len(values)-1], nil
	}

	newValues := make([]int16, len(values))
	copy(newValues, values)
	return append(newValues[:i], newValues[i+1:]...), nil
}

func lib_Int16Combination(values []int16, r int) (combinations [][]int16, err error) {
	if r == 1 {
		for _, value := range values {
			combinations = append(combinations, []int16{value})
		}
		return
	}

	for i := range values {
		newValues := values
		for j := 0; j <= i; j++ {
			newValues = newValues[1:]
		}
		partialCombinations, err := lib_Int16Combination(newValues, r-1)
		if err != nil {
			return nil, err
		}

		for _, pc := range partialCombinations {
			newC := append(pc, values[i])
			combinations = append(combinations, newC)
		}
	}
	return
}

func lib_Int16Permutation(values []int16, r int) (permutations [][]int16) {
	if r == 1 {
		for _, value := range values {
			permutations = append(permutations, []int16{value})
		}
		return
	}
	for i := range values {
		newValues := lib_Int16RemoveFromSlice(values, i)
		for _, pc := range lib_Int16Permutation(newValues, r-1) {
			newC := append(pc, values[i])
			permutations = append(permutations, newC)
		}
	}
	return
}

func lib_Int16SliceCombination(values [][]int16, r int) (combinations [][][]int16, err error) {
	if r == 1 {
		for _, value := range values {
			combinations = append(combinations, [][]int16{value})
		}
		return
	}

	for i := range values {
		newValues := values
		for j := 0; j <= i; j++ {
			newValues = newValues[1:]
			if err != nil {
				return nil, err
			}
		}
		partialCombinations, err := lib_Int16SliceCombination(newValues, r-1)
		if err != nil {
			return nil, err
		}

		for _, pc := range partialCombinations {
			newC := append(pc, values[i])
			combinations = append(combinations, newC)
		}
	}
	return
}

func lib_Int16RemoveFromSlice(slice []int16, i int) []int16 {
	n := make([]int16, len(slice))
	copy(n, slice)
	return append(n[:i], n[i+1:]...)
}

func lib_ReduceInt32(values []int32, f func(acc, cur int32) int32, initial int32) (newValue int32) {
	newValue = initial
	for _, value := range values {
		newValue = f(newValue, value)
	}
	return
}

func lib_ReduceInt32Slice(values [][]int32, f func(acc int32, cur []int32) int32, initial int32) (newValue int32) {
	newValue = initial
	for _, value := range values {
		newValue = f(newValue, value)
	}
	return
}

func lib_CopyInt32(values []int32) []int32 {
	dst := make([]int32, len(values))
	copy(dst, values)
	return dst
}

func lib_ReverseInt32(values []int32) []int32 {
	newValues := lib_CopyInt32(values)
	for i, j := 0, len(values)-1; i < j; i, j = i+1, j-1 {
		newValues[i], newValues[j] = values[j], values[i]
	}
	return newValues
}

func lib_MapInt32(values []int32, f func(v int32) int32) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapTypeInt32(values [][]int32, f func(v []int32) int32) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_ZipInt32(valuesList ...[]int32) (newValuesList [][]int32, err error) {
	if len(valuesList) == 0 {
		return nil, errors.New("empty values list are given to ZipInt32")
	}
	valuesLen := len(valuesList[0])
	for _, values := range valuesList {
		if (len(values)) != valuesLen {
			return nil, errors.New("different lengths values are given to ZipInt32")
		}
	}

	for i := 0; i < valuesLen; i++ {
		var newValues []int32
		for _, values := range valuesList {
			newValues = append(newValues, values[i])
		}
		newValuesList = append(newValuesList, newValues)
	}
	return
}

func lib_SomeInt32(values []int32, f func(v int32) bool) bool {
	for _, value := range values {
		if f(value) {
			return true
		}
	}
	return false
}

func lib_SomeInt32Slice(valuesList [][]int32, f func(v []int32) bool) bool {
	for _, values := range valuesList {
		if f(values) {
			return true
		}
	}
	return false
}

func lib_EveryInt32(values []int32, f func(v int32) bool) bool {
	for _, value := range values {
		if !f(value) {
			return false
		}
	}
	return true
}

func lib_EveryInt32Slice(valuesList [][]int32, f func(v []int32) bool) bool {
	for _, values := range valuesList {
		if !f(values) {
			return false
		}
	}
	return true
}

func lib_ChunkInt32ByBits(values []int32, bits []bool) (newValues [][]int32, err error) {
	if len(values) != len(bits)+1 {
		return nil, errors.New(fmt.Sprintf("there are different length between values(%d) and bits(%d)", len(values), len(bits)))
	}

	var chunk []int32
	for i, bit := range bits {
		chunk = append(chunk, values[i])
		if bit {
			newValues = append(newValues, chunk)
			chunk = []int32{}
		}
	}
	chunk = append(chunk, values[len(values)-1])
	newValues = append(newValues, chunk)
	return
}

func lib_UnsetInt32(values []int32, i int) ([]int32, error) {
	if i < 0 {
		return nil, fmt.Errorf("negative number index is given: %d", i)
	}

	if i >= len(values) {
		return nil, fmt.Errorf("index(%d) is larger than slice length(%d)", i, len(values))
	}

	if len(values) == 1 {
		return []int32{}, nil
	}

	if i == len(values)-1 {
		return values[:len(values)-1], nil
	}

	newValues := make([]int32, len(values))
	copy(newValues, values)
	return append(newValues[:i], newValues[i+1:]...), nil
}

func lib_Int32Combination(values []int32, r int) (combinations [][]int32, err error) {
	if r == 1 {
		for _, value := range values {
			combinations = append(combinations, []int32{value})
		}
		return
	}

	for i := range values {
		newValues := values
		for j := 0; j <= i; j++ {
			newValues = newValues[1:]
		}
		partialCombinations, err := lib_Int32Combination(newValues, r-1)
		if err != nil {
			return nil, err
		}

		for _, pc := range partialCombinations {
			newC := append(pc, values[i])
			combinations = append(combinations, newC)
		}
	}
	return
}

func lib_Int32Permutation(values []int32, r int) (permutations [][]int32) {
	if r == 1 {
		for _, value := range values {
			permutations = append(permutations, []int32{value})
		}
		return
	}
	for i := range values {
		newValues := lib_Int32RemoveFromSlice(values, i)
		for _, pc := range lib_Int32Permutation(newValues, r-1) {
			newC := append(pc, values[i])
			permutations = append(permutations, newC)
		}
	}
	return
}

func lib_Int32SliceCombination(values [][]int32, r int) (combinations [][][]int32, err error) {
	if r == 1 {
		for _, value := range values {
			combinations = append(combinations, [][]int32{value})
		}
		return
	}

	for i := range values {
		newValues := values
		for j := 0; j <= i; j++ {
			newValues = newValues[1:]
			if err != nil {
				return nil, err
			}
		}
		partialCombinations, err := lib_Int32SliceCombination(newValues, r-1)
		if err != nil {
			return nil, err
		}

		for _, pc := range partialCombinations {
			newC := append(pc, values[i])
			combinations = append(combinations, newC)
		}
	}
	return
}

func lib_Int32RemoveFromSlice(slice []int32, i int) []int32 {
	n := make([]int32, len(slice))
	copy(n, slice)
	return append(n[:i], n[i+1:]...)
}

func lib_ReduceInt64(values []int64, f func(acc, cur int64) int64, initial int64) (newValue int64) {
	newValue = initial
	for _, value := range values {
		newValue = f(newValue, value)
	}
	return
}

func lib_ReduceInt64Slice(values [][]int64, f func(acc int64, cur []int64) int64, initial int64) (newValue int64) {
	newValue = initial
	for _, value := range values {
		newValue = f(newValue, value)
	}
	return
}

func lib_CopyInt64(values []int64) []int64 {
	dst := make([]int64, len(values))
	copy(dst, values)
	return dst
}

func lib_ReverseInt64(values []int64) []int64 {
	newValues := lib_CopyInt64(values)
	for i, j := 0, len(values)-1; i < j; i, j = i+1, j-1 {
		newValues[i], newValues[j] = values[j], values[i]
	}
	return newValues
}

func lib_MapInt64(values []int64, f func(v int64) int64) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapTypeInt64(values [][]int64, f func(v []int64) int64) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_ZipInt64(valuesList ...[]int64) (newValuesList [][]int64, err error) {
	if len(valuesList) == 0 {
		return nil, errors.New("empty values list are given to ZipInt64")
	}
	valuesLen := len(valuesList[0])
	for _, values := range valuesList {
		if (len(values)) != valuesLen {
			return nil, errors.New("different lengths values are given to ZipInt64")
		}
	}

	for i := 0; i < valuesLen; i++ {
		var newValues []int64
		for _, values := range valuesList {
			newValues = append(newValues, values[i])
		}
		newValuesList = append(newValuesList, newValues)
	}
	return
}

func lib_SomeInt64(values []int64, f func(v int64) bool) bool {
	for _, value := range values {
		if f(value) {
			return true
		}
	}
	return false
}

func lib_SomeInt64Slice(valuesList [][]int64, f func(v []int64) bool) bool {
	for _, values := range valuesList {
		if f(values) {
			return true
		}
	}
	return false
}

func lib_EveryInt64(values []int64, f func(v int64) bool) bool {
	for _, value := range values {
		if !f(value) {
			return false
		}
	}
	return true
}

func lib_EveryInt64Slice(valuesList [][]int64, f func(v []int64) bool) bool {
	for _, values := range valuesList {
		if !f(values) {
			return false
		}
	}
	return true
}

func lib_ChunkInt64ByBits(values []int64, bits []bool) (newValues [][]int64, err error) {
	if len(values) != len(bits)+1 {
		return nil, errors.New(fmt.Sprintf("there are different length between values(%d) and bits(%d)", len(values), len(bits)))
	}

	var chunk []int64
	for i, bit := range bits {
		chunk = append(chunk, values[i])
		if bit {
			newValues = append(newValues, chunk)
			chunk = []int64{}
		}
	}
	chunk = append(chunk, values[len(values)-1])
	newValues = append(newValues, chunk)
	return
}

func lib_UnsetInt64(values []int64, i int) ([]int64, error) {
	if i < 0 {
		return nil, fmt.Errorf("negative number index is given: %d", i)
	}

	if i >= len(values) {
		return nil, fmt.Errorf("index(%d) is larger than slice length(%d)", i, len(values))
	}

	if len(values) == 1 {
		return []int64{}, nil
	}

	if i == len(values)-1 {
		return values[:len(values)-1], nil
	}

	newValues := make([]int64, len(values))
	copy(newValues, values)
	return append(newValues[:i], newValues[i+1:]...), nil
}

func lib_Int64Combination(values []int64, r int) (combinations [][]int64, err error) {
	if r == 1 {
		for _, value := range values {
			combinations = append(combinations, []int64{value})
		}
		return
	}

	for i := range values {
		newValues := values
		for j := 0; j <= i; j++ {
			newValues = newValues[1:]
		}
		partialCombinations, err := lib_Int64Combination(newValues, r-1)
		if err != nil {
			return nil, err
		}

		for _, pc := range partialCombinations {
			newC := append(pc, values[i])
			combinations = append(combinations, newC)
		}
	}
	return
}

func lib_Int64Permutation(values []int64, r int) (permutations [][]int64) {
	if r == 1 {
		for _, value := range values {
			permutations = append(permutations, []int64{value})
		}
		return
	}
	for i := range values {
		newValues := lib_Int64RemoveFromSlice(values, i)
		for _, pc := range lib_Int64Permutation(newValues, r-1) {
			newC := append(pc, values[i])
			permutations = append(permutations, newC)
		}
	}
	return
}

func lib_Int64SliceCombination(values [][]int64, r int) (combinations [][][]int64, err error) {
	if r == 1 {
		for _, value := range values {
			combinations = append(combinations, [][]int64{value})
		}
		return
	}

	for i := range values {
		newValues := values
		for j := 0; j <= i; j++ {
			newValues = newValues[1:]
			if err != nil {
				return nil, err
			}
		}
		partialCombinations, err := lib_Int64SliceCombination(newValues, r-1)
		if err != nil {
			return nil, err
		}

		for _, pc := range partialCombinations {
			newC := append(pc, values[i])
			combinations = append(combinations, newC)
		}
	}
	return
}

func lib_Int64RemoveFromSlice(slice []int64, i int) []int64 {
	n := make([]int64, len(slice))
	copy(n, slice)
	return append(n[:i], n[i+1:]...)
}

func lib_ReduceFloat32(values []float32, f func(acc, cur float32) float32, initial float32) (newValue float32) {
	newValue = initial
	for _, value := range values {
		newValue = f(newValue, value)
	}
	return
}

func lib_ReduceFloat32Slice(values [][]float32, f func(acc float32, cur []float32) float32, initial float32) (newValue float32) {
	newValue = initial
	for _, value := range values {
		newValue = f(newValue, value)
	}
	return
}

func lib_CopyFloat32(values []float32) []float32 {
	dst := make([]float32, len(values))
	copy(dst, values)
	return dst
}

func lib_ReverseFloat32(values []float32) []float32 {
	newValues := lib_CopyFloat32(values)
	for i, j := 0, len(values)-1; i < j; i, j = i+1, j-1 {
		newValues[i], newValues[j] = values[j], values[i]
	}
	return newValues
}

func lib_MapFloat32(values []float32, f func(v float32) float32) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapTypeFloat32(values [][]float32, f func(v []float32) float32) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_ZipFloat32(valuesList ...[]float32) (newValuesList [][]float32, err error) {
	if len(valuesList) == 0 {
		return nil, errors.New("empty values list are given to ZipFloat32")
	}
	valuesLen := len(valuesList[0])
	for _, values := range valuesList {
		if (len(values)) != valuesLen {
			return nil, errors.New("different lengths values are given to ZipFloat32")
		}
	}

	for i := 0; i < valuesLen; i++ {
		var newValues []float32
		for _, values := range valuesList {
			newValues = append(newValues, values[i])
		}
		newValuesList = append(newValuesList, newValues)
	}
	return
}

func lib_SomeFloat32(values []float32, f func(v float32) bool) bool {
	for _, value := range values {
		if f(value) {
			return true
		}
	}
	return false
}

func lib_SomeFloat32Slice(valuesList [][]float32, f func(v []float32) bool) bool {
	for _, values := range valuesList {
		if f(values) {
			return true
		}
	}
	return false
}

func lib_EveryFloat32(values []float32, f func(v float32) bool) bool {
	for _, value := range values {
		if !f(value) {
			return false
		}
	}
	return true
}

func lib_EveryFloat32Slice(valuesList [][]float32, f func(v []float32) bool) bool {
	for _, values := range valuesList {
		if !f(values) {
			return false
		}
	}
	return true
}

func lib_ChunkFloat32ByBits(values []float32, bits []bool) (newValues [][]float32, err error) {
	if len(values) != len(bits)+1 {
		return nil, errors.New(fmt.Sprintf("there are different length between values(%d) and bits(%d)", len(values), len(bits)))
	}

	var chunk []float32
	for i, bit := range bits {
		chunk = append(chunk, values[i])
		if bit {
			newValues = append(newValues, chunk)
			chunk = []float32{}
		}
	}
	chunk = append(chunk, values[len(values)-1])
	newValues = append(newValues, chunk)
	return
}

func lib_UnsetFloat32(values []float32, i int) ([]float32, error) {
	if i < 0 {
		return nil, fmt.Errorf("negative number index is given: %d", i)
	}

	if i >= len(values) {
		return nil, fmt.Errorf("index(%d) is larger than slice length(%d)", i, len(values))
	}

	if len(values) == 1 {
		return []float32{}, nil
	}

	if i == len(values)-1 {
		return values[:len(values)-1], nil
	}

	newValues := make([]float32, len(values))
	copy(newValues, values)
	return append(newValues[:i], newValues[i+1:]...), nil
}

func lib_Float32Combination(values []float32, r int) (combinations [][]float32, err error) {
	if r == 1 {
		for _, value := range values {
			combinations = append(combinations, []float32{value})
		}
		return
	}

	for i := range values {
		newValues := values
		for j := 0; j <= i; j++ {
			newValues = newValues[1:]
		}
		partialCombinations, err := lib_Float32Combination(newValues, r-1)
		if err != nil {
			return nil, err
		}

		for _, pc := range partialCombinations {
			newC := append(pc, values[i])
			combinations = append(combinations, newC)
		}
	}
	return
}

func lib_Float32Permutation(values []float32, r int) (permutations [][]float32) {
	if r == 1 {
		for _, value := range values {
			permutations = append(permutations, []float32{value})
		}
		return
	}
	for i := range values {
		newValues := lib_Float32RemoveFromSlice(values, i)
		for _, pc := range lib_Float32Permutation(newValues, r-1) {
			newC := append(pc, values[i])
			permutations = append(permutations, newC)
		}
	}
	return
}

func lib_Float32SliceCombination(values [][]float32, r int) (combinations [][][]float32, err error) {
	if r == 1 {
		for _, value := range values {
			combinations = append(combinations, [][]float32{value})
		}
		return
	}

	for i := range values {
		newValues := values
		for j := 0; j <= i; j++ {
			newValues = newValues[1:]
			if err != nil {
				return nil, err
			}
		}
		partialCombinations, err := lib_Float32SliceCombination(newValues, r-1)
		if err != nil {
			return nil, err
		}

		for _, pc := range partialCombinations {
			newC := append(pc, values[i])
			combinations = append(combinations, newC)
		}
	}
	return
}

func lib_Float32RemoveFromSlice(slice []float32, i int) []float32 {
	n := make([]float32, len(slice))
	copy(n, slice)
	return append(n[:i], n[i+1:]...)
}

func lib_ReduceFloat64(values []float64, f func(acc, cur float64) float64, initial float64) (newValue float64) {
	newValue = initial
	for _, value := range values {
		newValue = f(newValue, value)
	}
	return
}

func lib_ReduceFloat64Slice(values [][]float64, f func(acc float64, cur []float64) float64, initial float64) (newValue float64) {
	newValue = initial
	for _, value := range values {
		newValue = f(newValue, value)
	}
	return
}

func lib_CopyFloat64(values []float64) []float64 {
	dst := make([]float64, len(values))
	copy(dst, values)
	return dst
}

func lib_ReverseFloat64(values []float64) []float64 {
	newValues := lib_CopyFloat64(values)
	for i, j := 0, len(values)-1; i < j; i, j = i+1, j-1 {
		newValues[i], newValues[j] = values[j], values[i]
	}
	return newValues
}

func lib_MapFloat64(values []float64, f func(v float64) float64) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapTypeFloat64(values [][]float64, f func(v []float64) float64) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_ZipFloat64(valuesList ...[]float64) (newValuesList [][]float64, err error) {
	if len(valuesList) == 0 {
		return nil, errors.New("empty values list are given to ZipFloat64")
	}
	valuesLen := len(valuesList[0])
	for _, values := range valuesList {
		if (len(values)) != valuesLen {
			return nil, errors.New("different lengths values are given to ZipFloat64")
		}
	}

	for i := 0; i < valuesLen; i++ {
		var newValues []float64
		for _, values := range valuesList {
			newValues = append(newValues, values[i])
		}
		newValuesList = append(newValuesList, newValues)
	}
	return
}

func lib_SomeFloat64(values []float64, f func(v float64) bool) bool {
	for _, value := range values {
		if f(value) {
			return true
		}
	}
	return false
}

func lib_SomeFloat64Slice(valuesList [][]float64, f func(v []float64) bool) bool {
	for _, values := range valuesList {
		if f(values) {
			return true
		}
	}
	return false
}

func lib_EveryFloat64(values []float64, f func(v float64) bool) bool {
	for _, value := range values {
		if !f(value) {
			return false
		}
	}
	return true
}

func lib_EveryFloat64Slice(valuesList [][]float64, f func(v []float64) bool) bool {
	for _, values := range valuesList {
		if !f(values) {
			return false
		}
	}
	return true
}

func lib_ChunkFloat64ByBits(values []float64, bits []bool) (newValues [][]float64, err error) {
	if len(values) != len(bits)+1 {
		return nil, errors.New(fmt.Sprintf("there are different length between values(%d) and bits(%d)", len(values), len(bits)))
	}

	var chunk []float64
	for i, bit := range bits {
		chunk = append(chunk, values[i])
		if bit {
			newValues = append(newValues, chunk)
			chunk = []float64{}
		}
	}
	chunk = append(chunk, values[len(values)-1])
	newValues = append(newValues, chunk)
	return
}

func lib_UnsetFloat64(values []float64, i int) ([]float64, error) {
	if i < 0 {
		return nil, fmt.Errorf("negative number index is given: %d", i)
	}

	if i >= len(values) {
		return nil, fmt.Errorf("index(%d) is larger than slice length(%d)", i, len(values))
	}

	if len(values) == 1 {
		return []float64{}, nil
	}

	if i == len(values)-1 {
		return values[:len(values)-1], nil
	}

	newValues := make([]float64, len(values))
	copy(newValues, values)
	return append(newValues[:i], newValues[i+1:]...), nil
}

func lib_Float64Combination(values []float64, r int) (combinations [][]float64, err error) {
	if r == 1 {
		for _, value := range values {
			combinations = append(combinations, []float64{value})
		}
		return
	}

	for i := range values {
		newValues := values
		for j := 0; j <= i; j++ {
			newValues = newValues[1:]
		}
		partialCombinations, err := lib_Float64Combination(newValues, r-1)
		if err != nil {
			return nil, err
		}

		for _, pc := range partialCombinations {
			newC := append(pc, values[i])
			combinations = append(combinations, newC)
		}
	}
	return
}

func lib_Float64Permutation(values []float64, r int) (permutations [][]float64) {
	if r == 1 {
		for _, value := range values {
			permutations = append(permutations, []float64{value})
		}
		return
	}
	for i := range values {
		newValues := lib_Float64RemoveFromSlice(values, i)
		for _, pc := range lib_Float64Permutation(newValues, r-1) {
			newC := append(pc, values[i])
			permutations = append(permutations, newC)
		}
	}
	return
}

func lib_Float64SliceCombination(values [][]float64, r int) (combinations [][][]float64, err error) {
	if r == 1 {
		for _, value := range values {
			combinations = append(combinations, [][]float64{value})
		}
		return
	}

	for i := range values {
		newValues := values
		for j := 0; j <= i; j++ {
			newValues = newValues[1:]
			if err != nil {
				return nil, err
			}
		}
		partialCombinations, err := lib_Float64SliceCombination(newValues, r-1)
		if err != nil {
			return nil, err
		}

		for _, pc := range partialCombinations {
			newC := append(pc, values[i])
			combinations = append(combinations, newC)
		}
	}
	return
}

func lib_Float64RemoveFromSlice(slice []float64, i int) []float64 {
	n := make([]float64, len(slice))
	copy(n, slice)
	return append(n[:i], n[i+1:]...)
}

func lib_toLines(scanner *bufio.Scanner) [][]string {
	var lines [][]string
	for scanner.Scan() {
		text := lib_TrimSpaceAndNewLineCodeAndTab(scanner.Text())
		if len(text) == 0 {
			lines = append(lines, []string{})
			continue
		}
		line := strings.Split(text, " ")
		lines = append(lines, line)
	}
	return lines
}

func lib_toLinesFromReader(reader *bufio.Reader) (lines [][]string, err error) {
	for {
		chunks, err := lib_readLineAsChunks(reader)
		if err == io.EOF {
			return lines, nil
		}

		if err != nil {
			return nil, fmt.Errorf("failed to read line from reader: %v", err)
		}
		lineStr := lib_TrimSpaceAndNewLineCodeAndTab(strings.Join(chunks, ""))
		line := strings.Split(lineStr, " ")
		lines = append(lines, line)
	}
}

func lib_readLineAsChunks(reader *bufio.Reader) (chunks []string, err error) {
	for {
		chunk, isPrefix, err := reader.ReadLine()
		if err != nil {
			return nil, err
		}
		chunks = append(chunks, string(chunk))
		if !isPrefix {
			return chunks, nil
		}
	}
}

type lib_Input struct {
	lines [][]string
}

func (i *lib_Input) validateColIndex(index int) error {
	if index < 0 {
		return errors.New(fmt.Sprintf("index is under zero: %d", index))
	}

	return nil
}

func (i *lib_Input) validateRowIndex(index int) error {
	if index >= len(i.lines) {
		return errors.New(fmt.Sprintf("index(%d) is larger than lines(%d)", index, len(i.lines)))
	}

	if index < 0 {
		return errors.New(fmt.Sprintf("index is under zero: %d", index))
	}
	return nil
}

func (i *lib_Input) GetLines(startRowIndex, endRowIndex int) ([][]string, error) {
	if err := i.validateRowIndex(startRowIndex); err != nil {
		return nil, fmt.Errorf("invalid start row index: %v", err)
	}
	if err := i.validateRowIndex(endRowIndex - 1); err != nil {
		return nil, fmt.Errorf("invalid end row index: %v", err)
	}
	return i.lines[startRowIndex:endRowIndex], nil
}

func (i *lib_Input) GetStringLinesFrom(fromIndex int) (newLines [][]string, err error) {
	for index := range i.lines {
		if index < fromIndex {
			continue
		}
		newLine, err := i.GetLine(index)
		if err != nil {
			return nil, err
		}
		newLines = append(newLines, newLine)
	}
	return
}

func (i *lib_Input) GetValue(rowIndex, colIndex int) (string, error) {
	line, err := i.GetLine(rowIndex)
	if err != nil {
		return "", err
	}
	if colIndex < 0 || colIndex >= len(line) {
		return "", fmt.Errorf("Invalid col index: %v ", colIndex)
	}
	return line[colIndex], nil
}

func (i *lib_Input) GetFirstValue(rowIndex int) (string, error) {
	return i.GetValue(rowIndex, 0)
}

func (i *lib_Input) GetColLine(colIndex int) (newLine []string, err error) {
	if err := i.validateColIndex(colIndex); err != nil {
		return nil, err
	}

	for i, line := range i.lines {
		if len(line) <= colIndex {
			return nil, errors.New(fmt.Sprintf("col index(%d) is larger than %dth line length(%d)", colIndex, i, len(line)))
		}
		newLine = append(newLine, line[colIndex])
	}

	return newLine, nil
}

func (i *lib_Input) GetLine(index int) ([]string, error) {
	if err := i.validateRowIndex(index); err != nil {
		return nil, err
	}
	return i.lines[index], nil
}

func (i *lib_Input) ReadAsStringGridFrom(fromIndex int) ([][]string, error) {
	lines, err := i.GetStringLinesFrom(fromIndex)
	if err != nil {
		return nil, err
	}

	var m [][]string
	for _, line := range lines {
		if len(line) > 1 {
			return nil, fmt.Errorf("unexpected length line: %v", line)
		}

		var mLine []string
		for _, r := range line[0] {
			mLine = append(mLine, string(r))
		}
		m = append(m, mLine)
	}
	return m, nil
}

func lib_NewInput(scanner *bufio.Scanner) *lib_Input {
	return &lib_Input{
		lines: lib_toLines(scanner),
	}
}

func lib_NewInputFromReader(reader *bufio.Reader) (*lib_Input, error) {
	lines, err := lib_toLinesFromReader(reader)
	if err != nil {
		return nil, fmt.Errorf("failed to create new Input from reader: %v", err)
	}
	return &lib_Input{
		lines: lines,
	}, nil
}

func (i *lib_Input) MustGetIntLines() (newLines [][]int) {
	newLines, err := i.GetIntLines()
	if err != nil {
		panic(err)
	}
	return newLines
}

func (i *lib_Input) MustGetIntLinesFrom(fromIndex int) (newLines [][]int) {
	newLines, err := i.GetIntLinesFrom(fromIndex)
	if err != nil {
		panic(err)
	}
	return newLines
}

func (i *lib_Input) MustGetIntLine(index int) []int {
	v, err := i.GetIntLine(index)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetIntValue(rowIndex, colIndex int) int {
	v, err := i.GetIntValue(rowIndex, colIndex)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetFirstIntValue(rowIndex int) int {
	v, err := i.GetFirstIntValue(rowIndex)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetColIntLine(colIndex int) (newLine []int) {
	newLine, err := i.GetColIntLine(colIndex)
	if err != nil {
		panic(err)
	}
	return newLine
}

func (i *lib_Input) MustGetInt8Lines() (newLines [][]int8) {
	newLines, err := i.GetInt8Lines()
	if err != nil {
		panic(err)
	}
	return newLines
}

func (i *lib_Input) MustGetInt8LinesFrom(fromIndex int) (newLines [][]int8) {
	newLines, err := i.GetInt8LinesFrom(fromIndex)
	if err != nil {
		panic(err)
	}
	return newLines
}

func (i *lib_Input) MustGetInt8Line(index int) []int8 {
	v, err := i.GetInt8Line(index)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetInt8Value(rowIndex, colIndex int) int8 {
	v, err := i.GetInt8Value(rowIndex, colIndex)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetFirstInt8Value(rowIndex int) int8 {
	v, err := i.GetFirstInt8Value(rowIndex)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetColInt8Line(colIndex int) (newLine []int8) {
	newLine, err := i.GetColInt8Line(colIndex)
	if err != nil {
		panic(err)
	}
	return newLine
}

func (i *lib_Input) MustGetInt16Lines() (newLines [][]int16) {
	newLines, err := i.GetInt16Lines()
	if err != nil {
		panic(err)
	}
	return newLines
}

func (i *lib_Input) MustGetInt16LinesFrom(fromIndex int) (newLines [][]int16) {
	newLines, err := i.GetInt16LinesFrom(fromIndex)
	if err != nil {
		panic(err)
	}
	return newLines
}

func (i *lib_Input) MustGetInt16Line(index int) []int16 {
	v, err := i.GetInt16Line(index)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetInt16Value(rowIndex, colIndex int) int16 {
	v, err := i.GetInt16Value(rowIndex, colIndex)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetFirstInt16Value(rowIndex int) int16 {
	v, err := i.GetFirstInt16Value(rowIndex)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetColInt16Line(colIndex int) (newLine []int16) {
	newLine, err := i.GetColInt16Line(colIndex)
	if err != nil {
		panic(err)
	}
	return newLine
}

func (i *lib_Input) MustGetInt32Lines() (newLines [][]int32) {
	newLines, err := i.GetInt32Lines()
	if err != nil {
		panic(err)
	}
	return newLines
}

func (i *lib_Input) MustGetInt32LinesFrom(fromIndex int) (newLines [][]int32) {
	newLines, err := i.GetInt32LinesFrom(fromIndex)
	if err != nil {
		panic(err)
	}
	return newLines
}

func (i *lib_Input) MustGetInt32Line(index int) []int32 {
	v, err := i.GetInt32Line(index)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetInt32Value(rowIndex, colIndex int) int32 {
	v, err := i.GetInt32Value(rowIndex, colIndex)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetFirstInt32Value(rowIndex int) int32 {
	v, err := i.GetFirstInt32Value(rowIndex)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetColInt32Line(colIndex int) (newLine []int32) {
	newLine, err := i.GetColInt32Line(colIndex)
	if err != nil {
		panic(err)
	}
	return newLine
}

func (i *lib_Input) MustGetInt64Lines() (newLines [][]int64) {
	newLines, err := i.GetInt64Lines()
	if err != nil {
		panic(err)
	}
	return newLines
}

func (i *lib_Input) MustGetInt64LinesFrom(fromIndex int) (newLines [][]int64) {
	newLines, err := i.GetInt64LinesFrom(fromIndex)
	if err != nil {
		panic(err)
	}
	return newLines
}

func (i *lib_Input) MustGetInt64Line(index int) []int64 {
	v, err := i.GetInt64Line(index)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetInt64Value(rowIndex, colIndex int) int64 {
	v, err := i.GetInt64Value(rowIndex, colIndex)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetFirstInt64Value(rowIndex int) int64 {
	v, err := i.GetFirstInt64Value(rowIndex)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetColInt64Line(colIndex int) (newLine []int64) {
	newLine, err := i.GetColInt64Line(colIndex)
	if err != nil {
		panic(err)
	}
	return newLine
}

func (i *lib_Input) MustGetFloat32Lines() (newLines [][]float32) {
	newLines, err := i.GetFloat32Lines()
	if err != nil {
		panic(err)
	}
	return newLines
}

func (i *lib_Input) MustGetFloat32LinesFrom(fromIndex int) (newLines [][]float32) {
	newLines, err := i.GetFloat32LinesFrom(fromIndex)
	if err != nil {
		panic(err)
	}
	return newLines
}

func (i *lib_Input) MustGetFloat32Line(index int) []float32 {
	v, err := i.GetFloat32Line(index)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetFloat32Value(rowIndex, colIndex int) float32 {
	v, err := i.GetFloat32Value(rowIndex, colIndex)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetFirstFloat32Value(rowIndex int) float32 {
	v, err := i.GetFirstFloat32Value(rowIndex)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetColFloat32Line(colIndex int) (newLine []float32) {
	newLine, err := i.GetColFloat32Line(colIndex)
	if err != nil {
		panic(err)
	}
	return newLine
}

func (i *lib_Input) MustGetFloat64Lines() (newLines [][]float64) {
	newLines, err := i.GetFloat64Lines()
	if err != nil {
		panic(err)
	}
	return newLines
}

func (i *lib_Input) MustGetFloat64LinesFrom(fromIndex int) (newLines [][]float64) {
	newLines, err := i.GetFloat64LinesFrom(fromIndex)
	if err != nil {
		panic(err)
	}
	return newLines
}

func (i *lib_Input) MustGetFloat64Line(index int) []float64 {
	v, err := i.GetFloat64Line(index)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetFloat64Value(rowIndex, colIndex int) float64 {
	v, err := i.GetFloat64Value(rowIndex, colIndex)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetFirstFloat64Value(rowIndex int) float64 {
	v, err := i.GetFirstFloat64Value(rowIndex)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetColFloat64Line(colIndex int) (newLine []float64) {
	newLine, err := i.GetColFloat64Line(colIndex)
	if err != nil {
		panic(err)
	}
	return newLine
}

func lib_MustSubtractIntBy(values1 []int, values2 []int, f func(v int) int) (newValues []int) {
	newValues, err := lib_SubtractIntBy(values1, values2, f)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustSubtractInt(values1 []int, values2 []int) (newValues []int) {
	newValues, err := lib_SubtractInt(values1, values2)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustRDiffIntBy(values []int, f func(v int) int) (newValues []int) {
	newValues, err := lib_RDiffIntBy(values, f)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustRDiffInt(values []int) (newValues []int) {
	newValues, err := lib_RDiffInt(values)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustStringToIntSlice(s string) (ValueLine []int) {
	ValueLine, err := lib_StringToIntSlice(s)
	if err != nil {
		panic(err)
	}
	return ValueLine
}

func lib_MustStringSliceToIntSlice(line []string) (ValueLine []int) {
	ValueLine, err := lib_StringSliceToIntSlice(line)
	if err != nil {
		panic(err)
	}
	return ValueLine
}

func lib_MustMaxInt(values []int) (max int) {
	max, err := lib_MaxInt(values)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMinInt(values []int) (min int) {
	min, err := lib_MinInt(values)
	if err != nil {
		panic(err)
	}
	return min
}

func lib_MustSubtractInt8By(values1 []int8, values2 []int8, f func(v int8) int8) (newValues []int8) {
	newValues, err := lib_SubtractInt8By(values1, values2, f)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustSubtractInt8(values1 []int8, values2 []int8) (newValues []int8) {
	newValues, err := lib_SubtractInt8(values1, values2)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustRDiffInt8By(values []int8, f func(v int8) int8) (newValues []int8) {
	newValues, err := lib_RDiffInt8By(values, f)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustRDiffInt8(values []int8) (newValues []int8) {
	newValues, err := lib_RDiffInt8(values)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustStringToInt8Slice(s string) (ValueLine []int8) {
	ValueLine, err := lib_StringToInt8Slice(s)
	if err != nil {
		panic(err)
	}
	return ValueLine
}

func lib_MustStringSliceToInt8Slice(line []string) (ValueLine []int8) {
	ValueLine, err := lib_StringSliceToInt8Slice(line)
	if err != nil {
		panic(err)
	}
	return ValueLine
}

func lib_MustMaxInt8(values []int8) (max int8) {
	max, err := lib_MaxInt8(values)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMinInt8(values []int8) (min int8) {
	min, err := lib_MinInt8(values)
	if err != nil {
		panic(err)
	}
	return min
}

func lib_MustSubtractInt16By(values1 []int16, values2 []int16, f func(v int16) int16) (newValues []int16) {
	newValues, err := lib_SubtractInt16By(values1, values2, f)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustSubtractInt16(values1 []int16, values2 []int16) (newValues []int16) {
	newValues, err := lib_SubtractInt16(values1, values2)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustRDiffInt16By(values []int16, f func(v int16) int16) (newValues []int16) {
	newValues, err := lib_RDiffInt16By(values, f)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustRDiffInt16(values []int16) (newValues []int16) {
	newValues, err := lib_RDiffInt16(values)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustStringToInt16Slice(s string) (ValueLine []int16) {
	ValueLine, err := lib_StringToInt16Slice(s)
	if err != nil {
		panic(err)
	}
	return ValueLine
}

func lib_MustStringSliceToInt16Slice(line []string) (ValueLine []int16) {
	ValueLine, err := lib_StringSliceToInt16Slice(line)
	if err != nil {
		panic(err)
	}
	return ValueLine
}

func lib_MustMaxInt16(values []int16) (max int16) {
	max, err := lib_MaxInt16(values)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMinInt16(values []int16) (min int16) {
	min, err := lib_MinInt16(values)
	if err != nil {
		panic(err)
	}
	return min
}

func lib_MustSubtractInt32By(values1 []int32, values2 []int32, f func(v int32) int32) (newValues []int32) {
	newValues, err := lib_SubtractInt32By(values1, values2, f)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustSubtractInt32(values1 []int32, values2 []int32) (newValues []int32) {
	newValues, err := lib_SubtractInt32(values1, values2)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustRDiffInt32By(values []int32, f func(v int32) int32) (newValues []int32) {
	newValues, err := lib_RDiffInt32By(values, f)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustRDiffInt32(values []int32) (newValues []int32) {
	newValues, err := lib_RDiffInt32(values)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustStringToInt32Slice(s string) (ValueLine []int32) {
	ValueLine, err := lib_StringToInt32Slice(s)
	if err != nil {
		panic(err)
	}
	return ValueLine
}

func lib_MustStringSliceToInt32Slice(line []string) (ValueLine []int32) {
	ValueLine, err := lib_StringSliceToInt32Slice(line)
	if err != nil {
		panic(err)
	}
	return ValueLine
}

func lib_MustMaxInt32(values []int32) (max int32) {
	max, err := lib_MaxInt32(values)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMinInt32(values []int32) (min int32) {
	min, err := lib_MinInt32(values)
	if err != nil {
		panic(err)
	}
	return min
}

func lib_MustSubtractInt64By(values1 []int64, values2 []int64, f func(v int64) int64) (newValues []int64) {
	newValues, err := lib_SubtractInt64By(values1, values2, f)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustSubtractInt64(values1 []int64, values2 []int64) (newValues []int64) {
	newValues, err := lib_SubtractInt64(values1, values2)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustRDiffInt64By(values []int64, f func(v int64) int64) (newValues []int64) {
	newValues, err := lib_RDiffInt64By(values, f)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustRDiffInt64(values []int64) (newValues []int64) {
	newValues, err := lib_RDiffInt64(values)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustStringToInt64Slice(s string) (ValueLine []int64) {
	ValueLine, err := lib_StringToInt64Slice(s)
	if err != nil {
		panic(err)
	}
	return ValueLine
}

func lib_MustStringSliceToInt64Slice(line []string) (ValueLine []int64) {
	ValueLine, err := lib_StringSliceToInt64Slice(line)
	if err != nil {
		panic(err)
	}
	return ValueLine
}

func lib_MustMaxInt64(values []int64) (max int64) {
	max, err := lib_MaxInt64(values)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMinInt64(values []int64) (min int64) {
	min, err := lib_MinInt64(values)
	if err != nil {
		panic(err)
	}
	return min
}

func lib_MustSubtractFloat32By(values1 []float32, values2 []float32, f func(v float32) float32) (newValues []float32) {
	newValues, err := lib_SubtractFloat32By(values1, values2, f)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustSubtractFloat32(values1 []float32, values2 []float32) (newValues []float32) {
	newValues, err := lib_SubtractFloat32(values1, values2)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustRDiffFloat32By(values []float32, f func(v float32) float32) (newValues []float32) {
	newValues, err := lib_RDiffFloat32By(values, f)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustRDiffFloat32(values []float32) (newValues []float32) {
	newValues, err := lib_RDiffFloat32(values)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustStringToFloat32Slice(s string) (ValueLine []float32) {
	ValueLine, err := lib_StringToFloat32Slice(s)
	if err != nil {
		panic(err)
	}
	return ValueLine
}

func lib_MustStringSliceToFloat32Slice(line []string) (ValueLine []float32) {
	ValueLine, err := lib_StringSliceToFloat32Slice(line)
	if err != nil {
		panic(err)
	}
	return ValueLine
}

func lib_MustMaxFloat32(values []float32) (max float32) {
	max, err := lib_MaxFloat32(values)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMinFloat32(values []float32) (min float32) {
	min, err := lib_MinFloat32(values)
	if err != nil {
		panic(err)
	}
	return min
}

func lib_MustSubtractFloat64By(values1 []float64, values2 []float64, f func(v float64) float64) (newValues []float64) {
	newValues, err := lib_SubtractFloat64By(values1, values2, f)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustSubtractFloat64(values1 []float64, values2 []float64) (newValues []float64) {
	newValues, err := lib_SubtractFloat64(values1, values2)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustRDiffFloat64By(values []float64, f func(v float64) float64) (newValues []float64) {
	newValues, err := lib_RDiffFloat64By(values, f)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustRDiffFloat64(values []float64) (newValues []float64) {
	newValues, err := lib_RDiffFloat64(values)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustStringToFloat64Slice(s string) (ValueLine []float64) {
	ValueLine, err := lib_StringToFloat64Slice(s)
	if err != nil {
		panic(err)
	}
	return ValueLine
}

func lib_MustStringSliceToFloat64Slice(line []string) (ValueLine []float64) {
	ValueLine, err := lib_StringSliceToFloat64Slice(line)
	if err != nil {
		panic(err)
	}
	return ValueLine
}

func lib_MustMaxFloat64(values []float64) (max float64) {
	max, err := lib_MaxFloat64(values)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMinFloat64(values []float64) (min float64) {
	min, err := lib_MinFloat64(values)
	if err != nil {
		panic(err)
	}
	return min
}

func lib_MustMaxIntByIntSlice(values [][]int, f func(vs []int) int) (max int) {
	max, err := lib_MaxIntByIntSlice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxIntByIntSlice2(values [][][]int, f func(vs [][]int) int) (max int) {
	max, err := lib_MaxIntByIntSlice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxIntByInt8Slice(values [][]int8, f func(vs []int8) int) (max int) {
	max, err := lib_MaxIntByInt8Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxIntByInt8Slice2(values [][][]int8, f func(vs [][]int8) int) (max int) {
	max, err := lib_MaxIntByInt8Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxIntByInt16Slice(values [][]int16, f func(vs []int16) int) (max int) {
	max, err := lib_MaxIntByInt16Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxIntByInt16Slice2(values [][][]int16, f func(vs [][]int16) int) (max int) {
	max, err := lib_MaxIntByInt16Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxIntByInt32Slice(values [][]int32, f func(vs []int32) int) (max int) {
	max, err := lib_MaxIntByInt32Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxIntByInt32Slice2(values [][][]int32, f func(vs [][]int32) int) (max int) {
	max, err := lib_MaxIntByInt32Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxIntByInt64Slice(values [][]int64, f func(vs []int64) int) (max int) {
	max, err := lib_MaxIntByInt64Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxIntByInt64Slice2(values [][][]int64, f func(vs [][]int64) int) (max int) {
	max, err := lib_MaxIntByInt64Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxIntByFloat32Slice(values [][]float32, f func(vs []float32) int) (max int) {
	max, err := lib_MaxIntByFloat32Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxIntByFloat32Slice2(values [][][]float32, f func(vs [][]float32) int) (max int) {
	max, err := lib_MaxIntByFloat32Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxIntByFloat64Slice(values [][]float64, f func(vs []float64) int) (max int) {
	max, err := lib_MaxIntByFloat64Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxIntByFloat64Slice2(values [][][]float64, f func(vs [][]float64) int) (max int) {
	max, err := lib_MaxIntByFloat64Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt8ByIntSlice(values [][]int, f func(vs []int) int8) (max int8) {
	max, err := lib_MaxInt8ByIntSlice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt8ByIntSlice2(values [][][]int, f func(vs [][]int) int8) (max int8) {
	max, err := lib_MaxInt8ByIntSlice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt8ByInt8Slice(values [][]int8, f func(vs []int8) int8) (max int8) {
	max, err := lib_MaxInt8ByInt8Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt8ByInt8Slice2(values [][][]int8, f func(vs [][]int8) int8) (max int8) {
	max, err := lib_MaxInt8ByInt8Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt8ByInt16Slice(values [][]int16, f func(vs []int16) int8) (max int8) {
	max, err := lib_MaxInt8ByInt16Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt8ByInt16Slice2(values [][][]int16, f func(vs [][]int16) int8) (max int8) {
	max, err := lib_MaxInt8ByInt16Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt8ByInt32Slice(values [][]int32, f func(vs []int32) int8) (max int8) {
	max, err := lib_MaxInt8ByInt32Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt8ByInt32Slice2(values [][][]int32, f func(vs [][]int32) int8) (max int8) {
	max, err := lib_MaxInt8ByInt32Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt8ByInt64Slice(values [][]int64, f func(vs []int64) int8) (max int8) {
	max, err := lib_MaxInt8ByInt64Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt8ByInt64Slice2(values [][][]int64, f func(vs [][]int64) int8) (max int8) {
	max, err := lib_MaxInt8ByInt64Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt8ByFloat32Slice(values [][]float32, f func(vs []float32) int8) (max int8) {
	max, err := lib_MaxInt8ByFloat32Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt8ByFloat32Slice2(values [][][]float32, f func(vs [][]float32) int8) (max int8) {
	max, err := lib_MaxInt8ByFloat32Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt8ByFloat64Slice(values [][]float64, f func(vs []float64) int8) (max int8) {
	max, err := lib_MaxInt8ByFloat64Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt8ByFloat64Slice2(values [][][]float64, f func(vs [][]float64) int8) (max int8) {
	max, err := lib_MaxInt8ByFloat64Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt16ByIntSlice(values [][]int, f func(vs []int) int16) (max int16) {
	max, err := lib_MaxInt16ByIntSlice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt16ByIntSlice2(values [][][]int, f func(vs [][]int) int16) (max int16) {
	max, err := lib_MaxInt16ByIntSlice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt16ByInt8Slice(values [][]int8, f func(vs []int8) int16) (max int16) {
	max, err := lib_MaxInt16ByInt8Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt16ByInt8Slice2(values [][][]int8, f func(vs [][]int8) int16) (max int16) {
	max, err := lib_MaxInt16ByInt8Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt16ByInt16Slice(values [][]int16, f func(vs []int16) int16) (max int16) {
	max, err := lib_MaxInt16ByInt16Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt16ByInt16Slice2(values [][][]int16, f func(vs [][]int16) int16) (max int16) {
	max, err := lib_MaxInt16ByInt16Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt16ByInt32Slice(values [][]int32, f func(vs []int32) int16) (max int16) {
	max, err := lib_MaxInt16ByInt32Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt16ByInt32Slice2(values [][][]int32, f func(vs [][]int32) int16) (max int16) {
	max, err := lib_MaxInt16ByInt32Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt16ByInt64Slice(values [][]int64, f func(vs []int64) int16) (max int16) {
	max, err := lib_MaxInt16ByInt64Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt16ByInt64Slice2(values [][][]int64, f func(vs [][]int64) int16) (max int16) {
	max, err := lib_MaxInt16ByInt64Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt16ByFloat32Slice(values [][]float32, f func(vs []float32) int16) (max int16) {
	max, err := lib_MaxInt16ByFloat32Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt16ByFloat32Slice2(values [][][]float32, f func(vs [][]float32) int16) (max int16) {
	max, err := lib_MaxInt16ByFloat32Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt16ByFloat64Slice(values [][]float64, f func(vs []float64) int16) (max int16) {
	max, err := lib_MaxInt16ByFloat64Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt16ByFloat64Slice2(values [][][]float64, f func(vs [][]float64) int16) (max int16) {
	max, err := lib_MaxInt16ByFloat64Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt32ByIntSlice(values [][]int, f func(vs []int) int32) (max int32) {
	max, err := lib_MaxInt32ByIntSlice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt32ByIntSlice2(values [][][]int, f func(vs [][]int) int32) (max int32) {
	max, err := lib_MaxInt32ByIntSlice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt32ByInt8Slice(values [][]int8, f func(vs []int8) int32) (max int32) {
	max, err := lib_MaxInt32ByInt8Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt32ByInt8Slice2(values [][][]int8, f func(vs [][]int8) int32) (max int32) {
	max, err := lib_MaxInt32ByInt8Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt32ByInt16Slice(values [][]int16, f func(vs []int16) int32) (max int32) {
	max, err := lib_MaxInt32ByInt16Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt32ByInt16Slice2(values [][][]int16, f func(vs [][]int16) int32) (max int32) {
	max, err := lib_MaxInt32ByInt16Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt32ByInt32Slice(values [][]int32, f func(vs []int32) int32) (max int32) {
	max, err := lib_MaxInt32ByInt32Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt32ByInt32Slice2(values [][][]int32, f func(vs [][]int32) int32) (max int32) {
	max, err := lib_MaxInt32ByInt32Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt32ByInt64Slice(values [][]int64, f func(vs []int64) int32) (max int32) {
	max, err := lib_MaxInt32ByInt64Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt32ByInt64Slice2(values [][][]int64, f func(vs [][]int64) int32) (max int32) {
	max, err := lib_MaxInt32ByInt64Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt32ByFloat32Slice(values [][]float32, f func(vs []float32) int32) (max int32) {
	max, err := lib_MaxInt32ByFloat32Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt32ByFloat32Slice2(values [][][]float32, f func(vs [][]float32) int32) (max int32) {
	max, err := lib_MaxInt32ByFloat32Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt32ByFloat64Slice(values [][]float64, f func(vs []float64) int32) (max int32) {
	max, err := lib_MaxInt32ByFloat64Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt32ByFloat64Slice2(values [][][]float64, f func(vs [][]float64) int32) (max int32) {
	max, err := lib_MaxInt32ByFloat64Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt64ByIntSlice(values [][]int, f func(vs []int) int64) (max int64) {
	max, err := lib_MaxInt64ByIntSlice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt64ByIntSlice2(values [][][]int, f func(vs [][]int) int64) (max int64) {
	max, err := lib_MaxInt64ByIntSlice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt64ByInt8Slice(values [][]int8, f func(vs []int8) int64) (max int64) {
	max, err := lib_MaxInt64ByInt8Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt64ByInt8Slice2(values [][][]int8, f func(vs [][]int8) int64) (max int64) {
	max, err := lib_MaxInt64ByInt8Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt64ByInt16Slice(values [][]int16, f func(vs []int16) int64) (max int64) {
	max, err := lib_MaxInt64ByInt16Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt64ByInt16Slice2(values [][][]int16, f func(vs [][]int16) int64) (max int64) {
	max, err := lib_MaxInt64ByInt16Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt64ByInt32Slice(values [][]int32, f func(vs []int32) int64) (max int64) {
	max, err := lib_MaxInt64ByInt32Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt64ByInt32Slice2(values [][][]int32, f func(vs [][]int32) int64) (max int64) {
	max, err := lib_MaxInt64ByInt32Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt64ByInt64Slice(values [][]int64, f func(vs []int64) int64) (max int64) {
	max, err := lib_MaxInt64ByInt64Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt64ByInt64Slice2(values [][][]int64, f func(vs [][]int64) int64) (max int64) {
	max, err := lib_MaxInt64ByInt64Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt64ByFloat32Slice(values [][]float32, f func(vs []float32) int64) (max int64) {
	max, err := lib_MaxInt64ByFloat32Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt64ByFloat32Slice2(values [][][]float32, f func(vs [][]float32) int64) (max int64) {
	max, err := lib_MaxInt64ByFloat32Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt64ByFloat64Slice(values [][]float64, f func(vs []float64) int64) (max int64) {
	max, err := lib_MaxInt64ByFloat64Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt64ByFloat64Slice2(values [][][]float64, f func(vs [][]float64) int64) (max int64) {
	max, err := lib_MaxInt64ByFloat64Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat32ByIntSlice(values [][]int, f func(vs []int) float32) (max float32) {
	max, err := lib_MaxFloat32ByIntSlice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat32ByIntSlice2(values [][][]int, f func(vs [][]int) float32) (max float32) {
	max, err := lib_MaxFloat32ByIntSlice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat32ByInt8Slice(values [][]int8, f func(vs []int8) float32) (max float32) {
	max, err := lib_MaxFloat32ByInt8Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat32ByInt8Slice2(values [][][]int8, f func(vs [][]int8) float32) (max float32) {
	max, err := lib_MaxFloat32ByInt8Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat32ByInt16Slice(values [][]int16, f func(vs []int16) float32) (max float32) {
	max, err := lib_MaxFloat32ByInt16Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat32ByInt16Slice2(values [][][]int16, f func(vs [][]int16) float32) (max float32) {
	max, err := lib_MaxFloat32ByInt16Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat32ByInt32Slice(values [][]int32, f func(vs []int32) float32) (max float32) {
	max, err := lib_MaxFloat32ByInt32Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat32ByInt32Slice2(values [][][]int32, f func(vs [][]int32) float32) (max float32) {
	max, err := lib_MaxFloat32ByInt32Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat32ByInt64Slice(values [][]int64, f func(vs []int64) float32) (max float32) {
	max, err := lib_MaxFloat32ByInt64Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat32ByInt64Slice2(values [][][]int64, f func(vs [][]int64) float32) (max float32) {
	max, err := lib_MaxFloat32ByInt64Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat32ByFloat32Slice(values [][]float32, f func(vs []float32) float32) (max float32) {
	max, err := lib_MaxFloat32ByFloat32Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat32ByFloat32Slice2(values [][][]float32, f func(vs [][]float32) float32) (max float32) {
	max, err := lib_MaxFloat32ByFloat32Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat32ByFloat64Slice(values [][]float64, f func(vs []float64) float32) (max float32) {
	max, err := lib_MaxFloat32ByFloat64Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat32ByFloat64Slice2(values [][][]float64, f func(vs [][]float64) float32) (max float32) {
	max, err := lib_MaxFloat32ByFloat64Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat64ByIntSlice(values [][]int, f func(vs []int) float64) (max float64) {
	max, err := lib_MaxFloat64ByIntSlice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat64ByIntSlice2(values [][][]int, f func(vs [][]int) float64) (max float64) {
	max, err := lib_MaxFloat64ByIntSlice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat64ByInt8Slice(values [][]int8, f func(vs []int8) float64) (max float64) {
	max, err := lib_MaxFloat64ByInt8Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat64ByInt8Slice2(values [][][]int8, f func(vs [][]int8) float64) (max float64) {
	max, err := lib_MaxFloat64ByInt8Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat64ByInt16Slice(values [][]int16, f func(vs []int16) float64) (max float64) {
	max, err := lib_MaxFloat64ByInt16Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat64ByInt16Slice2(values [][][]int16, f func(vs [][]int16) float64) (max float64) {
	max, err := lib_MaxFloat64ByInt16Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat64ByInt32Slice(values [][]int32, f func(vs []int32) float64) (max float64) {
	max, err := lib_MaxFloat64ByInt32Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat64ByInt32Slice2(values [][][]int32, f func(vs [][]int32) float64) (max float64) {
	max, err := lib_MaxFloat64ByInt32Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat64ByInt64Slice(values [][]int64, f func(vs []int64) float64) (max float64) {
	max, err := lib_MaxFloat64ByInt64Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat64ByInt64Slice2(values [][][]int64, f func(vs [][]int64) float64) (max float64) {
	max, err := lib_MaxFloat64ByInt64Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat64ByFloat32Slice(values [][]float32, f func(vs []float32) float64) (max float64) {
	max, err := lib_MaxFloat64ByFloat32Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat64ByFloat32Slice2(values [][][]float32, f func(vs [][]float32) float64) (max float64) {
	max, err := lib_MaxFloat64ByFloat32Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat64ByFloat64Slice(values [][]float64, f func(vs []float64) float64) (max float64) {
	max, err := lib_MaxFloat64ByFloat64Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat64ByFloat64Slice2(values [][][]float64, f func(vs [][]float64) float64) (max float64) {
	max, err := lib_MaxFloat64ByFloat64Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustZipRune(valuesList ...[]rune) (newValuesList [][]rune) {
	newValuesList, err := lib_ZipRune(valuesList...)
	if err != nil {
		panic(err)
	}
	return newValuesList
}

func lib_MustChunkRuneByBits(values []rune, bits []bool) (newValues [][]rune) {
	newValues, err := lib_ChunkRuneByBits(values, bits)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustUnsetRune(values []rune, i int) []rune {
	v, err := lib_UnsetRune(values, i)
	if err != nil {
		panic(err)
	}
	return v
}

func lib_MustRuneCombination(values []rune, r int) (combinations [][]rune) {
	combinations, err := lib_RuneCombination(values, r)
	if err != nil {
		panic(err)
	}
	return combinations
}

func lib_MustRuneSliceCombination(values [][]rune, r int) (combinations [][][]rune) {
	combinations, err := lib_RuneSliceCombination(values, r)
	if err != nil {
		panic(err)
	}
	return combinations
}

func lib_MustZipString(valuesList ...[]string) (newValuesList [][]string) {
	newValuesList, err := lib_ZipString(valuesList...)
	if err != nil {
		panic(err)
	}
	return newValuesList
}

func lib_MustChunkStringByBits(values []string, bits []bool) (newValues [][]string) {
	newValues, err := lib_ChunkStringByBits(values, bits)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustUnsetString(values []string, i int) []string {
	v, err := lib_UnsetString(values, i)
	if err != nil {
		panic(err)
	}
	return v
}

func lib_MustStringCombination(values []string, r int) (combinations [][]string) {
	combinations, err := lib_StringCombination(values, r)
	if err != nil {
		panic(err)
	}
	return combinations
}

func lib_MustStringSliceCombination(values [][]string, r int) (combinations [][][]string) {
	combinations, err := lib_StringSliceCombination(values, r)
	if err != nil {
		panic(err)
	}
	return combinations
}

func lib_MustZipInt(valuesList ...[]int) (newValuesList [][]int) {
	newValuesList, err := lib_ZipInt(valuesList...)
	if err != nil {
		panic(err)
	}
	return newValuesList
}

func lib_MustChunkIntByBits(values []int, bits []bool) (newValues [][]int) {
	newValues, err := lib_ChunkIntByBits(values, bits)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustUnsetInt(values []int, i int) []int {
	v, err := lib_UnsetInt(values, i)
	if err != nil {
		panic(err)
	}
	return v
}

func lib_MustIntCombination(values []int, r int) (combinations [][]int) {
	combinations, err := lib_IntCombination(values, r)
	if err != nil {
		panic(err)
	}
	return combinations
}

func lib_MustIntSliceCombination(values [][]int, r int) (combinations [][][]int) {
	combinations, err := lib_IntSliceCombination(values, r)
	if err != nil {
		panic(err)
	}
	return combinations
}

func lib_MustZipInt8(valuesList ...[]int8) (newValuesList [][]int8) {
	newValuesList, err := lib_ZipInt8(valuesList...)
	if err != nil {
		panic(err)
	}
	return newValuesList
}

func lib_MustChunkInt8ByBits(values []int8, bits []bool) (newValues [][]int8) {
	newValues, err := lib_ChunkInt8ByBits(values, bits)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustUnsetInt8(values []int8, i int) []int8 {
	v, err := lib_UnsetInt8(values, i)
	if err != nil {
		panic(err)
	}
	return v
}

func lib_MustInt8Combination(values []int8, r int) (combinations [][]int8) {
	combinations, err := lib_Int8Combination(values, r)
	if err != nil {
		panic(err)
	}
	return combinations
}

func lib_MustInt8SliceCombination(values [][]int8, r int) (combinations [][][]int8) {
	combinations, err := lib_Int8SliceCombination(values, r)
	if err != nil {
		panic(err)
	}
	return combinations
}

func lib_MustZipInt16(valuesList ...[]int16) (newValuesList [][]int16) {
	newValuesList, err := lib_ZipInt16(valuesList...)
	if err != nil {
		panic(err)
	}
	return newValuesList
}

func lib_MustChunkInt16ByBits(values []int16, bits []bool) (newValues [][]int16) {
	newValues, err := lib_ChunkInt16ByBits(values, bits)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustUnsetInt16(values []int16, i int) []int16 {
	v, err := lib_UnsetInt16(values, i)
	if err != nil {
		panic(err)
	}
	return v
}

func lib_MustInt16Combination(values []int16, r int) (combinations [][]int16) {
	combinations, err := lib_Int16Combination(values, r)
	if err != nil {
		panic(err)
	}
	return combinations
}

func lib_MustInt16SliceCombination(values [][]int16, r int) (combinations [][][]int16) {
	combinations, err := lib_Int16SliceCombination(values, r)
	if err != nil {
		panic(err)
	}
	return combinations
}

func lib_MustZipInt32(valuesList ...[]int32) (newValuesList [][]int32) {
	newValuesList, err := lib_ZipInt32(valuesList...)
	if err != nil {
		panic(err)
	}
	return newValuesList
}

func lib_MustChunkInt32ByBits(values []int32, bits []bool) (newValues [][]int32) {
	newValues, err := lib_ChunkInt32ByBits(values, bits)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustUnsetInt32(values []int32, i int) []int32 {
	v, err := lib_UnsetInt32(values, i)
	if err != nil {
		panic(err)
	}
	return v
}

func lib_MustInt32Combination(values []int32, r int) (combinations [][]int32) {
	combinations, err := lib_Int32Combination(values, r)
	if err != nil {
		panic(err)
	}
	return combinations
}

func lib_MustInt32SliceCombination(values [][]int32, r int) (combinations [][][]int32) {
	combinations, err := lib_Int32SliceCombination(values, r)
	if err != nil {
		panic(err)
	}
	return combinations
}

func lib_MustZipInt64(valuesList ...[]int64) (newValuesList [][]int64) {
	newValuesList, err := lib_ZipInt64(valuesList...)
	if err != nil {
		panic(err)
	}
	return newValuesList
}

func lib_MustChunkInt64ByBits(values []int64, bits []bool) (newValues [][]int64) {
	newValues, err := lib_ChunkInt64ByBits(values, bits)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustUnsetInt64(values []int64, i int) []int64 {
	v, err := lib_UnsetInt64(values, i)
	if err != nil {
		panic(err)
	}
	return v
}

func lib_MustInt64Combination(values []int64, r int) (combinations [][]int64) {
	combinations, err := lib_Int64Combination(values, r)
	if err != nil {
		panic(err)
	}
	return combinations
}

func lib_MustInt64SliceCombination(values [][]int64, r int) (combinations [][][]int64) {
	combinations, err := lib_Int64SliceCombination(values, r)
	if err != nil {
		panic(err)
	}
	return combinations
}

func lib_MustZipFloat32(valuesList ...[]float32) (newValuesList [][]float32) {
	newValuesList, err := lib_ZipFloat32(valuesList...)
	if err != nil {
		panic(err)
	}
	return newValuesList
}

func lib_MustChunkFloat32ByBits(values []float32, bits []bool) (newValues [][]float32) {
	newValues, err := lib_ChunkFloat32ByBits(values, bits)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustUnsetFloat32(values []float32, i int) []float32 {
	v, err := lib_UnsetFloat32(values, i)
	if err != nil {
		panic(err)
	}
	return v
}

func lib_MustFloat32Combination(values []float32, r int) (combinations [][]float32) {
	combinations, err := lib_Float32Combination(values, r)
	if err != nil {
		panic(err)
	}
	return combinations
}

func lib_MustFloat32SliceCombination(values [][]float32, r int) (combinations [][][]float32) {
	combinations, err := lib_Float32SliceCombination(values, r)
	if err != nil {
		panic(err)
	}
	return combinations
}

func lib_MustZipFloat64(valuesList ...[]float64) (newValuesList [][]float64) {
	newValuesList, err := lib_ZipFloat64(valuesList...)
	if err != nil {
		panic(err)
	}
	return newValuesList
}

func lib_MustChunkFloat64ByBits(values []float64, bits []bool) (newValues [][]float64) {
	newValues, err := lib_ChunkFloat64ByBits(values, bits)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustUnsetFloat64(values []float64, i int) []float64 {
	v, err := lib_UnsetFloat64(values, i)
	if err != nil {
		panic(err)
	}
	return v
}

func lib_MustFloat64Combination(values []float64, r int) (combinations [][]float64) {
	combinations, err := lib_Float64Combination(values, r)
	if err != nil {
		panic(err)
	}
	return combinations
}

func lib_MustFloat64SliceCombination(values [][]float64, r int) (combinations [][][]float64) {
	combinations, err := lib_Float64SliceCombination(values, r)
	if err != nil {
		panic(err)
	}
	return combinations
}

func (i *lib_Input) MustGetLines(startRowIndex, endRowIndex int) [][]string {
	v, err := i.GetLines(startRowIndex, endRowIndex)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetStringLinesFrom(fromIndex int) (newLines [][]string) {
	newLines, err := i.GetStringLinesFrom(fromIndex)
	if err != nil {
		panic(err)
	}
	return newLines
}

func (i *lib_Input) MustGetValue(rowIndex, colIndex int) string {
	v, err := i.GetValue(rowIndex, colIndex)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetFirstValue(rowIndex int) string {
	v, err := i.GetFirstValue(rowIndex)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetColLine(colIndex int) (newLine []string) {
	newLine, err := i.GetColLine(colIndex)
	if err != nil {
		panic(err)
	}
	return newLine
}

func (i *lib_Input) MustGetLine(index int) []string {
	v, err := i.GetLine(index)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustReadAsStringGridFrom(fromIndex int) [][]string {
	v, err := i.ReadAsStringGridFrom(fromIndex)
	if err != nil {
		panic(err)
	}
	return v
}

func lib_MustNewInputFromReader(reader *bufio.Reader) *lib_Input {
	v, err := lib_NewInputFromReader(reader)
	if err != nil {
		panic(err)
	}
	return v
}

func lib_toSpecificBitIntLine(line []string, bitSize int) (intLine []int64, err error) {
	for j, v := range line {
		intV, err := strconv.ParseInt(v, 10, bitSize)
		if err != nil {
			return nil, fmt.Errorf(fmt.Sprintf("%dth value: %v", j, err.Error()))
		}
		intLine = append(intLine, intV)
	}
	return intLine, nil
}

func lib_BitEnumeration(digits uint) (enums [][]bool) {
	if digits == 0 {
		return [][]bool{}
	}

	for i := 0; i < 1<<digits; i++ {
		e := []bool{}
		for d := uint(0); d < digits; d++ {
			e = append(e, i>>d&1 == 1)
		}
		enums = append(enums, e)
	}
	return
}

func lib_FindPosFromStringGrid(m [][]string, s string) (int, int) {
	for rowIndex, row := range m {
		for colIndex, p := range row {
			if p == s {
				return rowIndex, colIndex
			}
		}
	}
	panic(s + " not found")
}

func lib_PanicIfErrorExist(err error) {
	if err != nil {
		panic(err)
	}
}

func lib_TrimSpaceAndNewLineCodeAndTab(s string) string {
	return strings.TrimFunc(s, func(r rune) bool {
		return r == ' ' || r == '\r' || r == '\n' || r == '\t'
	})
}
