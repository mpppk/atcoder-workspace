// Code generated by golang.org/x/tools/cmd/bundle. DO NOT EDIT.
//go:generate bundle -o abc159/A/bundled_gen.go -pkg main -dst github.com/mpppk/atcoder/abc159/A github.com/mpppk/atcoder/gen

// go:generate goofy mustify --file input.go
//

package F

import (
	"bufio"
	"errors"
	"fmt"
	"io"
	"math"
	"math/big"
	"strconv"
	"strings"
)

func (i *lib_Input) GetIntLines() (newLines [][]int, err error) {
	return i.GetIntLinesFrom(0)
}

func (i *lib_Input) GetIntLinesFrom(fromIndex int) (newLines [][]int, err error) {
	for index := range i.lines {
		if index < fromIndex {
			continue
		}
		newLine, err := i.GetIntLine(index)
		if err != nil {
			return nil, err
		}
		newLines = append(newLines, newLine)
	}
	return
}

func (i *lib_Input) GetIntLineRange(fromRowIndex, rangeNum int) (newLines [][]int, err error) {
	cnt := 0
	for index := range i.lines {
		if index < fromRowIndex {
			continue
		}
		newLine, err := i.GetIntLine(index)
		if err != nil {
			return nil, err
		}
		newLines = append(newLines, newLine)
		cnt++
		if cnt >= rangeNum {
			return newLines, nil
		}
	}
	return
}

func (i *lib_Input) GetIntLine(index int) ([]int, error) {
	if err := i.validateRowIndex(index); err != nil {
		return nil, err
	}

	newLine, err := lib_StringSliceToIntSlice(i.lines[index])
	if err != nil {
		return nil, fmt.Errorf("%dth index: %v", index, err)
	}
	return newLine, nil
}

func (i *lib_Input) GetIntValue(rowIndex, colIndex int) (int, error) {
	line, err := i.GetLine(rowIndex)
	if err != nil {
		return 0, err
	}
	if colIndex < 0 || colIndex >= len(line) {
		return 0, fmt.Errorf("Invalid col index: %v ", colIndex)
	}

	v, err := strconv.ParseInt(line[colIndex], 10, 64)
	if err != nil {
		return 0, fmt.Errorf("failed to convert string to int: %v, %v", line[colIndex], err)
	}

	return int(v), nil
}

func (i *lib_Input) GetFirstIntValue(rowIndex int) (int, error) {
	return i.GetIntValue(rowIndex, 0)
}

func (i *lib_Input) GetColIntLine(colIndex int) (newLine []int, err error) {
	strLine, err := i.GetColLine(colIndex)
	if err != nil {
		return nil, err
	}
	newLine, err = lib_StringSliceToIntSlice(strLine)
	if err != nil {
		return nil, fmt.Errorf("%dth col index: %v", colIndex, err)
	}
	return
}

func (i *lib_Input) GetInt8Lines() (newLines [][]int8, err error) {
	return i.GetInt8LinesFrom(0)
}

func (i *lib_Input) GetInt8LinesFrom(fromIndex int) (newLines [][]int8, err error) {
	for index := range i.lines {
		if index < fromIndex {
			continue
		}
		newLine, err := i.GetInt8Line(index)
		if err != nil {
			return nil, err
		}
		newLines = append(newLines, newLine)
	}
	return
}

func (i *lib_Input) GetInt8LineRange(fromRowIndex, rangeNum int) (newLines [][]int8, err error) {
	cnt := 0
	for index := range i.lines {
		if index < fromRowIndex {
			continue
		}
		newLine, err := i.GetInt8Line(index)
		if err != nil {
			return nil, err
		}
		newLines = append(newLines, newLine)
		cnt++
		if cnt >= rangeNum {
			return newLines, nil
		}
	}
	return
}

func (i *lib_Input) GetInt8Line(index int) ([]int8, error) {
	if err := i.validateRowIndex(index); err != nil {
		return nil, err
	}

	newLine, err := lib_StringSliceToInt8Slice(i.lines[index])
	if err != nil {
		return nil, fmt.Errorf("%dth index: %v", index, err)
	}
	return newLine, nil
}

func (i *lib_Input) GetInt8Value(rowIndex, colIndex int) (int8, error) {
	line, err := i.GetLine(rowIndex)
	if err != nil {
		return 0, err
	}
	if colIndex < 0 || colIndex >= len(line) {
		return 0, fmt.Errorf("Invalid col index: %v ", colIndex)
	}

	v, err := strconv.ParseInt(line[colIndex], 10, 64)
	if err != nil {
		return 0, fmt.Errorf("failed to convert string to int: %v, %v", line[colIndex], err)
	}

	return int8(v), nil
}

func (i *lib_Input) GetFirstInt8Value(rowIndex int) (int8, error) {
	return i.GetInt8Value(rowIndex, 0)
}

func (i *lib_Input) GetColInt8Line(colIndex int) (newLine []int8, err error) {
	strLine, err := i.GetColLine(colIndex)
	if err != nil {
		return nil, err
	}
	newLine, err = lib_StringSliceToInt8Slice(strLine)
	if err != nil {
		return nil, fmt.Errorf("%dth col index: %v", colIndex, err)
	}
	return
}

func (i *lib_Input) GetInt16Lines() (newLines [][]int16, err error) {
	return i.GetInt16LinesFrom(0)
}

func (i *lib_Input) GetInt16LinesFrom(fromIndex int) (newLines [][]int16, err error) {
	for index := range i.lines {
		if index < fromIndex {
			continue
		}
		newLine, err := i.GetInt16Line(index)
		if err != nil {
			return nil, err
		}
		newLines = append(newLines, newLine)
	}
	return
}

func (i *lib_Input) GetInt16LineRange(fromRowIndex, rangeNum int) (newLines [][]int16, err error) {
	cnt := 0
	for index := range i.lines {
		if index < fromRowIndex {
			continue
		}
		newLine, err := i.GetInt16Line(index)
		if err != nil {
			return nil, err
		}
		newLines = append(newLines, newLine)
		cnt++
		if cnt >= rangeNum {
			return newLines, nil
		}
	}
	return
}

func (i *lib_Input) GetInt16Line(index int) ([]int16, error) {
	if err := i.validateRowIndex(index); err != nil {
		return nil, err
	}

	newLine, err := lib_StringSliceToInt16Slice(i.lines[index])
	if err != nil {
		return nil, fmt.Errorf("%dth index: %v", index, err)
	}
	return newLine, nil
}

func (i *lib_Input) GetInt16Value(rowIndex, colIndex int) (int16, error) {
	line, err := i.GetLine(rowIndex)
	if err != nil {
		return 0, err
	}
	if colIndex < 0 || colIndex >= len(line) {
		return 0, fmt.Errorf("Invalid col index: %v ", colIndex)
	}

	v, err := strconv.ParseInt(line[colIndex], 10, 64)
	if err != nil {
		return 0, fmt.Errorf("failed to convert string to int: %v, %v", line[colIndex], err)
	}

	return int16(v), nil
}

func (i *lib_Input) GetFirstInt16Value(rowIndex int) (int16, error) {
	return i.GetInt16Value(rowIndex, 0)
}

func (i *lib_Input) GetColInt16Line(colIndex int) (newLine []int16, err error) {
	strLine, err := i.GetColLine(colIndex)
	if err != nil {
		return nil, err
	}
	newLine, err = lib_StringSliceToInt16Slice(strLine)
	if err != nil {
		return nil, fmt.Errorf("%dth col index: %v", colIndex, err)
	}
	return
}

func (i *lib_Input) GetInt32Lines() (newLines [][]int32, err error) {
	return i.GetInt32LinesFrom(0)
}

func (i *lib_Input) GetInt32LinesFrom(fromIndex int) (newLines [][]int32, err error) {
	for index := range i.lines {
		if index < fromIndex {
			continue
		}
		newLine, err := i.GetInt32Line(index)
		if err != nil {
			return nil, err
		}
		newLines = append(newLines, newLine)
	}
	return
}

func (i *lib_Input) GetInt32LineRange(fromRowIndex, rangeNum int) (newLines [][]int32, err error) {
	cnt := 0
	for index := range i.lines {
		if index < fromRowIndex {
			continue
		}
		newLine, err := i.GetInt32Line(index)
		if err != nil {
			return nil, err
		}
		newLines = append(newLines, newLine)
		cnt++
		if cnt >= rangeNum {
			return newLines, nil
		}
	}
	return
}

func (i *lib_Input) GetInt32Line(index int) ([]int32, error) {
	if err := i.validateRowIndex(index); err != nil {
		return nil, err
	}

	newLine, err := lib_StringSliceToInt32Slice(i.lines[index])
	if err != nil {
		return nil, fmt.Errorf("%dth index: %v", index, err)
	}
	return newLine, nil
}

func (i *lib_Input) GetInt32Value(rowIndex, colIndex int) (int32, error) {
	line, err := i.GetLine(rowIndex)
	if err != nil {
		return 0, err
	}
	if colIndex < 0 || colIndex >= len(line) {
		return 0, fmt.Errorf("Invalid col index: %v ", colIndex)
	}

	v, err := strconv.ParseInt(line[colIndex], 10, 64)
	if err != nil {
		return 0, fmt.Errorf("failed to convert string to int: %v, %v", line[colIndex], err)
	}

	return int32(v), nil
}

func (i *lib_Input) GetFirstInt32Value(rowIndex int) (int32, error) {
	return i.GetInt32Value(rowIndex, 0)
}

func (i *lib_Input) GetColInt32Line(colIndex int) (newLine []int32, err error) {
	strLine, err := i.GetColLine(colIndex)
	if err != nil {
		return nil, err
	}
	newLine, err = lib_StringSliceToInt32Slice(strLine)
	if err != nil {
		return nil, fmt.Errorf("%dth col index: %v", colIndex, err)
	}
	return
}

func (i *lib_Input) GetInt64Lines() (newLines [][]int64, err error) {
	return i.GetInt64LinesFrom(0)
}

func (i *lib_Input) GetInt64LinesFrom(fromIndex int) (newLines [][]int64, err error) {
	for index := range i.lines {
		if index < fromIndex {
			continue
		}
		newLine, err := i.GetInt64Line(index)
		if err != nil {
			return nil, err
		}
		newLines = append(newLines, newLine)
	}
	return
}

func (i *lib_Input) GetInt64LineRange(fromRowIndex, rangeNum int) (newLines [][]int64, err error) {
	cnt := 0
	for index := range i.lines {
		if index < fromRowIndex {
			continue
		}
		newLine, err := i.GetInt64Line(index)
		if err != nil {
			return nil, err
		}
		newLines = append(newLines, newLine)
		cnt++
		if cnt >= rangeNum {
			return newLines, nil
		}
	}
	return
}

func (i *lib_Input) GetInt64Line(index int) ([]int64, error) {
	if err := i.validateRowIndex(index); err != nil {
		return nil, err
	}

	newLine, err := lib_StringSliceToInt64Slice(i.lines[index])
	if err != nil {
		return nil, fmt.Errorf("%dth index: %v", index, err)
	}
	return newLine, nil
}

func (i *lib_Input) GetInt64Value(rowIndex, colIndex int) (int64, error) {
	line, err := i.GetLine(rowIndex)
	if err != nil {
		return 0, err
	}
	if colIndex < 0 || colIndex >= len(line) {
		return 0, fmt.Errorf("Invalid col index: %v ", colIndex)
	}

	v, err := strconv.ParseInt(line[colIndex], 10, 64)
	if err != nil {
		return 0, fmt.Errorf("failed to convert string to int: %v, %v", line[colIndex], err)
	}

	return int64(v), nil
}

func (i *lib_Input) GetFirstInt64Value(rowIndex int) (int64, error) {
	return i.GetInt64Value(rowIndex, 0)
}

func (i *lib_Input) GetColInt64Line(colIndex int) (newLine []int64, err error) {
	strLine, err := i.GetColLine(colIndex)
	if err != nil {
		return nil, err
	}
	newLine, err = lib_StringSliceToInt64Slice(strLine)
	if err != nil {
		return nil, fmt.Errorf("%dth col index: %v", colIndex, err)
	}
	return
}

func (i *lib_Input) GetFloat32Lines() (newLines [][]float32, err error) {
	return i.GetFloat32LinesFrom(0)
}

func (i *lib_Input) GetFloat32LinesFrom(fromIndex int) (newLines [][]float32, err error) {
	for index := range i.lines {
		if index < fromIndex {
			continue
		}
		newLine, err := i.GetFloat32Line(index)
		if err != nil {
			return nil, err
		}
		newLines = append(newLines, newLine)
	}
	return
}

func (i *lib_Input) GetFloat32LineRange(fromRowIndex, rangeNum int) (newLines [][]float32, err error) {
	cnt := 0
	for index := range i.lines {
		if index < fromRowIndex {
			continue
		}
		newLine, err := i.GetFloat32Line(index)
		if err != nil {
			return nil, err
		}
		newLines = append(newLines, newLine)
		cnt++
		if cnt >= rangeNum {
			return newLines, nil
		}
	}
	return
}

func (i *lib_Input) GetFloat32Line(index int) ([]float32, error) {
	if err := i.validateRowIndex(index); err != nil {
		return nil, err
	}

	newLine, err := lib_StringSliceToFloat32Slice(i.lines[index])
	if err != nil {
		return nil, fmt.Errorf("%dth index: %v", index, err)
	}
	return newLine, nil
}

func (i *lib_Input) GetFloat32Value(rowIndex, colIndex int) (float32, error) {
	line, err := i.GetLine(rowIndex)
	if err != nil {
		return 0, err
	}
	if colIndex < 0 || colIndex >= len(line) {
		return 0, fmt.Errorf("Invalid col index: %v ", colIndex)
	}

	v, err := strconv.ParseInt(line[colIndex], 10, 64)
	if err != nil {
		return 0, fmt.Errorf("failed to convert string to int: %v, %v", line[colIndex], err)
	}

	return float32(v), nil
}

func (i *lib_Input) GetFirstFloat32Value(rowIndex int) (float32, error) {
	return i.GetFloat32Value(rowIndex, 0)
}

func (i *lib_Input) GetColFloat32Line(colIndex int) (newLine []float32, err error) {
	strLine, err := i.GetColLine(colIndex)
	if err != nil {
		return nil, err
	}
	newLine, err = lib_StringSliceToFloat32Slice(strLine)
	if err != nil {
		return nil, fmt.Errorf("%dth col index: %v", colIndex, err)
	}
	return
}

func (i *lib_Input) GetFloat64Lines() (newLines [][]float64, err error) {
	return i.GetFloat64LinesFrom(0)
}

func (i *lib_Input) GetFloat64LinesFrom(fromIndex int) (newLines [][]float64, err error) {
	for index := range i.lines {
		if index < fromIndex {
			continue
		}
		newLine, err := i.GetFloat64Line(index)
		if err != nil {
			return nil, err
		}
		newLines = append(newLines, newLine)
	}
	return
}

func (i *lib_Input) GetFloat64LineRange(fromRowIndex, rangeNum int) (newLines [][]float64, err error) {
	cnt := 0
	for index := range i.lines {
		if index < fromRowIndex {
			continue
		}
		newLine, err := i.GetFloat64Line(index)
		if err != nil {
			return nil, err
		}
		newLines = append(newLines, newLine)
		cnt++
		if cnt >= rangeNum {
			return newLines, nil
		}
	}
	return
}

func (i *lib_Input) GetFloat64Line(index int) ([]float64, error) {
	if err := i.validateRowIndex(index); err != nil {
		return nil, err
	}

	newLine, err := lib_StringSliceToFloat64Slice(i.lines[index])
	if err != nil {
		return nil, fmt.Errorf("%dth index: %v", index, err)
	}
	return newLine, nil
}

func (i *lib_Input) GetFloat64Value(rowIndex, colIndex int) (float64, error) {
	line, err := i.GetLine(rowIndex)
	if err != nil {
		return 0, err
	}
	if colIndex < 0 || colIndex >= len(line) {
		return 0, fmt.Errorf("Invalid col index: %v ", colIndex)
	}

	v, err := strconv.ParseInt(line[colIndex], 10, 64)
	if err != nil {
		return 0, fmt.Errorf("failed to convert string to int: %v, %v", line[colIndex], err)
	}

	return float64(v), nil
}

func (i *lib_Input) GetFirstFloat64Value(rowIndex int) (float64, error) {
	return i.GetFloat64Value(rowIndex, 0)
}

func (i *lib_Input) GetColFloat64Line(colIndex int) (newLine []float64, err error) {
	strLine, err := i.GetColLine(colIndex)
	if err != nil {
		return nil, err
	}
	newLine, err = lib_StringSliceToFloat64Slice(strLine)
	if err != nil {
		return nil, fmt.Errorf("%dth col index: %v", colIndex, err)
	}
	return
}

func lib_IntToBits(value int, minDigits int) (bits []bool) {
	bin := fmt.Sprintf("%b", int(value))
	digits := 0
	for _, b := range bin {
		digits++
		if b == '0' {
			bits = append(bits, false)
		} else if b == '1' {
			bits = append(bits, true)
		} else {
			panic("invalid bit:" + string(b) + ", " + string('0'))
		}
	}

	for minDigits > digits {
		bits = append([]bool{false}, bits...)
		digits++
	}

	return
}

func lib_Int8ToBits(value int8, minDigits int) (bits []bool) {
	bin := fmt.Sprintf("%b", int(value))
	digits := 0
	for _, b := range bin {
		digits++
		if b == '0' {
			bits = append(bits, false)
		} else if b == '1' {
			bits = append(bits, true)
		} else {
			panic("invalid bit:" + string(b) + ", " + string('0'))
		}
	}

	for minDigits > digits {
		bits = append([]bool{false}, bits...)
		digits++
	}

	return
}

func lib_Int16ToBits(value int16, minDigits int) (bits []bool) {
	bin := fmt.Sprintf("%b", int(value))
	digits := 0
	for _, b := range bin {
		digits++
		if b == '0' {
			bits = append(bits, false)
		} else if b == '1' {
			bits = append(bits, true)
		} else {
			panic("invalid bit:" + string(b) + ", " + string('0'))
		}
	}

	for minDigits > digits {
		bits = append([]bool{false}, bits...)
		digits++
	}

	return
}

func lib_Int32ToBits(value int32, minDigits int) (bits []bool) {
	bin := fmt.Sprintf("%b", int(value))
	digits := 0
	for _, b := range bin {
		digits++
		if b == '0' {
			bits = append(bits, false)
		} else if b == '1' {
			bits = append(bits, true)
		} else {
			panic("invalid bit:" + string(b) + ", " + string('0'))
		}
	}

	for minDigits > digits {
		bits = append([]bool{false}, bits...)
		digits++
	}

	return
}

func lib_Int64ToBits(value int64, minDigits int) (bits []bool) {
	bin := fmt.Sprintf("%b", int(value))
	digits := 0
	for _, b := range bin {
		digits++
		if b == '0' {
			bits = append(bits, false)
		} else if b == '1' {
			bits = append(bits, true)
		} else {
			panic("invalid bit:" + string(b) + ", " + string('0'))
		}
	}

	for minDigits > digits {
		bits = append([]bool{false}, bits...)
		digits++
	}

	return
}

func lib_GetEachDigitSumInt(n int) (sum int) {
	for _, digit := range lib_ToDigitSliceInt(n) {
		sum += int(digit)
	}
	return
}

func lib_ToDigitSliceInt(n int) (digits []int8) {
	nn := int64(n)
	for {
		if nn <= 0 {
			return lib_ReverseInt8(digits)
		}
		digit := int8(nn % 10) // FIXME
		digits = append(digits, digit)
		nn /= 10
	}
}

func lib_DigitsToInt(digits []int8) int {
	v := int(0)
	for i, digit := range digits {
		v += int(float64(digit) * math.Pow(10, float64(len(digits)-i-1)))
	}
	return v
}

func lib_GetEachDigitSumInt8(n int8) (sum int8) {
	for _, digit := range lib_ToDigitSliceInt8(n) {
		sum += int8(digit)
	}
	return
}

func lib_ToDigitSliceInt8(n int8) (digits []int8) {
	nn := int64(n)
	for {
		if nn <= 0 {
			return lib_ReverseInt8(digits)
		}
		digit := int8(nn % 10) // FIXME
		digits = append(digits, digit)
		nn /= 10
	}
}

func lib_DigitsToInt8(digits []int8) int8 {
	v := int8(0)
	for i, digit := range digits {
		v += int8(float64(digit) * math.Pow(10, float64(len(digits)-i-1)))
	}
	return v
}

func lib_GetEachDigitSumInt16(n int16) (sum int16) {
	for _, digit := range lib_ToDigitSliceInt16(n) {
		sum += int16(digit)
	}
	return
}

func lib_ToDigitSliceInt16(n int16) (digits []int8) {
	nn := int64(n)
	for {
		if nn <= 0 {
			return lib_ReverseInt8(digits)
		}
		digit := int8(nn % 10) // FIXME
		digits = append(digits, digit)
		nn /= 10
	}
}

func lib_DigitsToInt16(digits []int8) int16 {
	v := int16(0)
	for i, digit := range digits {
		v += int16(float64(digit) * math.Pow(10, float64(len(digits)-i-1)))
	}
	return v
}

func lib_GetEachDigitSumInt32(n int32) (sum int32) {
	for _, digit := range lib_ToDigitSliceInt32(n) {
		sum += int32(digit)
	}
	return
}

func lib_ToDigitSliceInt32(n int32) (digits []int8) {
	nn := int64(n)
	for {
		if nn <= 0 {
			return lib_ReverseInt8(digits)
		}
		digit := int8(nn % 10) // FIXME
		digits = append(digits, digit)
		nn /= 10
	}
}

func lib_DigitsToInt32(digits []int8) int32 {
	v := int32(0)
	for i, digit := range digits {
		v += int32(float64(digit) * math.Pow(10, float64(len(digits)-i-1)))
	}
	return v
}

func lib_GetEachDigitSumInt64(n int64) (sum int64) {
	for _, digit := range lib_ToDigitSliceInt64(n) {
		sum += int64(digit)
	}
	return
}

func lib_ToDigitSliceInt64(n int64) (digits []int8) {
	nn := int64(n)
	for {
		if nn <= 0 {
			return lib_ReverseInt8(digits)
		}
		digit := int8(nn % 10) // FIXME
		digits = append(digits, digit)
		nn /= 10
	}
}

func lib_DigitsToInt64(digits []int8) int64 {
	v := int64(0)
	for i, digit := range digits {
		v += int64(float64(digit) * math.Pow(10, float64(len(digits)-i-1)))
	}
	return v
}

func lib_GetEachDigitSumFloat32(n float32) (sum float32) {
	for _, digit := range lib_ToDigitSliceFloat32(n) {
		sum += float32(digit)
	}
	return
}

func lib_ToDigitSliceFloat32(n float32) (digits []int8) {
	nn := int64(n)
	for {
		if nn <= 0 {
			return lib_ReverseInt8(digits)
		}
		digit := int8(nn % 10) // FIXME
		digits = append(digits, digit)
		nn /= 10
	}
}

func lib_DigitsToFloat32(digits []int8) float32 {
	v := float32(0)
	for i, digit := range digits {
		v += float32(float64(digit) * math.Pow(10, float64(len(digits)-i-1)))
	}
	return v
}

func lib_GetEachDigitSumFloat64(n float64) (sum float64) {
	for _, digit := range lib_ToDigitSliceFloat64(n) {
		sum += float64(digit)
	}
	return
}

func lib_ToDigitSliceFloat64(n float64) (digits []int8) {
	nn := int64(n)
	for {
		if nn <= 0 {
			return lib_ReverseInt8(digits)
		}
		digit := int8(nn % 10) // FIXME
		digits = append(digits, digit)
		nn /= 10
	}
}

func lib_DigitsToFloat64(digits []int8) float64 {
	v := float64(0)
	for i, digit := range digits {
		v += float64(float64(digit) * math.Pow(10, float64(len(digits)-i-1)))
	}
	return v
}

func lib_SumInt(values []int) int {
	var sum int = 0
	for _, value := range values {
		sum += value
	}
	return sum
}

func lib_FilterInt(values []int, f func(v int) bool) (newValues []int) {
	for _, value := range values {
		if f(value) {
			newValues = append(newValues, value)
		}
	}
	return
}

func lib_FilterIntSlice(values [][]int, f func(v []int) bool) (newValues [][]int) {
	for _, value := range values {
		if f(value) {
			newValues = append(newValues, value)
		}
	}
	return
}

func lib_UniqInt(values []int) (newValues []int) {
	m := map[int]bool{}
	for _, value := range values {
		m[value] = true
	}

	for key := range m {
		newValues = append(newValues, key)
	}
	return
}

func lib_SubtractIntBy(values1 []int, values2 []int, f func(v int) int) (newValues []int, err error) {
	if len(values1) != len(values2) {
		return nil, errors.New("two values lengths are different")
	}

	for i := 0; i < len(values1); i++ {
		fValue1 := f(values1[i])
		fValue2 := f(values2[i])
		newValues = append(newValues, fValue1-fValue2)
	}
	return newValues, nil
}

func lib_SubtractInt(values1 []int, values2 []int) (newValues []int, err error) {
	return lib_SubtractIntBy(values1, values2, func(v int) int {
		return v
	})
}

func lib_RDiffIntBy(values []int, f func(v int) int) (newValues []int, err error) {
	diffValues := append([]int{0}, values...)
	newValues, err = lib_SubtractIntBy(values, diffValues[:len(diffValues)-1], f)
	if err != nil {
		return nil, fmt.Errorf("failed to RDiff: %v", err)
	}
	return newValues[1:], nil
}

func lib_RDiffInt(values []int) (newValues []int, err error) {
	return lib_RDiffIntBy(values, func(v int) int {
		return v
	})
}

func lib_StringToIntSlice(s string) (ValueLine []int, err error) {
	for _, r := range s {
		v, err := strconv.ParseInt(string(r), 10, 64)
		if err != nil {
			return nil, err
		}
		ValueLine = append(ValueLine, int(v))
	}
	return
}

func lib_StringSliceToIntSlice(line []string) (ValueLine []int, err error) {
	newLine, err := lib_toSpecificBitIntLine(line, 64)
	if err != nil {
		return nil, err
	}
	for _, v := range newLine {
		ValueLine = append(ValueLine, int(v))
	}
	return
}

func lib_MaxInt(values []int) (max int, err error) {
	if len(values) == 0 {
		return 0, errors.New("empty slice is given")
	}

	max = values[0]
	for _, value := range values {
		if max < value {
			max = value
		}
	}
	return
}

func lib_MaxIntVA(values ...int) (max int, err error) {
	if len(values) == 0 {
		return 0, errors.New("empty slice is given")
	}

	max = values[0]
	for _, value := range values {
		if max < value {
			max = value
		}
	}
	return
}

func lib_MinInt(values []int) (min int, err error) {
	if len(values) == 0 {
		return 0, errors.New("empty slice is given")
	}

	min = values[0]
	for _, value := range values {
		if min > value {
			min = value
		}
	}
	return
}

func lib_NewIntGridMap(grid [][]string, defaultValue int) (m [][]int) {
	for _, line := range grid {
		var newLine []int
		for range line {
			newLine = append(newLine, defaultValue)
		}
		m = append(m, newLine)
	}
	return
}

func lib_IntRange(start, end, step int) []int {
	if end < start {
		return []int{}
	}
	s := make([]int, 0, int(1+(end-start)/step))
	for start < end {
		s = append(s, start)
		start += step
	}
	return s
}

func lib_SumInt8(values []int8) int8 {
	var sum int8 = 0
	for _, value := range values {
		sum += value
	}
	return sum
}

func lib_FilterInt8(values []int8, f func(v int8) bool) (newValues []int8) {
	for _, value := range values {
		if f(value) {
			newValues = append(newValues, value)
		}
	}
	return
}

func lib_FilterInt8Slice(values [][]int8, f func(v []int8) bool) (newValues [][]int8) {
	for _, value := range values {
		if f(value) {
			newValues = append(newValues, value)
		}
	}
	return
}

func lib_UniqInt8(values []int8) (newValues []int8) {
	m := map[int8]bool{}
	for _, value := range values {
		m[value] = true
	}

	for key := range m {
		newValues = append(newValues, key)
	}
	return
}

func lib_SubtractInt8By(values1 []int8, values2 []int8, f func(v int8) int8) (newValues []int8, err error) {
	if len(values1) != len(values2) {
		return nil, errors.New("two values lengths are different")
	}

	for i := 0; i < len(values1); i++ {
		fValue1 := f(values1[i])
		fValue2 := f(values2[i])
		newValues = append(newValues, fValue1-fValue2)
	}
	return newValues, nil
}

func lib_SubtractInt8(values1 []int8, values2 []int8) (newValues []int8, err error) {
	return lib_SubtractInt8By(values1, values2, func(v int8) int8 {
		return v
	})
}

func lib_RDiffInt8By(values []int8, f func(v int8) int8) (newValues []int8, err error) {
	diffValues := append([]int8{0}, values...)
	newValues, err = lib_SubtractInt8By(values, diffValues[:len(diffValues)-1], f)
	if err != nil {
		return nil, fmt.Errorf("failed to RDiff: %v", err)
	}
	return newValues[1:], nil
}

func lib_RDiffInt8(values []int8) (newValues []int8, err error) {
	return lib_RDiffInt8By(values, func(v int8) int8 {
		return v
	})
}

func lib_StringToInt8Slice(s string) (ValueLine []int8, err error) {
	for _, r := range s {
		v, err := strconv.ParseInt(string(r), 10, 64)
		if err != nil {
			return nil, err
		}
		ValueLine = append(ValueLine, int8(v))
	}
	return
}

func lib_StringSliceToInt8Slice(line []string) (ValueLine []int8, err error) {
	newLine, err := lib_toSpecificBitIntLine(line, 64)
	if err != nil {
		return nil, err
	}
	for _, v := range newLine {
		ValueLine = append(ValueLine, int8(v))
	}
	return
}

func lib_MaxInt8(values []int8) (max int8, err error) {
	if len(values) == 0 {
		return 0, errors.New("empty slice is given")
	}

	max = values[0]
	for _, value := range values {
		if max < value {
			max = value
		}
	}
	return
}

func lib_MaxInt8VA(values ...int8) (max int8, err error) {
	if len(values) == 0 {
		return 0, errors.New("empty slice is given")
	}

	max = values[0]
	for _, value := range values {
		if max < value {
			max = value
		}
	}
	return
}

func lib_MinInt8(values []int8) (min int8, err error) {
	if len(values) == 0 {
		return 0, errors.New("empty slice is given")
	}

	min = values[0]
	for _, value := range values {
		if min > value {
			min = value
		}
	}
	return
}

func lib_NewInt8GridMap(grid [][]string, defaultValue int8) (m [][]int8) {
	for _, line := range grid {
		var newLine []int8
		for range line {
			newLine = append(newLine, defaultValue)
		}
		m = append(m, newLine)
	}
	return
}

func lib_Int8Range(start, end, step int8) []int8 {
	if end < start {
		return []int8{}
	}
	s := make([]int8, 0, int(1+(end-start)/step))
	for start < end {
		s = append(s, start)
		start += step
	}
	return s
}

func lib_SumInt16(values []int16) int16 {
	var sum int16 = 0
	for _, value := range values {
		sum += value
	}
	return sum
}

func lib_FilterInt16(values []int16, f func(v int16) bool) (newValues []int16) {
	for _, value := range values {
		if f(value) {
			newValues = append(newValues, value)
		}
	}
	return
}

func lib_FilterInt16Slice(values [][]int16, f func(v []int16) bool) (newValues [][]int16) {
	for _, value := range values {
		if f(value) {
			newValues = append(newValues, value)
		}
	}
	return
}

func lib_UniqInt16(values []int16) (newValues []int16) {
	m := map[int16]bool{}
	for _, value := range values {
		m[value] = true
	}

	for key := range m {
		newValues = append(newValues, key)
	}
	return
}

func lib_SubtractInt16By(values1 []int16, values2 []int16, f func(v int16) int16) (newValues []int16, err error) {
	if len(values1) != len(values2) {
		return nil, errors.New("two values lengths are different")
	}

	for i := 0; i < len(values1); i++ {
		fValue1 := f(values1[i])
		fValue2 := f(values2[i])
		newValues = append(newValues, fValue1-fValue2)
	}
	return newValues, nil
}

func lib_SubtractInt16(values1 []int16, values2 []int16) (newValues []int16, err error) {
	return lib_SubtractInt16By(values1, values2, func(v int16) int16 {
		return v
	})
}

func lib_RDiffInt16By(values []int16, f func(v int16) int16) (newValues []int16, err error) {
	diffValues := append([]int16{0}, values...)
	newValues, err = lib_SubtractInt16By(values, diffValues[:len(diffValues)-1], f)
	if err != nil {
		return nil, fmt.Errorf("failed to RDiff: %v", err)
	}
	return newValues[1:], nil
}

func lib_RDiffInt16(values []int16) (newValues []int16, err error) {
	return lib_RDiffInt16By(values, func(v int16) int16 {
		return v
	})
}

func lib_StringToInt16Slice(s string) (ValueLine []int16, err error) {
	for _, r := range s {
		v, err := strconv.ParseInt(string(r), 10, 64)
		if err != nil {
			return nil, err
		}
		ValueLine = append(ValueLine, int16(v))
	}
	return
}

func lib_StringSliceToInt16Slice(line []string) (ValueLine []int16, err error) {
	newLine, err := lib_toSpecificBitIntLine(line, 64)
	if err != nil {
		return nil, err
	}
	for _, v := range newLine {
		ValueLine = append(ValueLine, int16(v))
	}
	return
}

func lib_MaxInt16(values []int16) (max int16, err error) {
	if len(values) == 0 {
		return 0, errors.New("empty slice is given")
	}

	max = values[0]
	for _, value := range values {
		if max < value {
			max = value
		}
	}
	return
}

func lib_MaxInt16VA(values ...int16) (max int16, err error) {
	if len(values) == 0 {
		return 0, errors.New("empty slice is given")
	}

	max = values[0]
	for _, value := range values {
		if max < value {
			max = value
		}
	}
	return
}

func lib_MinInt16(values []int16) (min int16, err error) {
	if len(values) == 0 {
		return 0, errors.New("empty slice is given")
	}

	min = values[0]
	for _, value := range values {
		if min > value {
			min = value
		}
	}
	return
}

func lib_NewInt16GridMap(grid [][]string, defaultValue int16) (m [][]int16) {
	for _, line := range grid {
		var newLine []int16
		for range line {
			newLine = append(newLine, defaultValue)
		}
		m = append(m, newLine)
	}
	return
}

func lib_Int16Range(start, end, step int16) []int16 {
	if end < start {
		return []int16{}
	}
	s := make([]int16, 0, int(1+(end-start)/step))
	for start < end {
		s = append(s, start)
		start += step
	}
	return s
}

func lib_SumInt32(values []int32) int32 {
	var sum int32 = 0
	for _, value := range values {
		sum += value
	}
	return sum
}

func lib_FilterInt32(values []int32, f func(v int32) bool) (newValues []int32) {
	for _, value := range values {
		if f(value) {
			newValues = append(newValues, value)
		}
	}
	return
}

func lib_FilterInt32Slice(values [][]int32, f func(v []int32) bool) (newValues [][]int32) {
	for _, value := range values {
		if f(value) {
			newValues = append(newValues, value)
		}
	}
	return
}

func lib_UniqInt32(values []int32) (newValues []int32) {
	m := map[int32]bool{}
	for _, value := range values {
		m[value] = true
	}

	for key := range m {
		newValues = append(newValues, key)
	}
	return
}

func lib_SubtractInt32By(values1 []int32, values2 []int32, f func(v int32) int32) (newValues []int32, err error) {
	if len(values1) != len(values2) {
		return nil, errors.New("two values lengths are different")
	}

	for i := 0; i < len(values1); i++ {
		fValue1 := f(values1[i])
		fValue2 := f(values2[i])
		newValues = append(newValues, fValue1-fValue2)
	}
	return newValues, nil
}

func lib_SubtractInt32(values1 []int32, values2 []int32) (newValues []int32, err error) {
	return lib_SubtractInt32By(values1, values2, func(v int32) int32 {
		return v
	})
}

func lib_RDiffInt32By(values []int32, f func(v int32) int32) (newValues []int32, err error) {
	diffValues := append([]int32{0}, values...)
	newValues, err = lib_SubtractInt32By(values, diffValues[:len(diffValues)-1], f)
	if err != nil {
		return nil, fmt.Errorf("failed to RDiff: %v", err)
	}
	return newValues[1:], nil
}

func lib_RDiffInt32(values []int32) (newValues []int32, err error) {
	return lib_RDiffInt32By(values, func(v int32) int32 {
		return v
	})
}

func lib_StringToInt32Slice(s string) (ValueLine []int32, err error) {
	for _, r := range s {
		v, err := strconv.ParseInt(string(r), 10, 64)
		if err != nil {
			return nil, err
		}
		ValueLine = append(ValueLine, int32(v))
	}
	return
}

func lib_StringSliceToInt32Slice(line []string) (ValueLine []int32, err error) {
	newLine, err := lib_toSpecificBitIntLine(line, 64)
	if err != nil {
		return nil, err
	}
	for _, v := range newLine {
		ValueLine = append(ValueLine, int32(v))
	}
	return
}

func lib_MaxInt32(values []int32) (max int32, err error) {
	if len(values) == 0 {
		return 0, errors.New("empty slice is given")
	}

	max = values[0]
	for _, value := range values {
		if max < value {
			max = value
		}
	}
	return
}

func lib_MaxInt32VA(values ...int32) (max int32, err error) {
	if len(values) == 0 {
		return 0, errors.New("empty slice is given")
	}

	max = values[0]
	for _, value := range values {
		if max < value {
			max = value
		}
	}
	return
}

func lib_MinInt32(values []int32) (min int32, err error) {
	if len(values) == 0 {
		return 0, errors.New("empty slice is given")
	}

	min = values[0]
	for _, value := range values {
		if min > value {
			min = value
		}
	}
	return
}

func lib_NewInt32GridMap(grid [][]string, defaultValue int32) (m [][]int32) {
	for _, line := range grid {
		var newLine []int32
		for range line {
			newLine = append(newLine, defaultValue)
		}
		m = append(m, newLine)
	}
	return
}

func lib_Int32Range(start, end, step int32) []int32 {
	if end < start {
		return []int32{}
	}
	s := make([]int32, 0, int(1+(end-start)/step))
	for start < end {
		s = append(s, start)
		start += step
	}
	return s
}

func lib_SumInt64(values []int64) int64 {
	var sum int64 = 0
	for _, value := range values {
		sum += value
	}
	return sum
}

func lib_FilterInt64(values []int64, f func(v int64) bool) (newValues []int64) {
	for _, value := range values {
		if f(value) {
			newValues = append(newValues, value)
		}
	}
	return
}

func lib_FilterInt64Slice(values [][]int64, f func(v []int64) bool) (newValues [][]int64) {
	for _, value := range values {
		if f(value) {
			newValues = append(newValues, value)
		}
	}
	return
}

func lib_UniqInt64(values []int64) (newValues []int64) {
	m := map[int64]bool{}
	for _, value := range values {
		m[value] = true
	}

	for key := range m {
		newValues = append(newValues, key)
	}
	return
}

func lib_SubtractInt64By(values1 []int64, values2 []int64, f func(v int64) int64) (newValues []int64, err error) {
	if len(values1) != len(values2) {
		return nil, errors.New("two values lengths are different")
	}

	for i := 0; i < len(values1); i++ {
		fValue1 := f(values1[i])
		fValue2 := f(values2[i])
		newValues = append(newValues, fValue1-fValue2)
	}
	return newValues, nil
}

func lib_SubtractInt64(values1 []int64, values2 []int64) (newValues []int64, err error) {
	return lib_SubtractInt64By(values1, values2, func(v int64) int64 {
		return v
	})
}

func lib_RDiffInt64By(values []int64, f func(v int64) int64) (newValues []int64, err error) {
	diffValues := append([]int64{0}, values...)
	newValues, err = lib_SubtractInt64By(values, diffValues[:len(diffValues)-1], f)
	if err != nil {
		return nil, fmt.Errorf("failed to RDiff: %v", err)
	}
	return newValues[1:], nil
}

func lib_RDiffInt64(values []int64) (newValues []int64, err error) {
	return lib_RDiffInt64By(values, func(v int64) int64 {
		return v
	})
}

func lib_StringToInt64Slice(s string) (ValueLine []int64, err error) {
	for _, r := range s {
		v, err := strconv.ParseInt(string(r), 10, 64)
		if err != nil {
			return nil, err
		}
		ValueLine = append(ValueLine, int64(v))
	}
	return
}

func lib_StringSliceToInt64Slice(line []string) (ValueLine []int64, err error) {
	newLine, err := lib_toSpecificBitIntLine(line, 64)
	if err != nil {
		return nil, err
	}
	for _, v := range newLine {
		ValueLine = append(ValueLine, int64(v))
	}
	return
}

func lib_MaxInt64(values []int64) (max int64, err error) {
	if len(values) == 0 {
		return 0, errors.New("empty slice is given")
	}

	max = values[0]
	for _, value := range values {
		if max < value {
			max = value
		}
	}
	return
}

func lib_MaxInt64VA(values ...int64) (max int64, err error) {
	if len(values) == 0 {
		return 0, errors.New("empty slice is given")
	}

	max = values[0]
	for _, value := range values {
		if max < value {
			max = value
		}
	}
	return
}

func lib_MinInt64(values []int64) (min int64, err error) {
	if len(values) == 0 {
		return 0, errors.New("empty slice is given")
	}

	min = values[0]
	for _, value := range values {
		if min > value {
			min = value
		}
	}
	return
}

func lib_NewInt64GridMap(grid [][]string, defaultValue int64) (m [][]int64) {
	for _, line := range grid {
		var newLine []int64
		for range line {
			newLine = append(newLine, defaultValue)
		}
		m = append(m, newLine)
	}
	return
}

func lib_Int64Range(start, end, step int64) []int64 {
	if end < start {
		return []int64{}
	}
	s := make([]int64, 0, int(1+(end-start)/step))
	for start < end {
		s = append(s, start)
		start += step
	}
	return s
}

func lib_SumFloat32(values []float32) float32 {
	var sum float32 = 0
	for _, value := range values {
		sum += value
	}
	return sum
}

func lib_FilterFloat32(values []float32, f func(v float32) bool) (newValues []float32) {
	for _, value := range values {
		if f(value) {
			newValues = append(newValues, value)
		}
	}
	return
}

func lib_FilterFloat32Slice(values [][]float32, f func(v []float32) bool) (newValues [][]float32) {
	for _, value := range values {
		if f(value) {
			newValues = append(newValues, value)
		}
	}
	return
}

func lib_UniqFloat32(values []float32) (newValues []float32) {
	m := map[float32]bool{}
	for _, value := range values {
		m[value] = true
	}

	for key := range m {
		newValues = append(newValues, key)
	}
	return
}

func lib_SubtractFloat32By(values1 []float32, values2 []float32, f func(v float32) float32) (newValues []float32, err error) {
	if len(values1) != len(values2) {
		return nil, errors.New("two values lengths are different")
	}

	for i := 0; i < len(values1); i++ {
		fValue1 := f(values1[i])
		fValue2 := f(values2[i])
		newValues = append(newValues, fValue1-fValue2)
	}
	return newValues, nil
}

func lib_SubtractFloat32(values1 []float32, values2 []float32) (newValues []float32, err error) {
	return lib_SubtractFloat32By(values1, values2, func(v float32) float32 {
		return v
	})
}

func lib_RDiffFloat32By(values []float32, f func(v float32) float32) (newValues []float32, err error) {
	diffValues := append([]float32{0}, values...)
	newValues, err = lib_SubtractFloat32By(values, diffValues[:len(diffValues)-1], f)
	if err != nil {
		return nil, fmt.Errorf("failed to RDiff: %v", err)
	}
	return newValues[1:], nil
}

func lib_RDiffFloat32(values []float32) (newValues []float32, err error) {
	return lib_RDiffFloat32By(values, func(v float32) float32 {
		return v
	})
}

func lib_StringToFloat32Slice(s string) (ValueLine []float32, err error) {
	for _, r := range s {
		v, err := strconv.ParseInt(string(r), 10, 64)
		if err != nil {
			return nil, err
		}
		ValueLine = append(ValueLine, float32(v))
	}
	return
}

func lib_StringSliceToFloat32Slice(line []string) (ValueLine []float32, err error) {
	newLine, err := lib_toSpecificBitIntLine(line, 64)
	if err != nil {
		return nil, err
	}
	for _, v := range newLine {
		ValueLine = append(ValueLine, float32(v))
	}
	return
}

func lib_MaxFloat32(values []float32) (max float32, err error) {
	if len(values) == 0 {
		return 0, errors.New("empty slice is given")
	}

	max = values[0]
	for _, value := range values {
		if max < value {
			max = value
		}
	}
	return
}

func lib_MaxFloat32VA(values ...float32) (max float32, err error) {
	if len(values) == 0 {
		return 0, errors.New("empty slice is given")
	}

	max = values[0]
	for _, value := range values {
		if max < value {
			max = value
		}
	}
	return
}

func lib_MinFloat32(values []float32) (min float32, err error) {
	if len(values) == 0 {
		return 0, errors.New("empty slice is given")
	}

	min = values[0]
	for _, value := range values {
		if min > value {
			min = value
		}
	}
	return
}

func lib_NewFloat32GridMap(grid [][]string, defaultValue float32) (m [][]float32) {
	for _, line := range grid {
		var newLine []float32
		for range line {
			newLine = append(newLine, defaultValue)
		}
		m = append(m, newLine)
	}
	return
}

func lib_Float32Range(start, end, step float32) []float32 {
	if end < start {
		return []float32{}
	}
	s := make([]float32, 0, int(1+(end-start)/step))
	for start < end {
		s = append(s, start)
		start += step
	}
	return s
}

func lib_SumFloat64(values []float64) float64 {
	var sum float64 = 0
	for _, value := range values {
		sum += value
	}
	return sum
}

func lib_FilterFloat64(values []float64, f func(v float64) bool) (newValues []float64) {
	for _, value := range values {
		if f(value) {
			newValues = append(newValues, value)
		}
	}
	return
}

func lib_FilterFloat64Slice(values [][]float64, f func(v []float64) bool) (newValues [][]float64) {
	for _, value := range values {
		if f(value) {
			newValues = append(newValues, value)
		}
	}
	return
}

func lib_UniqFloat64(values []float64) (newValues []float64) {
	m := map[float64]bool{}
	for _, value := range values {
		m[value] = true
	}

	for key := range m {
		newValues = append(newValues, key)
	}
	return
}

func lib_SubtractFloat64By(values1 []float64, values2 []float64, f func(v float64) float64) (newValues []float64, err error) {
	if len(values1) != len(values2) {
		return nil, errors.New("two values lengths are different")
	}

	for i := 0; i < len(values1); i++ {
		fValue1 := f(values1[i])
		fValue2 := f(values2[i])
		newValues = append(newValues, fValue1-fValue2)
	}
	return newValues, nil
}

func lib_SubtractFloat64(values1 []float64, values2 []float64) (newValues []float64, err error) {
	return lib_SubtractFloat64By(values1, values2, func(v float64) float64 {
		return v
	})
}

func lib_RDiffFloat64By(values []float64, f func(v float64) float64) (newValues []float64, err error) {
	diffValues := append([]float64{0}, values...)
	newValues, err = lib_SubtractFloat64By(values, diffValues[:len(diffValues)-1], f)
	if err != nil {
		return nil, fmt.Errorf("failed to RDiff: %v", err)
	}
	return newValues[1:], nil
}

func lib_RDiffFloat64(values []float64) (newValues []float64, err error) {
	return lib_RDiffFloat64By(values, func(v float64) float64 {
		return v
	})
}

func lib_StringToFloat64Slice(s string) (ValueLine []float64, err error) {
	for _, r := range s {
		v, err := strconv.ParseInt(string(r), 10, 64)
		if err != nil {
			return nil, err
		}
		ValueLine = append(ValueLine, float64(v))
	}
	return
}

func lib_StringSliceToFloat64Slice(line []string) (ValueLine []float64, err error) {
	newLine, err := lib_toSpecificBitIntLine(line, 64)
	if err != nil {
		return nil, err
	}
	for _, v := range newLine {
		ValueLine = append(ValueLine, float64(v))
	}
	return
}

func lib_MaxFloat64(values []float64) (max float64, err error) {
	if len(values) == 0 {
		return 0, errors.New("empty slice is given")
	}

	max = values[0]
	for _, value := range values {
		if max < value {
			max = value
		}
	}
	return
}

func lib_MaxFloat64VA(values ...float64) (max float64, err error) {
	if len(values) == 0 {
		return 0, errors.New("empty slice is given")
	}

	max = values[0]
	for _, value := range values {
		if max < value {
			max = value
		}
	}
	return
}

func lib_MinFloat64(values []float64) (min float64, err error) {
	if len(values) == 0 {
		return 0, errors.New("empty slice is given")
	}

	min = values[0]
	for _, value := range values {
		if min > value {
			min = value
		}
	}
	return
}

func lib_NewFloat64GridMap(grid [][]string, defaultValue float64) (m [][]float64) {
	for _, line := range grid {
		var newLine []float64
		for range line {
			newLine = append(newLine, defaultValue)
		}
		m = append(m, newLine)
	}
	return
}

func lib_Float64Range(start, end, step float64) []float64 {
	if end < start {
		return []float64{}
	}
	s := make([]float64, 0, int(1+(end-start)/step))
	for start < end {
		s = append(s, start)
		start += step
	}
	return s
}

type lib_Int3ToIntCache map[int]map[int]map[int]int

func (c lib_Int3ToIntCache) Has(k1, k2, k3 int) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Int3ToIntCache) Get(k1, k2, k3 int) (int, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Int3ToIntCache) Set(k1, k2, k3 int, v int) int {
	if _, ok := c[k1]; !ok {
		c[k1] = map[int]map[int]int{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[int]int{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumIntByInt(values []int, f func(v int) int) int {
	var sum int = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_IntSliceToIntSlice(values []int) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, int(value))
	}
	return
}

func lib_MapIntSliceToInt(values [][]int, f func(v []int) int) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapIntSlice2ToInt(values [][][]int, f func(v [][]int) int) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxIntByIntSlice(values [][]int, f func(vs []int) int) (max int, err error) {
	return lib_MaxInt(lib_MapIntSliceToInt(values, f))
}

func lib_MaxIntByIntSlice2(values [][][]int, f func(vs [][]int) int) (max int, err error) {
	return lib_MaxInt(lib_MapIntSlice2ToInt(values, f))
}

type lib_Int83ToIntCache map[int8]map[int8]map[int8]int

func (c lib_Int83ToIntCache) Has(k1, k2, k3 int8) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Int83ToIntCache) Get(k1, k2, k3 int8) (int, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Int83ToIntCache) Set(k1, k2, k3 int8, v int) int {
	if _, ok := c[k1]; !ok {
		c[k1] = map[int8]map[int8]int{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[int8]int{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumIntByInt8(values []int, f func(v int) int8) int8 {
	var sum int8 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_IntSliceToInt8Slice(values []int) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, int8(value))
	}
	return
}

func lib_MapInt8SliceToInt(values [][]int8, f func(v []int8) int) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt8Slice2ToInt(values [][][]int8, f func(v [][]int8) int) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxIntByInt8Slice(values [][]int8, f func(vs []int8) int) (max int, err error) {
	return lib_MaxInt(lib_MapInt8SliceToInt(values, f))
}

func lib_MaxIntByInt8Slice2(values [][][]int8, f func(vs [][]int8) int) (max int, err error) {
	return lib_MaxInt(lib_MapInt8Slice2ToInt(values, f))
}

type lib_Int163ToIntCache map[int16]map[int16]map[int16]int

func (c lib_Int163ToIntCache) Has(k1, k2, k3 int16) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Int163ToIntCache) Get(k1, k2, k3 int16) (int, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Int163ToIntCache) Set(k1, k2, k3 int16, v int) int {
	if _, ok := c[k1]; !ok {
		c[k1] = map[int16]map[int16]int{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[int16]int{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumIntByInt16(values []int, f func(v int) int16) int16 {
	var sum int16 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_IntSliceToInt16Slice(values []int) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, int16(value))
	}
	return
}

func lib_MapInt16SliceToInt(values [][]int16, f func(v []int16) int) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt16Slice2ToInt(values [][][]int16, f func(v [][]int16) int) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxIntByInt16Slice(values [][]int16, f func(vs []int16) int) (max int, err error) {
	return lib_MaxInt(lib_MapInt16SliceToInt(values, f))
}

func lib_MaxIntByInt16Slice2(values [][][]int16, f func(vs [][]int16) int) (max int, err error) {
	return lib_MaxInt(lib_MapInt16Slice2ToInt(values, f))
}

type lib_Int323ToIntCache map[int32]map[int32]map[int32]int

func (c lib_Int323ToIntCache) Has(k1, k2, k3 int32) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Int323ToIntCache) Get(k1, k2, k3 int32) (int, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Int323ToIntCache) Set(k1, k2, k3 int32, v int) int {
	if _, ok := c[k1]; !ok {
		c[k1] = map[int32]map[int32]int{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[int32]int{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumIntByInt32(values []int, f func(v int) int32) int32 {
	var sum int32 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_IntSliceToInt32Slice(values []int) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, int32(value))
	}
	return
}

func lib_MapInt32SliceToInt(values [][]int32, f func(v []int32) int) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt32Slice2ToInt(values [][][]int32, f func(v [][]int32) int) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxIntByInt32Slice(values [][]int32, f func(vs []int32) int) (max int, err error) {
	return lib_MaxInt(lib_MapInt32SliceToInt(values, f))
}

func lib_MaxIntByInt32Slice2(values [][][]int32, f func(vs [][]int32) int) (max int, err error) {
	return lib_MaxInt(lib_MapInt32Slice2ToInt(values, f))
}

type lib_Int643ToIntCache map[int64]map[int64]map[int64]int

func (c lib_Int643ToIntCache) Has(k1, k2, k3 int64) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Int643ToIntCache) Get(k1, k2, k3 int64) (int, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Int643ToIntCache) Set(k1, k2, k3 int64, v int) int {
	if _, ok := c[k1]; !ok {
		c[k1] = map[int64]map[int64]int{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[int64]int{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumIntByInt64(values []int, f func(v int) int64) int64 {
	var sum int64 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_IntSliceToInt64Slice(values []int) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, int64(value))
	}
	return
}

func lib_MapInt64SliceToInt(values [][]int64, f func(v []int64) int) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt64Slice2ToInt(values [][][]int64, f func(v [][]int64) int) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxIntByInt64Slice(values [][]int64, f func(vs []int64) int) (max int, err error) {
	return lib_MaxInt(lib_MapInt64SliceToInt(values, f))
}

func lib_MaxIntByInt64Slice2(values [][][]int64, f func(vs [][]int64) int) (max int, err error) {
	return lib_MaxInt(lib_MapInt64Slice2ToInt(values, f))
}

type lib_Float323ToIntCache map[float32]map[float32]map[float32]int

func (c lib_Float323ToIntCache) Has(k1, k2, k3 float32) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Float323ToIntCache) Get(k1, k2, k3 float32) (int, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Float323ToIntCache) Set(k1, k2, k3 float32, v int) int {
	if _, ok := c[k1]; !ok {
		c[k1] = map[float32]map[float32]int{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[float32]int{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumIntByFloat32(values []int, f func(v int) float32) float32 {
	var sum float32 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_IntSliceToFloat32Slice(values []int) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, float32(value))
	}
	return
}

func lib_MapFloat32SliceToInt(values [][]float32, f func(v []float32) int) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapFloat32Slice2ToInt(values [][][]float32, f func(v [][]float32) int) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxIntByFloat32Slice(values [][]float32, f func(vs []float32) int) (max int, err error) {
	return lib_MaxInt(lib_MapFloat32SliceToInt(values, f))
}

func lib_MaxIntByFloat32Slice2(values [][][]float32, f func(vs [][]float32) int) (max int, err error) {
	return lib_MaxInt(lib_MapFloat32Slice2ToInt(values, f))
}

type lib_Float643ToIntCache map[float64]map[float64]map[float64]int

func (c lib_Float643ToIntCache) Has(k1, k2, k3 float64) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Float643ToIntCache) Get(k1, k2, k3 float64) (int, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Float643ToIntCache) Set(k1, k2, k3 float64, v int) int {
	if _, ok := c[k1]; !ok {
		c[k1] = map[float64]map[float64]int{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[float64]int{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumIntByFloat64(values []int, f func(v int) float64) float64 {
	var sum float64 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_IntSliceToFloat64Slice(values []int) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, float64(value))
	}
	return
}

func lib_MapFloat64SliceToInt(values [][]float64, f func(v []float64) int) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapFloat64Slice2ToInt(values [][][]float64, f func(v [][]float64) int) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxIntByFloat64Slice(values [][]float64, f func(vs []float64) int) (max int, err error) {
	return lib_MaxInt(lib_MapFloat64SliceToInt(values, f))
}

func lib_MaxIntByFloat64Slice2(values [][][]float64, f func(vs [][]float64) int) (max int, err error) {
	return lib_MaxInt(lib_MapFloat64Slice2ToInt(values, f))
}

type lib_Int3ToInt8Cache map[int]map[int]map[int]int8

func (c lib_Int3ToInt8Cache) Has(k1, k2, k3 int) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Int3ToInt8Cache) Get(k1, k2, k3 int) (int8, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Int3ToInt8Cache) Set(k1, k2, k3 int, v int8) int8 {
	if _, ok := c[k1]; !ok {
		c[k1] = map[int]map[int]int8{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[int]int8{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumInt8ByInt(values []int8, f func(v int8) int) int {
	var sum int = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int8SliceToIntSlice(values []int8) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, int(value))
	}
	return
}

func lib_MapIntSliceToInt8(values [][]int, f func(v []int) int8) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapIntSlice2ToInt8(values [][][]int, f func(v [][]int) int8) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt8ByIntSlice(values [][]int, f func(vs []int) int8) (max int8, err error) {
	return lib_MaxInt8(lib_MapIntSliceToInt8(values, f))
}

func lib_MaxInt8ByIntSlice2(values [][][]int, f func(vs [][]int) int8) (max int8, err error) {
	return lib_MaxInt8(lib_MapIntSlice2ToInt8(values, f))
}

type lib_Int83ToInt8Cache map[int8]map[int8]map[int8]int8

func (c lib_Int83ToInt8Cache) Has(k1, k2, k3 int8) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Int83ToInt8Cache) Get(k1, k2, k3 int8) (int8, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Int83ToInt8Cache) Set(k1, k2, k3 int8, v int8) int8 {
	if _, ok := c[k1]; !ok {
		c[k1] = map[int8]map[int8]int8{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[int8]int8{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumInt8ByInt8(values []int8, f func(v int8) int8) int8 {
	var sum int8 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int8SliceToInt8Slice(values []int8) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, int8(value))
	}
	return
}

func lib_MapInt8SliceToInt8(values [][]int8, f func(v []int8) int8) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt8Slice2ToInt8(values [][][]int8, f func(v [][]int8) int8) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt8ByInt8Slice(values [][]int8, f func(vs []int8) int8) (max int8, err error) {
	return lib_MaxInt8(lib_MapInt8SliceToInt8(values, f))
}

func lib_MaxInt8ByInt8Slice2(values [][][]int8, f func(vs [][]int8) int8) (max int8, err error) {
	return lib_MaxInt8(lib_MapInt8Slice2ToInt8(values, f))
}

type lib_Int163ToInt8Cache map[int16]map[int16]map[int16]int8

func (c lib_Int163ToInt8Cache) Has(k1, k2, k3 int16) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Int163ToInt8Cache) Get(k1, k2, k3 int16) (int8, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Int163ToInt8Cache) Set(k1, k2, k3 int16, v int8) int8 {
	if _, ok := c[k1]; !ok {
		c[k1] = map[int16]map[int16]int8{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[int16]int8{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumInt8ByInt16(values []int8, f func(v int8) int16) int16 {
	var sum int16 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int8SliceToInt16Slice(values []int8) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, int16(value))
	}
	return
}

func lib_MapInt16SliceToInt8(values [][]int16, f func(v []int16) int8) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt16Slice2ToInt8(values [][][]int16, f func(v [][]int16) int8) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt8ByInt16Slice(values [][]int16, f func(vs []int16) int8) (max int8, err error) {
	return lib_MaxInt8(lib_MapInt16SliceToInt8(values, f))
}

func lib_MaxInt8ByInt16Slice2(values [][][]int16, f func(vs [][]int16) int8) (max int8, err error) {
	return lib_MaxInt8(lib_MapInt16Slice2ToInt8(values, f))
}

type lib_Int323ToInt8Cache map[int32]map[int32]map[int32]int8

func (c lib_Int323ToInt8Cache) Has(k1, k2, k3 int32) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Int323ToInt8Cache) Get(k1, k2, k3 int32) (int8, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Int323ToInt8Cache) Set(k1, k2, k3 int32, v int8) int8 {
	if _, ok := c[k1]; !ok {
		c[k1] = map[int32]map[int32]int8{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[int32]int8{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumInt8ByInt32(values []int8, f func(v int8) int32) int32 {
	var sum int32 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int8SliceToInt32Slice(values []int8) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, int32(value))
	}
	return
}

func lib_MapInt32SliceToInt8(values [][]int32, f func(v []int32) int8) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt32Slice2ToInt8(values [][][]int32, f func(v [][]int32) int8) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt8ByInt32Slice(values [][]int32, f func(vs []int32) int8) (max int8, err error) {
	return lib_MaxInt8(lib_MapInt32SliceToInt8(values, f))
}

func lib_MaxInt8ByInt32Slice2(values [][][]int32, f func(vs [][]int32) int8) (max int8, err error) {
	return lib_MaxInt8(lib_MapInt32Slice2ToInt8(values, f))
}

type lib_Int643ToInt8Cache map[int64]map[int64]map[int64]int8

func (c lib_Int643ToInt8Cache) Has(k1, k2, k3 int64) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Int643ToInt8Cache) Get(k1, k2, k3 int64) (int8, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Int643ToInt8Cache) Set(k1, k2, k3 int64, v int8) int8 {
	if _, ok := c[k1]; !ok {
		c[k1] = map[int64]map[int64]int8{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[int64]int8{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumInt8ByInt64(values []int8, f func(v int8) int64) int64 {
	var sum int64 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int8SliceToInt64Slice(values []int8) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, int64(value))
	}
	return
}

func lib_MapInt64SliceToInt8(values [][]int64, f func(v []int64) int8) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt64Slice2ToInt8(values [][][]int64, f func(v [][]int64) int8) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt8ByInt64Slice(values [][]int64, f func(vs []int64) int8) (max int8, err error) {
	return lib_MaxInt8(lib_MapInt64SliceToInt8(values, f))
}

func lib_MaxInt8ByInt64Slice2(values [][][]int64, f func(vs [][]int64) int8) (max int8, err error) {
	return lib_MaxInt8(lib_MapInt64Slice2ToInt8(values, f))
}

type lib_Float323ToInt8Cache map[float32]map[float32]map[float32]int8

func (c lib_Float323ToInt8Cache) Has(k1, k2, k3 float32) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Float323ToInt8Cache) Get(k1, k2, k3 float32) (int8, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Float323ToInt8Cache) Set(k1, k2, k3 float32, v int8) int8 {
	if _, ok := c[k1]; !ok {
		c[k1] = map[float32]map[float32]int8{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[float32]int8{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumInt8ByFloat32(values []int8, f func(v int8) float32) float32 {
	var sum float32 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int8SliceToFloat32Slice(values []int8) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, float32(value))
	}
	return
}

func lib_MapFloat32SliceToInt8(values [][]float32, f func(v []float32) int8) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapFloat32Slice2ToInt8(values [][][]float32, f func(v [][]float32) int8) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt8ByFloat32Slice(values [][]float32, f func(vs []float32) int8) (max int8, err error) {
	return lib_MaxInt8(lib_MapFloat32SliceToInt8(values, f))
}

func lib_MaxInt8ByFloat32Slice2(values [][][]float32, f func(vs [][]float32) int8) (max int8, err error) {
	return lib_MaxInt8(lib_MapFloat32Slice2ToInt8(values, f))
}

type lib_Float643ToInt8Cache map[float64]map[float64]map[float64]int8

func (c lib_Float643ToInt8Cache) Has(k1, k2, k3 float64) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Float643ToInt8Cache) Get(k1, k2, k3 float64) (int8, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Float643ToInt8Cache) Set(k1, k2, k3 float64, v int8) int8 {
	if _, ok := c[k1]; !ok {
		c[k1] = map[float64]map[float64]int8{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[float64]int8{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumInt8ByFloat64(values []int8, f func(v int8) float64) float64 {
	var sum float64 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int8SliceToFloat64Slice(values []int8) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, float64(value))
	}
	return
}

func lib_MapFloat64SliceToInt8(values [][]float64, f func(v []float64) int8) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapFloat64Slice2ToInt8(values [][][]float64, f func(v [][]float64) int8) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt8ByFloat64Slice(values [][]float64, f func(vs []float64) int8) (max int8, err error) {
	return lib_MaxInt8(lib_MapFloat64SliceToInt8(values, f))
}

func lib_MaxInt8ByFloat64Slice2(values [][][]float64, f func(vs [][]float64) int8) (max int8, err error) {
	return lib_MaxInt8(lib_MapFloat64Slice2ToInt8(values, f))
}

type lib_Int3ToInt16Cache map[int]map[int]map[int]int16

func (c lib_Int3ToInt16Cache) Has(k1, k2, k3 int) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Int3ToInt16Cache) Get(k1, k2, k3 int) (int16, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Int3ToInt16Cache) Set(k1, k2, k3 int, v int16) int16 {
	if _, ok := c[k1]; !ok {
		c[k1] = map[int]map[int]int16{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[int]int16{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumInt16ByInt(values []int16, f func(v int16) int) int {
	var sum int = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int16SliceToIntSlice(values []int16) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, int(value))
	}
	return
}

func lib_MapIntSliceToInt16(values [][]int, f func(v []int) int16) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapIntSlice2ToInt16(values [][][]int, f func(v [][]int) int16) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt16ByIntSlice(values [][]int, f func(vs []int) int16) (max int16, err error) {
	return lib_MaxInt16(lib_MapIntSliceToInt16(values, f))
}

func lib_MaxInt16ByIntSlice2(values [][][]int, f func(vs [][]int) int16) (max int16, err error) {
	return lib_MaxInt16(lib_MapIntSlice2ToInt16(values, f))
}

type lib_Int83ToInt16Cache map[int8]map[int8]map[int8]int16

func (c lib_Int83ToInt16Cache) Has(k1, k2, k3 int8) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Int83ToInt16Cache) Get(k1, k2, k3 int8) (int16, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Int83ToInt16Cache) Set(k1, k2, k3 int8, v int16) int16 {
	if _, ok := c[k1]; !ok {
		c[k1] = map[int8]map[int8]int16{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[int8]int16{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumInt16ByInt8(values []int16, f func(v int16) int8) int8 {
	var sum int8 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int16SliceToInt8Slice(values []int16) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, int8(value))
	}
	return
}

func lib_MapInt8SliceToInt16(values [][]int8, f func(v []int8) int16) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt8Slice2ToInt16(values [][][]int8, f func(v [][]int8) int16) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt16ByInt8Slice(values [][]int8, f func(vs []int8) int16) (max int16, err error) {
	return lib_MaxInt16(lib_MapInt8SliceToInt16(values, f))
}

func lib_MaxInt16ByInt8Slice2(values [][][]int8, f func(vs [][]int8) int16) (max int16, err error) {
	return lib_MaxInt16(lib_MapInt8Slice2ToInt16(values, f))
}

type lib_Int163ToInt16Cache map[int16]map[int16]map[int16]int16

func (c lib_Int163ToInt16Cache) Has(k1, k2, k3 int16) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Int163ToInt16Cache) Get(k1, k2, k3 int16) (int16, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Int163ToInt16Cache) Set(k1, k2, k3 int16, v int16) int16 {
	if _, ok := c[k1]; !ok {
		c[k1] = map[int16]map[int16]int16{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[int16]int16{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumInt16ByInt16(values []int16, f func(v int16) int16) int16 {
	var sum int16 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int16SliceToInt16Slice(values []int16) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, int16(value))
	}
	return
}

func lib_MapInt16SliceToInt16(values [][]int16, f func(v []int16) int16) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt16Slice2ToInt16(values [][][]int16, f func(v [][]int16) int16) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt16ByInt16Slice(values [][]int16, f func(vs []int16) int16) (max int16, err error) {
	return lib_MaxInt16(lib_MapInt16SliceToInt16(values, f))
}

func lib_MaxInt16ByInt16Slice2(values [][][]int16, f func(vs [][]int16) int16) (max int16, err error) {
	return lib_MaxInt16(lib_MapInt16Slice2ToInt16(values, f))
}

type lib_Int323ToInt16Cache map[int32]map[int32]map[int32]int16

func (c lib_Int323ToInt16Cache) Has(k1, k2, k3 int32) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Int323ToInt16Cache) Get(k1, k2, k3 int32) (int16, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Int323ToInt16Cache) Set(k1, k2, k3 int32, v int16) int16 {
	if _, ok := c[k1]; !ok {
		c[k1] = map[int32]map[int32]int16{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[int32]int16{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumInt16ByInt32(values []int16, f func(v int16) int32) int32 {
	var sum int32 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int16SliceToInt32Slice(values []int16) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, int32(value))
	}
	return
}

func lib_MapInt32SliceToInt16(values [][]int32, f func(v []int32) int16) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt32Slice2ToInt16(values [][][]int32, f func(v [][]int32) int16) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt16ByInt32Slice(values [][]int32, f func(vs []int32) int16) (max int16, err error) {
	return lib_MaxInt16(lib_MapInt32SliceToInt16(values, f))
}

func lib_MaxInt16ByInt32Slice2(values [][][]int32, f func(vs [][]int32) int16) (max int16, err error) {
	return lib_MaxInt16(lib_MapInt32Slice2ToInt16(values, f))
}

type lib_Int643ToInt16Cache map[int64]map[int64]map[int64]int16

func (c lib_Int643ToInt16Cache) Has(k1, k2, k3 int64) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Int643ToInt16Cache) Get(k1, k2, k3 int64) (int16, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Int643ToInt16Cache) Set(k1, k2, k3 int64, v int16) int16 {
	if _, ok := c[k1]; !ok {
		c[k1] = map[int64]map[int64]int16{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[int64]int16{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumInt16ByInt64(values []int16, f func(v int16) int64) int64 {
	var sum int64 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int16SliceToInt64Slice(values []int16) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, int64(value))
	}
	return
}

func lib_MapInt64SliceToInt16(values [][]int64, f func(v []int64) int16) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt64Slice2ToInt16(values [][][]int64, f func(v [][]int64) int16) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt16ByInt64Slice(values [][]int64, f func(vs []int64) int16) (max int16, err error) {
	return lib_MaxInt16(lib_MapInt64SliceToInt16(values, f))
}

func lib_MaxInt16ByInt64Slice2(values [][][]int64, f func(vs [][]int64) int16) (max int16, err error) {
	return lib_MaxInt16(lib_MapInt64Slice2ToInt16(values, f))
}

type lib_Float323ToInt16Cache map[float32]map[float32]map[float32]int16

func (c lib_Float323ToInt16Cache) Has(k1, k2, k3 float32) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Float323ToInt16Cache) Get(k1, k2, k3 float32) (int16, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Float323ToInt16Cache) Set(k1, k2, k3 float32, v int16) int16 {
	if _, ok := c[k1]; !ok {
		c[k1] = map[float32]map[float32]int16{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[float32]int16{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumInt16ByFloat32(values []int16, f func(v int16) float32) float32 {
	var sum float32 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int16SliceToFloat32Slice(values []int16) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, float32(value))
	}
	return
}

func lib_MapFloat32SliceToInt16(values [][]float32, f func(v []float32) int16) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapFloat32Slice2ToInt16(values [][][]float32, f func(v [][]float32) int16) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt16ByFloat32Slice(values [][]float32, f func(vs []float32) int16) (max int16, err error) {
	return lib_MaxInt16(lib_MapFloat32SliceToInt16(values, f))
}

func lib_MaxInt16ByFloat32Slice2(values [][][]float32, f func(vs [][]float32) int16) (max int16, err error) {
	return lib_MaxInt16(lib_MapFloat32Slice2ToInt16(values, f))
}

type lib_Float643ToInt16Cache map[float64]map[float64]map[float64]int16

func (c lib_Float643ToInt16Cache) Has(k1, k2, k3 float64) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Float643ToInt16Cache) Get(k1, k2, k3 float64) (int16, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Float643ToInt16Cache) Set(k1, k2, k3 float64, v int16) int16 {
	if _, ok := c[k1]; !ok {
		c[k1] = map[float64]map[float64]int16{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[float64]int16{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumInt16ByFloat64(values []int16, f func(v int16) float64) float64 {
	var sum float64 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int16SliceToFloat64Slice(values []int16) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, float64(value))
	}
	return
}

func lib_MapFloat64SliceToInt16(values [][]float64, f func(v []float64) int16) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapFloat64Slice2ToInt16(values [][][]float64, f func(v [][]float64) int16) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt16ByFloat64Slice(values [][]float64, f func(vs []float64) int16) (max int16, err error) {
	return lib_MaxInt16(lib_MapFloat64SliceToInt16(values, f))
}

func lib_MaxInt16ByFloat64Slice2(values [][][]float64, f func(vs [][]float64) int16) (max int16, err error) {
	return lib_MaxInt16(lib_MapFloat64Slice2ToInt16(values, f))
}

type lib_Int3ToInt32Cache map[int]map[int]map[int]int32

func (c lib_Int3ToInt32Cache) Has(k1, k2, k3 int) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Int3ToInt32Cache) Get(k1, k2, k3 int) (int32, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Int3ToInt32Cache) Set(k1, k2, k3 int, v int32) int32 {
	if _, ok := c[k1]; !ok {
		c[k1] = map[int]map[int]int32{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[int]int32{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumInt32ByInt(values []int32, f func(v int32) int) int {
	var sum int = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int32SliceToIntSlice(values []int32) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, int(value))
	}
	return
}

func lib_MapIntSliceToInt32(values [][]int, f func(v []int) int32) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapIntSlice2ToInt32(values [][][]int, f func(v [][]int) int32) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt32ByIntSlice(values [][]int, f func(vs []int) int32) (max int32, err error) {
	return lib_MaxInt32(lib_MapIntSliceToInt32(values, f))
}

func lib_MaxInt32ByIntSlice2(values [][][]int, f func(vs [][]int) int32) (max int32, err error) {
	return lib_MaxInt32(lib_MapIntSlice2ToInt32(values, f))
}

type lib_Int83ToInt32Cache map[int8]map[int8]map[int8]int32

func (c lib_Int83ToInt32Cache) Has(k1, k2, k3 int8) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Int83ToInt32Cache) Get(k1, k2, k3 int8) (int32, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Int83ToInt32Cache) Set(k1, k2, k3 int8, v int32) int32 {
	if _, ok := c[k1]; !ok {
		c[k1] = map[int8]map[int8]int32{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[int8]int32{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumInt32ByInt8(values []int32, f func(v int32) int8) int8 {
	var sum int8 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int32SliceToInt8Slice(values []int32) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, int8(value))
	}
	return
}

func lib_MapInt8SliceToInt32(values [][]int8, f func(v []int8) int32) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt8Slice2ToInt32(values [][][]int8, f func(v [][]int8) int32) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt32ByInt8Slice(values [][]int8, f func(vs []int8) int32) (max int32, err error) {
	return lib_MaxInt32(lib_MapInt8SliceToInt32(values, f))
}

func lib_MaxInt32ByInt8Slice2(values [][][]int8, f func(vs [][]int8) int32) (max int32, err error) {
	return lib_MaxInt32(lib_MapInt8Slice2ToInt32(values, f))
}

type lib_Int163ToInt32Cache map[int16]map[int16]map[int16]int32

func (c lib_Int163ToInt32Cache) Has(k1, k2, k3 int16) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Int163ToInt32Cache) Get(k1, k2, k3 int16) (int32, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Int163ToInt32Cache) Set(k1, k2, k3 int16, v int32) int32 {
	if _, ok := c[k1]; !ok {
		c[k1] = map[int16]map[int16]int32{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[int16]int32{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumInt32ByInt16(values []int32, f func(v int32) int16) int16 {
	var sum int16 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int32SliceToInt16Slice(values []int32) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, int16(value))
	}
	return
}

func lib_MapInt16SliceToInt32(values [][]int16, f func(v []int16) int32) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt16Slice2ToInt32(values [][][]int16, f func(v [][]int16) int32) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt32ByInt16Slice(values [][]int16, f func(vs []int16) int32) (max int32, err error) {
	return lib_MaxInt32(lib_MapInt16SliceToInt32(values, f))
}

func lib_MaxInt32ByInt16Slice2(values [][][]int16, f func(vs [][]int16) int32) (max int32, err error) {
	return lib_MaxInt32(lib_MapInt16Slice2ToInt32(values, f))
}

type lib_Int323ToInt32Cache map[int32]map[int32]map[int32]int32

func (c lib_Int323ToInt32Cache) Has(k1, k2, k3 int32) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Int323ToInt32Cache) Get(k1, k2, k3 int32) (int32, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Int323ToInt32Cache) Set(k1, k2, k3 int32, v int32) int32 {
	if _, ok := c[k1]; !ok {
		c[k1] = map[int32]map[int32]int32{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[int32]int32{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumInt32ByInt32(values []int32, f func(v int32) int32) int32 {
	var sum int32 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int32SliceToInt32Slice(values []int32) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, int32(value))
	}
	return
}

func lib_MapInt32SliceToInt32(values [][]int32, f func(v []int32) int32) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt32Slice2ToInt32(values [][][]int32, f func(v [][]int32) int32) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt32ByInt32Slice(values [][]int32, f func(vs []int32) int32) (max int32, err error) {
	return lib_MaxInt32(lib_MapInt32SliceToInt32(values, f))
}

func lib_MaxInt32ByInt32Slice2(values [][][]int32, f func(vs [][]int32) int32) (max int32, err error) {
	return lib_MaxInt32(lib_MapInt32Slice2ToInt32(values, f))
}

type lib_Int643ToInt32Cache map[int64]map[int64]map[int64]int32

func (c lib_Int643ToInt32Cache) Has(k1, k2, k3 int64) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Int643ToInt32Cache) Get(k1, k2, k3 int64) (int32, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Int643ToInt32Cache) Set(k1, k2, k3 int64, v int32) int32 {
	if _, ok := c[k1]; !ok {
		c[k1] = map[int64]map[int64]int32{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[int64]int32{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumInt32ByInt64(values []int32, f func(v int32) int64) int64 {
	var sum int64 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int32SliceToInt64Slice(values []int32) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, int64(value))
	}
	return
}

func lib_MapInt64SliceToInt32(values [][]int64, f func(v []int64) int32) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt64Slice2ToInt32(values [][][]int64, f func(v [][]int64) int32) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt32ByInt64Slice(values [][]int64, f func(vs []int64) int32) (max int32, err error) {
	return lib_MaxInt32(lib_MapInt64SliceToInt32(values, f))
}

func lib_MaxInt32ByInt64Slice2(values [][][]int64, f func(vs [][]int64) int32) (max int32, err error) {
	return lib_MaxInt32(lib_MapInt64Slice2ToInt32(values, f))
}

type lib_Float323ToInt32Cache map[float32]map[float32]map[float32]int32

func (c lib_Float323ToInt32Cache) Has(k1, k2, k3 float32) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Float323ToInt32Cache) Get(k1, k2, k3 float32) (int32, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Float323ToInt32Cache) Set(k1, k2, k3 float32, v int32) int32 {
	if _, ok := c[k1]; !ok {
		c[k1] = map[float32]map[float32]int32{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[float32]int32{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumInt32ByFloat32(values []int32, f func(v int32) float32) float32 {
	var sum float32 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int32SliceToFloat32Slice(values []int32) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, float32(value))
	}
	return
}

func lib_MapFloat32SliceToInt32(values [][]float32, f func(v []float32) int32) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapFloat32Slice2ToInt32(values [][][]float32, f func(v [][]float32) int32) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt32ByFloat32Slice(values [][]float32, f func(vs []float32) int32) (max int32, err error) {
	return lib_MaxInt32(lib_MapFloat32SliceToInt32(values, f))
}

func lib_MaxInt32ByFloat32Slice2(values [][][]float32, f func(vs [][]float32) int32) (max int32, err error) {
	return lib_MaxInt32(lib_MapFloat32Slice2ToInt32(values, f))
}

type lib_Float643ToInt32Cache map[float64]map[float64]map[float64]int32

func (c lib_Float643ToInt32Cache) Has(k1, k2, k3 float64) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Float643ToInt32Cache) Get(k1, k2, k3 float64) (int32, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Float643ToInt32Cache) Set(k1, k2, k3 float64, v int32) int32 {
	if _, ok := c[k1]; !ok {
		c[k1] = map[float64]map[float64]int32{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[float64]int32{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumInt32ByFloat64(values []int32, f func(v int32) float64) float64 {
	var sum float64 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int32SliceToFloat64Slice(values []int32) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, float64(value))
	}
	return
}

func lib_MapFloat64SliceToInt32(values [][]float64, f func(v []float64) int32) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapFloat64Slice2ToInt32(values [][][]float64, f func(v [][]float64) int32) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt32ByFloat64Slice(values [][]float64, f func(vs []float64) int32) (max int32, err error) {
	return lib_MaxInt32(lib_MapFloat64SliceToInt32(values, f))
}

func lib_MaxInt32ByFloat64Slice2(values [][][]float64, f func(vs [][]float64) int32) (max int32, err error) {
	return lib_MaxInt32(lib_MapFloat64Slice2ToInt32(values, f))
}

type lib_Int3ToInt64Cache map[int]map[int]map[int]int64

func (c lib_Int3ToInt64Cache) Has(k1, k2, k3 int) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Int3ToInt64Cache) Get(k1, k2, k3 int) (int64, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Int3ToInt64Cache) Set(k1, k2, k3 int, v int64) int64 {
	if _, ok := c[k1]; !ok {
		c[k1] = map[int]map[int]int64{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[int]int64{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumInt64ByInt(values []int64, f func(v int64) int) int {
	var sum int = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int64SliceToIntSlice(values []int64) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, int(value))
	}
	return
}

func lib_MapIntSliceToInt64(values [][]int, f func(v []int) int64) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapIntSlice2ToInt64(values [][][]int, f func(v [][]int) int64) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt64ByIntSlice(values [][]int, f func(vs []int) int64) (max int64, err error) {
	return lib_MaxInt64(lib_MapIntSliceToInt64(values, f))
}

func lib_MaxInt64ByIntSlice2(values [][][]int, f func(vs [][]int) int64) (max int64, err error) {
	return lib_MaxInt64(lib_MapIntSlice2ToInt64(values, f))
}

type lib_Int83ToInt64Cache map[int8]map[int8]map[int8]int64

func (c lib_Int83ToInt64Cache) Has(k1, k2, k3 int8) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Int83ToInt64Cache) Get(k1, k2, k3 int8) (int64, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Int83ToInt64Cache) Set(k1, k2, k3 int8, v int64) int64 {
	if _, ok := c[k1]; !ok {
		c[k1] = map[int8]map[int8]int64{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[int8]int64{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumInt64ByInt8(values []int64, f func(v int64) int8) int8 {
	var sum int8 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int64SliceToInt8Slice(values []int64) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, int8(value))
	}
	return
}

func lib_MapInt8SliceToInt64(values [][]int8, f func(v []int8) int64) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt8Slice2ToInt64(values [][][]int8, f func(v [][]int8) int64) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt64ByInt8Slice(values [][]int8, f func(vs []int8) int64) (max int64, err error) {
	return lib_MaxInt64(lib_MapInt8SliceToInt64(values, f))
}

func lib_MaxInt64ByInt8Slice2(values [][][]int8, f func(vs [][]int8) int64) (max int64, err error) {
	return lib_MaxInt64(lib_MapInt8Slice2ToInt64(values, f))
}

type lib_Int163ToInt64Cache map[int16]map[int16]map[int16]int64

func (c lib_Int163ToInt64Cache) Has(k1, k2, k3 int16) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Int163ToInt64Cache) Get(k1, k2, k3 int16) (int64, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Int163ToInt64Cache) Set(k1, k2, k3 int16, v int64) int64 {
	if _, ok := c[k1]; !ok {
		c[k1] = map[int16]map[int16]int64{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[int16]int64{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumInt64ByInt16(values []int64, f func(v int64) int16) int16 {
	var sum int16 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int64SliceToInt16Slice(values []int64) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, int16(value))
	}
	return
}

func lib_MapInt16SliceToInt64(values [][]int16, f func(v []int16) int64) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt16Slice2ToInt64(values [][][]int16, f func(v [][]int16) int64) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt64ByInt16Slice(values [][]int16, f func(vs []int16) int64) (max int64, err error) {
	return lib_MaxInt64(lib_MapInt16SliceToInt64(values, f))
}

func lib_MaxInt64ByInt16Slice2(values [][][]int16, f func(vs [][]int16) int64) (max int64, err error) {
	return lib_MaxInt64(lib_MapInt16Slice2ToInt64(values, f))
}

type lib_Int323ToInt64Cache map[int32]map[int32]map[int32]int64

func (c lib_Int323ToInt64Cache) Has(k1, k2, k3 int32) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Int323ToInt64Cache) Get(k1, k2, k3 int32) (int64, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Int323ToInt64Cache) Set(k1, k2, k3 int32, v int64) int64 {
	if _, ok := c[k1]; !ok {
		c[k1] = map[int32]map[int32]int64{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[int32]int64{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumInt64ByInt32(values []int64, f func(v int64) int32) int32 {
	var sum int32 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int64SliceToInt32Slice(values []int64) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, int32(value))
	}
	return
}

func lib_MapInt32SliceToInt64(values [][]int32, f func(v []int32) int64) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt32Slice2ToInt64(values [][][]int32, f func(v [][]int32) int64) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt64ByInt32Slice(values [][]int32, f func(vs []int32) int64) (max int64, err error) {
	return lib_MaxInt64(lib_MapInt32SliceToInt64(values, f))
}

func lib_MaxInt64ByInt32Slice2(values [][][]int32, f func(vs [][]int32) int64) (max int64, err error) {
	return lib_MaxInt64(lib_MapInt32Slice2ToInt64(values, f))
}

type lib_Int643ToInt64Cache map[int64]map[int64]map[int64]int64

func (c lib_Int643ToInt64Cache) Has(k1, k2, k3 int64) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Int643ToInt64Cache) Get(k1, k2, k3 int64) (int64, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Int643ToInt64Cache) Set(k1, k2, k3 int64, v int64) int64 {
	if _, ok := c[k1]; !ok {
		c[k1] = map[int64]map[int64]int64{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[int64]int64{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumInt64ByInt64(values []int64, f func(v int64) int64) int64 {
	var sum int64 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int64SliceToInt64Slice(values []int64) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, int64(value))
	}
	return
}

func lib_MapInt64SliceToInt64(values [][]int64, f func(v []int64) int64) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt64Slice2ToInt64(values [][][]int64, f func(v [][]int64) int64) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt64ByInt64Slice(values [][]int64, f func(vs []int64) int64) (max int64, err error) {
	return lib_MaxInt64(lib_MapInt64SliceToInt64(values, f))
}

func lib_MaxInt64ByInt64Slice2(values [][][]int64, f func(vs [][]int64) int64) (max int64, err error) {
	return lib_MaxInt64(lib_MapInt64Slice2ToInt64(values, f))
}

type lib_Float323ToInt64Cache map[float32]map[float32]map[float32]int64

func (c lib_Float323ToInt64Cache) Has(k1, k2, k3 float32) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Float323ToInt64Cache) Get(k1, k2, k3 float32) (int64, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Float323ToInt64Cache) Set(k1, k2, k3 float32, v int64) int64 {
	if _, ok := c[k1]; !ok {
		c[k1] = map[float32]map[float32]int64{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[float32]int64{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumInt64ByFloat32(values []int64, f func(v int64) float32) float32 {
	var sum float32 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int64SliceToFloat32Slice(values []int64) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, float32(value))
	}
	return
}

func lib_MapFloat32SliceToInt64(values [][]float32, f func(v []float32) int64) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapFloat32Slice2ToInt64(values [][][]float32, f func(v [][]float32) int64) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt64ByFloat32Slice(values [][]float32, f func(vs []float32) int64) (max int64, err error) {
	return lib_MaxInt64(lib_MapFloat32SliceToInt64(values, f))
}

func lib_MaxInt64ByFloat32Slice2(values [][][]float32, f func(vs [][]float32) int64) (max int64, err error) {
	return lib_MaxInt64(lib_MapFloat32Slice2ToInt64(values, f))
}

type lib_Float643ToInt64Cache map[float64]map[float64]map[float64]int64

func (c lib_Float643ToInt64Cache) Has(k1, k2, k3 float64) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Float643ToInt64Cache) Get(k1, k2, k3 float64) (int64, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Float643ToInt64Cache) Set(k1, k2, k3 float64, v int64) int64 {
	if _, ok := c[k1]; !ok {
		c[k1] = map[float64]map[float64]int64{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[float64]int64{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumInt64ByFloat64(values []int64, f func(v int64) float64) float64 {
	var sum float64 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Int64SliceToFloat64Slice(values []int64) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, float64(value))
	}
	return
}

func lib_MapFloat64SliceToInt64(values [][]float64, f func(v []float64) int64) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapFloat64Slice2ToInt64(values [][][]float64, f func(v [][]float64) int64) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxInt64ByFloat64Slice(values [][]float64, f func(vs []float64) int64) (max int64, err error) {
	return lib_MaxInt64(lib_MapFloat64SliceToInt64(values, f))
}

func lib_MaxInt64ByFloat64Slice2(values [][][]float64, f func(vs [][]float64) int64) (max int64, err error) {
	return lib_MaxInt64(lib_MapFloat64Slice2ToInt64(values, f))
}

type lib_Int3ToFloat32Cache map[int]map[int]map[int]float32

func (c lib_Int3ToFloat32Cache) Has(k1, k2, k3 int) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Int3ToFloat32Cache) Get(k1, k2, k3 int) (float32, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Int3ToFloat32Cache) Set(k1, k2, k3 int, v float32) float32 {
	if _, ok := c[k1]; !ok {
		c[k1] = map[int]map[int]float32{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[int]float32{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumFloat32ByInt(values []float32, f func(v float32) int) int {
	var sum int = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Float32SliceToIntSlice(values []float32) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, int(value))
	}
	return
}

func lib_MapIntSliceToFloat32(values [][]int, f func(v []int) float32) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapIntSlice2ToFloat32(values [][][]int, f func(v [][]int) float32) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxFloat32ByIntSlice(values [][]int, f func(vs []int) float32) (max float32, err error) {
	return lib_MaxFloat32(lib_MapIntSliceToFloat32(values, f))
}

func lib_MaxFloat32ByIntSlice2(values [][][]int, f func(vs [][]int) float32) (max float32, err error) {
	return lib_MaxFloat32(lib_MapIntSlice2ToFloat32(values, f))
}

type lib_Int83ToFloat32Cache map[int8]map[int8]map[int8]float32

func (c lib_Int83ToFloat32Cache) Has(k1, k2, k3 int8) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Int83ToFloat32Cache) Get(k1, k2, k3 int8) (float32, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Int83ToFloat32Cache) Set(k1, k2, k3 int8, v float32) float32 {
	if _, ok := c[k1]; !ok {
		c[k1] = map[int8]map[int8]float32{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[int8]float32{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumFloat32ByInt8(values []float32, f func(v float32) int8) int8 {
	var sum int8 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Float32SliceToInt8Slice(values []float32) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, int8(value))
	}
	return
}

func lib_MapInt8SliceToFloat32(values [][]int8, f func(v []int8) float32) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt8Slice2ToFloat32(values [][][]int8, f func(v [][]int8) float32) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxFloat32ByInt8Slice(values [][]int8, f func(vs []int8) float32) (max float32, err error) {
	return lib_MaxFloat32(lib_MapInt8SliceToFloat32(values, f))
}

func lib_MaxFloat32ByInt8Slice2(values [][][]int8, f func(vs [][]int8) float32) (max float32, err error) {
	return lib_MaxFloat32(lib_MapInt8Slice2ToFloat32(values, f))
}

type lib_Int163ToFloat32Cache map[int16]map[int16]map[int16]float32

func (c lib_Int163ToFloat32Cache) Has(k1, k2, k3 int16) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Int163ToFloat32Cache) Get(k1, k2, k3 int16) (float32, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Int163ToFloat32Cache) Set(k1, k2, k3 int16, v float32) float32 {
	if _, ok := c[k1]; !ok {
		c[k1] = map[int16]map[int16]float32{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[int16]float32{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumFloat32ByInt16(values []float32, f func(v float32) int16) int16 {
	var sum int16 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Float32SliceToInt16Slice(values []float32) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, int16(value))
	}
	return
}

func lib_MapInt16SliceToFloat32(values [][]int16, f func(v []int16) float32) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt16Slice2ToFloat32(values [][][]int16, f func(v [][]int16) float32) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxFloat32ByInt16Slice(values [][]int16, f func(vs []int16) float32) (max float32, err error) {
	return lib_MaxFloat32(lib_MapInt16SliceToFloat32(values, f))
}

func lib_MaxFloat32ByInt16Slice2(values [][][]int16, f func(vs [][]int16) float32) (max float32, err error) {
	return lib_MaxFloat32(lib_MapInt16Slice2ToFloat32(values, f))
}

type lib_Int323ToFloat32Cache map[int32]map[int32]map[int32]float32

func (c lib_Int323ToFloat32Cache) Has(k1, k2, k3 int32) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Int323ToFloat32Cache) Get(k1, k2, k3 int32) (float32, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Int323ToFloat32Cache) Set(k1, k2, k3 int32, v float32) float32 {
	if _, ok := c[k1]; !ok {
		c[k1] = map[int32]map[int32]float32{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[int32]float32{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumFloat32ByInt32(values []float32, f func(v float32) int32) int32 {
	var sum int32 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Float32SliceToInt32Slice(values []float32) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, int32(value))
	}
	return
}

func lib_MapInt32SliceToFloat32(values [][]int32, f func(v []int32) float32) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt32Slice2ToFloat32(values [][][]int32, f func(v [][]int32) float32) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxFloat32ByInt32Slice(values [][]int32, f func(vs []int32) float32) (max float32, err error) {
	return lib_MaxFloat32(lib_MapInt32SliceToFloat32(values, f))
}

func lib_MaxFloat32ByInt32Slice2(values [][][]int32, f func(vs [][]int32) float32) (max float32, err error) {
	return lib_MaxFloat32(lib_MapInt32Slice2ToFloat32(values, f))
}

type lib_Int643ToFloat32Cache map[int64]map[int64]map[int64]float32

func (c lib_Int643ToFloat32Cache) Has(k1, k2, k3 int64) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Int643ToFloat32Cache) Get(k1, k2, k3 int64) (float32, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Int643ToFloat32Cache) Set(k1, k2, k3 int64, v float32) float32 {
	if _, ok := c[k1]; !ok {
		c[k1] = map[int64]map[int64]float32{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[int64]float32{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumFloat32ByInt64(values []float32, f func(v float32) int64) int64 {
	var sum int64 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Float32SliceToInt64Slice(values []float32) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, int64(value))
	}
	return
}

func lib_MapInt64SliceToFloat32(values [][]int64, f func(v []int64) float32) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt64Slice2ToFloat32(values [][][]int64, f func(v [][]int64) float32) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxFloat32ByInt64Slice(values [][]int64, f func(vs []int64) float32) (max float32, err error) {
	return lib_MaxFloat32(lib_MapInt64SliceToFloat32(values, f))
}

func lib_MaxFloat32ByInt64Slice2(values [][][]int64, f func(vs [][]int64) float32) (max float32, err error) {
	return lib_MaxFloat32(lib_MapInt64Slice2ToFloat32(values, f))
}

type lib_Float323ToFloat32Cache map[float32]map[float32]map[float32]float32

func (c lib_Float323ToFloat32Cache) Has(k1, k2, k3 float32) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Float323ToFloat32Cache) Get(k1, k2, k3 float32) (float32, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Float323ToFloat32Cache) Set(k1, k2, k3 float32, v float32) float32 {
	if _, ok := c[k1]; !ok {
		c[k1] = map[float32]map[float32]float32{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[float32]float32{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumFloat32ByFloat32(values []float32, f func(v float32) float32) float32 {
	var sum float32 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Float32SliceToFloat32Slice(values []float32) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, float32(value))
	}
	return
}

func lib_MapFloat32SliceToFloat32(values [][]float32, f func(v []float32) float32) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapFloat32Slice2ToFloat32(values [][][]float32, f func(v [][]float32) float32) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxFloat32ByFloat32Slice(values [][]float32, f func(vs []float32) float32) (max float32, err error) {
	return lib_MaxFloat32(lib_MapFloat32SliceToFloat32(values, f))
}

func lib_MaxFloat32ByFloat32Slice2(values [][][]float32, f func(vs [][]float32) float32) (max float32, err error) {
	return lib_MaxFloat32(lib_MapFloat32Slice2ToFloat32(values, f))
}

type lib_Float643ToFloat32Cache map[float64]map[float64]map[float64]float32

func (c lib_Float643ToFloat32Cache) Has(k1, k2, k3 float64) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Float643ToFloat32Cache) Get(k1, k2, k3 float64) (float32, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Float643ToFloat32Cache) Set(k1, k2, k3 float64, v float32) float32 {
	if _, ok := c[k1]; !ok {
		c[k1] = map[float64]map[float64]float32{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[float64]float32{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumFloat32ByFloat64(values []float32, f func(v float32) float64) float64 {
	var sum float64 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Float32SliceToFloat64Slice(values []float32) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, float64(value))
	}
	return
}

func lib_MapFloat64SliceToFloat32(values [][]float64, f func(v []float64) float32) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapFloat64Slice2ToFloat32(values [][][]float64, f func(v [][]float64) float32) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxFloat32ByFloat64Slice(values [][]float64, f func(vs []float64) float32) (max float32, err error) {
	return lib_MaxFloat32(lib_MapFloat64SliceToFloat32(values, f))
}

func lib_MaxFloat32ByFloat64Slice2(values [][][]float64, f func(vs [][]float64) float32) (max float32, err error) {
	return lib_MaxFloat32(lib_MapFloat64Slice2ToFloat32(values, f))
}

type lib_Int3ToFloat64Cache map[int]map[int]map[int]float64

func (c lib_Int3ToFloat64Cache) Has(k1, k2, k3 int) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Int3ToFloat64Cache) Get(k1, k2, k3 int) (float64, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Int3ToFloat64Cache) Set(k1, k2, k3 int, v float64) float64 {
	if _, ok := c[k1]; !ok {
		c[k1] = map[int]map[int]float64{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[int]float64{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumFloat64ByInt(values []float64, f func(v float64) int) int {
	var sum int = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Float64SliceToIntSlice(values []float64) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, int(value))
	}
	return
}

func lib_MapIntSliceToFloat64(values [][]int, f func(v []int) float64) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapIntSlice2ToFloat64(values [][][]int, f func(v [][]int) float64) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxFloat64ByIntSlice(values [][]int, f func(vs []int) float64) (max float64, err error) {
	return lib_MaxFloat64(lib_MapIntSliceToFloat64(values, f))
}

func lib_MaxFloat64ByIntSlice2(values [][][]int, f func(vs [][]int) float64) (max float64, err error) {
	return lib_MaxFloat64(lib_MapIntSlice2ToFloat64(values, f))
}

type lib_Int83ToFloat64Cache map[int8]map[int8]map[int8]float64

func (c lib_Int83ToFloat64Cache) Has(k1, k2, k3 int8) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Int83ToFloat64Cache) Get(k1, k2, k3 int8) (float64, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Int83ToFloat64Cache) Set(k1, k2, k3 int8, v float64) float64 {
	if _, ok := c[k1]; !ok {
		c[k1] = map[int8]map[int8]float64{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[int8]float64{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumFloat64ByInt8(values []float64, f func(v float64) int8) int8 {
	var sum int8 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Float64SliceToInt8Slice(values []float64) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, int8(value))
	}
	return
}

func lib_MapInt8SliceToFloat64(values [][]int8, f func(v []int8) float64) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt8Slice2ToFloat64(values [][][]int8, f func(v [][]int8) float64) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxFloat64ByInt8Slice(values [][]int8, f func(vs []int8) float64) (max float64, err error) {
	return lib_MaxFloat64(lib_MapInt8SliceToFloat64(values, f))
}

func lib_MaxFloat64ByInt8Slice2(values [][][]int8, f func(vs [][]int8) float64) (max float64, err error) {
	return lib_MaxFloat64(lib_MapInt8Slice2ToFloat64(values, f))
}

type lib_Int163ToFloat64Cache map[int16]map[int16]map[int16]float64

func (c lib_Int163ToFloat64Cache) Has(k1, k2, k3 int16) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Int163ToFloat64Cache) Get(k1, k2, k3 int16) (float64, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Int163ToFloat64Cache) Set(k1, k2, k3 int16, v float64) float64 {
	if _, ok := c[k1]; !ok {
		c[k1] = map[int16]map[int16]float64{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[int16]float64{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumFloat64ByInt16(values []float64, f func(v float64) int16) int16 {
	var sum int16 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Float64SliceToInt16Slice(values []float64) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, int16(value))
	}
	return
}

func lib_MapInt16SliceToFloat64(values [][]int16, f func(v []int16) float64) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt16Slice2ToFloat64(values [][][]int16, f func(v [][]int16) float64) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxFloat64ByInt16Slice(values [][]int16, f func(vs []int16) float64) (max float64, err error) {
	return lib_MaxFloat64(lib_MapInt16SliceToFloat64(values, f))
}

func lib_MaxFloat64ByInt16Slice2(values [][][]int16, f func(vs [][]int16) float64) (max float64, err error) {
	return lib_MaxFloat64(lib_MapInt16Slice2ToFloat64(values, f))
}

type lib_Int323ToFloat64Cache map[int32]map[int32]map[int32]float64

func (c lib_Int323ToFloat64Cache) Has(k1, k2, k3 int32) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Int323ToFloat64Cache) Get(k1, k2, k3 int32) (float64, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Int323ToFloat64Cache) Set(k1, k2, k3 int32, v float64) float64 {
	if _, ok := c[k1]; !ok {
		c[k1] = map[int32]map[int32]float64{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[int32]float64{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumFloat64ByInt32(values []float64, f func(v float64) int32) int32 {
	var sum int32 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Float64SliceToInt32Slice(values []float64) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, int32(value))
	}
	return
}

func lib_MapInt32SliceToFloat64(values [][]int32, f func(v []int32) float64) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt32Slice2ToFloat64(values [][][]int32, f func(v [][]int32) float64) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxFloat64ByInt32Slice(values [][]int32, f func(vs []int32) float64) (max float64, err error) {
	return lib_MaxFloat64(lib_MapInt32SliceToFloat64(values, f))
}

func lib_MaxFloat64ByInt32Slice2(values [][][]int32, f func(vs [][]int32) float64) (max float64, err error) {
	return lib_MaxFloat64(lib_MapInt32Slice2ToFloat64(values, f))
}

type lib_Int643ToFloat64Cache map[int64]map[int64]map[int64]float64

func (c lib_Int643ToFloat64Cache) Has(k1, k2, k3 int64) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Int643ToFloat64Cache) Get(k1, k2, k3 int64) (float64, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Int643ToFloat64Cache) Set(k1, k2, k3 int64, v float64) float64 {
	if _, ok := c[k1]; !ok {
		c[k1] = map[int64]map[int64]float64{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[int64]float64{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumFloat64ByInt64(values []float64, f func(v float64) int64) int64 {
	var sum int64 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Float64SliceToInt64Slice(values []float64) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, int64(value))
	}
	return
}

func lib_MapInt64SliceToFloat64(values [][]int64, f func(v []int64) float64) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt64Slice2ToFloat64(values [][][]int64, f func(v [][]int64) float64) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxFloat64ByInt64Slice(values [][]int64, f func(vs []int64) float64) (max float64, err error) {
	return lib_MaxFloat64(lib_MapInt64SliceToFloat64(values, f))
}

func lib_MaxFloat64ByInt64Slice2(values [][][]int64, f func(vs [][]int64) float64) (max float64, err error) {
	return lib_MaxFloat64(lib_MapInt64Slice2ToFloat64(values, f))
}

type lib_Float323ToFloat64Cache map[float32]map[float32]map[float32]float64

func (c lib_Float323ToFloat64Cache) Has(k1, k2, k3 float32) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Float323ToFloat64Cache) Get(k1, k2, k3 float32) (float64, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Float323ToFloat64Cache) Set(k1, k2, k3 float32, v float64) float64 {
	if _, ok := c[k1]; !ok {
		c[k1] = map[float32]map[float32]float64{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[float32]float64{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumFloat64ByFloat32(values []float64, f func(v float64) float32) float32 {
	var sum float32 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Float64SliceToFloat32Slice(values []float64) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, float32(value))
	}
	return
}

func lib_MapFloat32SliceToFloat64(values [][]float32, f func(v []float32) float64) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapFloat32Slice2ToFloat64(values [][][]float32, f func(v [][]float32) float64) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxFloat64ByFloat32Slice(values [][]float32, f func(vs []float32) float64) (max float64, err error) {
	return lib_MaxFloat64(lib_MapFloat32SliceToFloat64(values, f))
}

func lib_MaxFloat64ByFloat32Slice2(values [][][]float32, f func(vs [][]float32) float64) (max float64, err error) {
	return lib_MaxFloat64(lib_MapFloat32Slice2ToFloat64(values, f))
}

type lib_Float643ToFloat64Cache map[float64]map[float64]map[float64]float64

func (c lib_Float643ToFloat64Cache) Has(k1, k2, k3 float64) bool {
	if _, ok := c[k1]; !ok {
		return false
	}

	if _, ok := c[k1][k2]; !ok {
		return false
	}

	_, ok := c[k1][k2][k3]
	return ok
}

func (c lib_Float643ToFloat64Cache) Get(k1, k2, k3 float64) (float64, bool) {
	if _, ok := c[k1]; !ok {
		return 0, false
	}

	if _, ok := c[k1][k2]; !ok {
		return 0, false
	}

	v, ok := c[k1][k2][k3]
	return v, ok
}

func (c lib_Float643ToFloat64Cache) Set(k1, k2, k3 float64, v float64) float64 {
	if _, ok := c[k1]; !ok {
		c[k1] = map[float64]map[float64]float64{}
	}
	if _, ok := c[k1][k2]; !ok {
		c[k1][k2] = map[float64]float64{}
	}
	c[k1][k2][k3] = v
	return v
}

func lib_SumFloat64ByFloat64(values []float64, f func(v float64) float64) float64 {
	var sum float64 = 0
	for _, value := range values {
		sum += f(value)
	}
	return sum
}

func lib_Float64SliceToFloat64Slice(values []float64) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, float64(value))
	}
	return
}

func lib_MapFloat64SliceToFloat64(values [][]float64, f func(v []float64) float64) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapFloat64Slice2ToFloat64(values [][][]float64, f func(v [][]float64) float64) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MaxFloat64ByFloat64Slice(values [][]float64, f func(vs []float64) float64) (max float64, err error) {
	return lib_MaxFloat64(lib_MapFloat64SliceToFloat64(values, f))
}

func lib_MaxFloat64ByFloat64Slice2(values [][][]float64, f func(vs [][]float64) float64) (max float64, err error) {
	return lib_MaxFloat64(lib_MapFloat64Slice2ToFloat64(values, f))
}

func lib_ReduceRune(values []rune, f func(acc, cur rune) rune, initial rune) (newValue rune) {
	newValue = initial
	for _, value := range values {
		newValue = f(newValue, value)
	}
	return
}

func lib_ReduceRuneSlice(values [][]rune, f func(acc rune, cur []rune) rune, initial rune) (newValue rune) {
	newValue = initial
	for _, value := range values {
		newValue = f(newValue, value)
	}
	return
}

func lib_CopyRune(values []rune) []rune {
	dst := make([]rune, len(values))
	copy(dst, values)
	return dst
}

func lib_CopyRuneSlice(values [][]rune) [][]rune {
	dst := make([][]rune, len(values))
	for i, value := range values {
		dst[i] = lib_CopyRune(value)
	}
	return dst
}

func lib_ReverseRune(values []rune) []rune {
	newValues := lib_CopyRune(values)
	for i, j := 0, len(values)-1; i < j; i, j = i+1, j-1 {
		newValues[i], newValues[j] = values[j], values[i]
	}
	return newValues
}

func lib_ReverseRuneSlice(values [][]rune) [][]rune {
	newValues := lib_CopyRuneSlice(values)
	for i, j := 0, len(values)-1; i < j; i, j = i+1, j-1 {
		newValues[i], newValues[j] = values[j], values[i]
	}
	return newValues
}

func lib_MapRune(values []rune, f func(v rune) rune) (newValues []rune) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapRuneSlice(values [][]rune, f func(v []rune) []rune) (newValues [][]rune) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapTypeRune(values [][]rune, f func(v []rune) rune) (newValues []rune) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_ZipRune(valuesList ...[]rune) (newValuesList [][]rune, err error) {
	if len(valuesList) == 0 {
		return nil, errors.New("empty values list are given to ZipRune")
	}
	valuesLen := len(valuesList[0])
	for _, values := range valuesList {
		if (len(values)) != valuesLen {
			return nil, errors.New("different lengths values are given to ZipRune")
		}
	}

	for i := 0; i < valuesLen; i++ {
		var newValues []rune
		for _, values := range valuesList {
			newValues = append(newValues, values[i])
		}
		newValuesList = append(newValuesList, newValues)
	}
	return
}

func lib_SomeRune(values []rune, f func(v rune) bool) bool {
	for _, value := range values {
		if f(value) {
			return true
		}
	}
	return false
}

func lib_SomeRuneSlice(valuesList [][]rune, f func(v []rune) bool) bool {
	for _, values := range valuesList {
		if f(values) {
			return true
		}
	}
	return false
}

func lib_EveryRune(values []rune, f func(v rune) bool) bool {
	for _, value := range values {
		if !f(value) {
			return false
		}
	}
	return true
}

func lib_EveryRuneSlice(valuesList [][]rune, f func(v []rune) bool) bool {
	for _, values := range valuesList {
		if !f(values) {
			return false
		}
	}
	return true
}

func lib_ChunkRuneByBits(values []rune, bits []bool) (newValues [][]rune, err error) {
	if len(values) != len(bits)+1 {
		return nil, errors.New(fmt.Sprintf("there are different length between values(%d) and bits(%d)", len(values), len(bits)))
	}

	var chunk []rune
	for i, bit := range bits {
		chunk = append(chunk, values[i])
		if bit {
			newValues = append(newValues, chunk)
			chunk = []rune{}
		}
	}
	chunk = append(chunk, values[len(values)-1])
	newValues = append(newValues, chunk)
	return
}

func lib_UnsetRune(values []rune, i int) ([]rune, error) {
	if i < 0 {
		return nil, fmt.Errorf("negative number index is given: %d", i)
	}

	if i >= len(values) {
		return nil, fmt.Errorf("index(%d) is larger than slice length(%d)", i, len(values))
	}

	if len(values) == 1 {
		return []rune{}, nil
	}

	if i == len(values)-1 {
		return values[:len(values)-1], nil
	}

	newValues := make([]rune, len(values))
	copy(newValues, values)
	return append(newValues[:i], newValues[i+1:]...), nil
}

func lib_RuneCombination(values []rune, r int) (combinations [][]rune, err error) {
	if r == 1 {
		for _, value := range values {
			combinations = append(combinations, []rune{value})
		}
		return
	}

	for i := range values {
		newValues := values
		for j := 0; j <= i; j++ {
			newValues = newValues[1:]
		}
		partialCombinations, err := lib_RuneCombination(newValues, r-1)
		if err != nil {
			return nil, err
		}

		for _, pc := range partialCombinations {
			newC := append(pc, values[i])
			combinations = append(combinations, newC)
		}
	}
	return
}

func lib_RunePermutation(values []rune, r int) (permutations [][]rune) {
	if r == 1 {
		for _, value := range values {
			permutations = append(permutations, []rune{value})
		}
		return
	}
	for i := range values {
		newValues := lib_RuneRemoveFromSlice(values, i)
		for _, pc := range lib_RunePermutation(newValues, r-1) {
			newC := append(pc, values[i])
			permutations = append(permutations, newC)
		}
	}
	return
}

func lib_RuneSliceCombination(values [][]rune, r int) (combinations [][][]rune, err error) {
	if r == 1 {
		for _, value := range values {
			combinations = append(combinations, [][]rune{value})
		}
		return
	}

	for i := range values {
		newValues := values
		for j := 0; j <= i; j++ {
			newValues = newValues[1:]
			if err != nil {
				return nil, err
			}
		}
		partialCombinations, err := lib_RuneSliceCombination(newValues, r-1)
		if err != nil {
			return nil, err
		}

		for _, pc := range partialCombinations {
			newC := append(pc, values[i])
			combinations = append(combinations, newC)
		}
	}
	return
}

func lib_RuneRemoveFromSlice(slice []rune, i int) []rune {
	n := make([]rune, len(slice))
	copy(n, slice)
	return append(n[:i], n[i+1:]...)
}

func lib_TernaryOPRune(ok bool, v1, v2 rune) rune {
	if ok {
		return v1
	}
	return v2
}

type lib_UnionFindRune struct {
	nodes map[rune]rune
}

func lib_NewUnionFindRune(values []rune) *lib_UnionFindRune {
	m := map[rune]rune{}
	for _, v := range values {
		m[v] = v
	}
	return &lib_UnionFindRune{nodes: m}
}

func (u *lib_UnionFindRune) GetRoot(value rune) (rune, int) {
	v := value
	newV := u.nodes[v]
	cnt := 0
	for newV != v {
		cnt++
		oldV := v
		v = newV
		newV = u.nodes[newV]
		u.nodes[oldV] = newV
	}
	return newV, cnt
}

func (u *lib_UnionFindRune) Unite(v1, v2 rune) (rune, bool) {
	v1Root, v1HopNum := u.GetRoot(v1)
	v2Root, v2HopNum := u.GetRoot(v2)
	if v1Root == v2Root {
		return v1Root, false
	}
	if v1HopNum >= v2HopNum {
		u.nodes[v2Root] = v1Root
		return v1Root, true
	}
	u.nodes[v1Root] = v2Root
	return v2Root, true
}

func (u *lib_UnionFindRune) IsSameGroup(v1, v2 rune) bool {
	v1Root, _ := u.GetRoot(v1)
	v2Root, _ := u.GetRoot(v2)
	return v1Root == v2Root
}

func lib_MemoizeRune(f func(v rune) rune) func(v rune) rune {
	cache := map[rune]rune{}
	return func(v rune) rune {
		if cachedResult, ok := cache[v]; ok {
			return cachedResult
		}
		result := f(v)
		cache[v] = result
		return result
	}
}

func lib_ReduceString(values []string, f func(acc, cur string) string, initial string) (newValue string) {
	newValue = initial
	for _, value := range values {
		newValue = f(newValue, value)
	}
	return
}

func lib_ReduceStringSlice(values [][]string, f func(acc string, cur []string) string, initial string) (newValue string) {
	newValue = initial
	for _, value := range values {
		newValue = f(newValue, value)
	}
	return
}

func lib_CopyString(values []string) []string {
	dst := make([]string, len(values))
	copy(dst, values)
	return dst
}

func lib_CopyStringSlice(values [][]string) [][]string {
	dst := make([][]string, len(values))
	for i, value := range values {
		dst[i] = lib_CopyString(value)
	}
	return dst
}

func lib_ReverseString(values []string) []string {
	newValues := lib_CopyString(values)
	for i, j := 0, len(values)-1; i < j; i, j = i+1, j-1 {
		newValues[i], newValues[j] = values[j], values[i]
	}
	return newValues
}

func lib_ReverseStringSlice(values [][]string) [][]string {
	newValues := lib_CopyStringSlice(values)
	for i, j := 0, len(values)-1; i < j; i, j = i+1, j-1 {
		newValues[i], newValues[j] = values[j], values[i]
	}
	return newValues
}

func lib_MapString(values []string, f func(v string) string) (newValues []string) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapStringSlice(values [][]string, f func(v []string) []string) (newValues [][]string) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapTypeString(values [][]string, f func(v []string) string) (newValues []string) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_ZipString(valuesList ...[]string) (newValuesList [][]string, err error) {
	if len(valuesList) == 0 {
		return nil, errors.New("empty values list are given to ZipString")
	}
	valuesLen := len(valuesList[0])
	for _, values := range valuesList {
		if (len(values)) != valuesLen {
			return nil, errors.New("different lengths values are given to ZipString")
		}
	}

	for i := 0; i < valuesLen; i++ {
		var newValues []string
		for _, values := range valuesList {
			newValues = append(newValues, values[i])
		}
		newValuesList = append(newValuesList, newValues)
	}
	return
}

func lib_SomeString(values []string, f func(v string) bool) bool {
	for _, value := range values {
		if f(value) {
			return true
		}
	}
	return false
}

func lib_SomeStringSlice(valuesList [][]string, f func(v []string) bool) bool {
	for _, values := range valuesList {
		if f(values) {
			return true
		}
	}
	return false
}

func lib_EveryString(values []string, f func(v string) bool) bool {
	for _, value := range values {
		if !f(value) {
			return false
		}
	}
	return true
}

func lib_EveryStringSlice(valuesList [][]string, f func(v []string) bool) bool {
	for _, values := range valuesList {
		if !f(values) {
			return false
		}
	}
	return true
}

func lib_ChunkStringByBits(values []string, bits []bool) (newValues [][]string, err error) {
	if len(values) != len(bits)+1 {
		return nil, errors.New(fmt.Sprintf("there are different length between values(%d) and bits(%d)", len(values), len(bits)))
	}

	var chunk []string
	for i, bit := range bits {
		chunk = append(chunk, values[i])
		if bit {
			newValues = append(newValues, chunk)
			chunk = []string{}
		}
	}
	chunk = append(chunk, values[len(values)-1])
	newValues = append(newValues, chunk)
	return
}

func lib_UnsetString(values []string, i int) ([]string, error) {
	if i < 0 {
		return nil, fmt.Errorf("negative number index is given: %d", i)
	}

	if i >= len(values) {
		return nil, fmt.Errorf("index(%d) is larger than slice length(%d)", i, len(values))
	}

	if len(values) == 1 {
		return []string{}, nil
	}

	if i == len(values)-1 {
		return values[:len(values)-1], nil
	}

	newValues := make([]string, len(values))
	copy(newValues, values)
	return append(newValues[:i], newValues[i+1:]...), nil
}

func lib_StringCombination(values []string, r int) (combinations [][]string, err error) {
	if r == 1 {
		for _, value := range values {
			combinations = append(combinations, []string{value})
		}
		return
	}

	for i := range values {
		newValues := values
		for j := 0; j <= i; j++ {
			newValues = newValues[1:]
		}
		partialCombinations, err := lib_StringCombination(newValues, r-1)
		if err != nil {
			return nil, err
		}

		for _, pc := range partialCombinations {
			newC := append(pc, values[i])
			combinations = append(combinations, newC)
		}
	}
	return
}

func lib_StringPermutation(values []string, r int) (permutations [][]string) {
	if r == 1 {
		for _, value := range values {
			permutations = append(permutations, []string{value})
		}
		return
	}
	for i := range values {
		newValues := lib_StringRemoveFromSlice(values, i)
		for _, pc := range lib_StringPermutation(newValues, r-1) {
			newC := append(pc, values[i])
			permutations = append(permutations, newC)
		}
	}
	return
}

func lib_StringSliceCombination(values [][]string, r int) (combinations [][][]string, err error) {
	if r == 1 {
		for _, value := range values {
			combinations = append(combinations, [][]string{value})
		}
		return
	}

	for i := range values {
		newValues := values
		for j := 0; j <= i; j++ {
			newValues = newValues[1:]
			if err != nil {
				return nil, err
			}
		}
		partialCombinations, err := lib_StringSliceCombination(newValues, r-1)
		if err != nil {
			return nil, err
		}

		for _, pc := range partialCombinations {
			newC := append(pc, values[i])
			combinations = append(combinations, newC)
		}
	}
	return
}

func lib_StringRemoveFromSlice(slice []string, i int) []string {
	n := make([]string, len(slice))
	copy(n, slice)
	return append(n[:i], n[i+1:]...)
}

func lib_TernaryOPString(ok bool, v1, v2 string) string {
	if ok {
		return v1
	}
	return v2
}

type lib_UnionFindString struct {
	nodes map[string]string
}

func lib_NewUnionFindString(values []string) *lib_UnionFindString {
	m := map[string]string{}
	for _, v := range values {
		m[v] = v
	}
	return &lib_UnionFindString{nodes: m}
}

func (u *lib_UnionFindString) GetRoot(value string) (string, int) {
	v := value
	newV := u.nodes[v]
	cnt := 0
	for newV != v {
		cnt++
		oldV := v
		v = newV
		newV = u.nodes[newV]
		u.nodes[oldV] = newV
	}
	return newV, cnt
}

func (u *lib_UnionFindString) Unite(v1, v2 string) (string, bool) {
	v1Root, v1HopNum := u.GetRoot(v1)
	v2Root, v2HopNum := u.GetRoot(v2)
	if v1Root == v2Root {
		return v1Root, false
	}
	if v1HopNum >= v2HopNum {
		u.nodes[v2Root] = v1Root
		return v1Root, true
	}
	u.nodes[v1Root] = v2Root
	return v2Root, true
}

func (u *lib_UnionFindString) IsSameGroup(v1, v2 string) bool {
	v1Root, _ := u.GetRoot(v1)
	v2Root, _ := u.GetRoot(v2)
	return v1Root == v2Root
}

func lib_MemoizeString(f func(v string) string) func(v string) string {
	cache := map[string]string{}
	return func(v string) string {
		if cachedResult, ok := cache[v]; ok {
			return cachedResult
		}
		result := f(v)
		cache[v] = result
		return result
	}
}

func lib_ReduceInt(values []int, f func(acc, cur int) int, initial int) (newValue int) {
	newValue = initial
	for _, value := range values {
		newValue = f(newValue, value)
	}
	return
}

func lib_ReduceIntSlice(values [][]int, f func(acc int, cur []int) int, initial int) (newValue int) {
	newValue = initial
	for _, value := range values {
		newValue = f(newValue, value)
	}
	return
}

func lib_CopyInt(values []int) []int {
	dst := make([]int, len(values))
	copy(dst, values)
	return dst
}

func lib_CopyIntSlice(values [][]int) [][]int {
	dst := make([][]int, len(values))
	for i, value := range values {
		dst[i] = lib_CopyInt(value)
	}
	return dst
}

func lib_ReverseInt(values []int) []int {
	newValues := lib_CopyInt(values)
	for i, j := 0, len(values)-1; i < j; i, j = i+1, j-1 {
		newValues[i], newValues[j] = values[j], values[i]
	}
	return newValues
}

func lib_ReverseIntSlice(values [][]int) [][]int {
	newValues := lib_CopyIntSlice(values)
	for i, j := 0, len(values)-1; i < j; i, j = i+1, j-1 {
		newValues[i], newValues[j] = values[j], values[i]
	}
	return newValues
}

func lib_MapInt(values []int, f func(v int) int) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapIntSlice(values [][]int, f func(v []int) []int) (newValues [][]int) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapTypeInt(values [][]int, f func(v []int) int) (newValues []int) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_ZipInt(valuesList ...[]int) (newValuesList [][]int, err error) {
	if len(valuesList) == 0 {
		return nil, errors.New("empty values list are given to ZipInt")
	}
	valuesLen := len(valuesList[0])
	for _, values := range valuesList {
		if (len(values)) != valuesLen {
			return nil, errors.New("different lengths values are given to ZipInt")
		}
	}

	for i := 0; i < valuesLen; i++ {
		var newValues []int
		for _, values := range valuesList {
			newValues = append(newValues, values[i])
		}
		newValuesList = append(newValuesList, newValues)
	}
	return
}

func lib_SomeInt(values []int, f func(v int) bool) bool {
	for _, value := range values {
		if f(value) {
			return true
		}
	}
	return false
}

func lib_SomeIntSlice(valuesList [][]int, f func(v []int) bool) bool {
	for _, values := range valuesList {
		if f(values) {
			return true
		}
	}
	return false
}

func lib_EveryInt(values []int, f func(v int) bool) bool {
	for _, value := range values {
		if !f(value) {
			return false
		}
	}
	return true
}

func lib_EveryIntSlice(valuesList [][]int, f func(v []int) bool) bool {
	for _, values := range valuesList {
		if !f(values) {
			return false
		}
	}
	return true
}

func lib_ChunkIntByBits(values []int, bits []bool) (newValues [][]int, err error) {
	if len(values) != len(bits)+1 {
		return nil, errors.New(fmt.Sprintf("there are different length between values(%d) and bits(%d)", len(values), len(bits)))
	}

	var chunk []int
	for i, bit := range bits {
		chunk = append(chunk, values[i])
		if bit {
			newValues = append(newValues, chunk)
			chunk = []int{}
		}
	}
	chunk = append(chunk, values[len(values)-1])
	newValues = append(newValues, chunk)
	return
}

func lib_UnsetInt(values []int, i int) ([]int, error) {
	if i < 0 {
		return nil, fmt.Errorf("negative number index is given: %d", i)
	}

	if i >= len(values) {
		return nil, fmt.Errorf("index(%d) is larger than slice length(%d)", i, len(values))
	}

	if len(values) == 1 {
		return []int{}, nil
	}

	if i == len(values)-1 {
		return values[:len(values)-1], nil
	}

	newValues := make([]int, len(values))
	copy(newValues, values)
	return append(newValues[:i], newValues[i+1:]...), nil
}

func lib_IntCombination(values []int, r int) (combinations [][]int, err error) {
	if r == 1 {
		for _, value := range values {
			combinations = append(combinations, []int{value})
		}
		return
	}

	for i := range values {
		newValues := values
		for j := 0; j <= i; j++ {
			newValues = newValues[1:]
		}
		partialCombinations, err := lib_IntCombination(newValues, r-1)
		if err != nil {
			return nil, err
		}

		for _, pc := range partialCombinations {
			newC := append(pc, values[i])
			combinations = append(combinations, newC)
		}
	}
	return
}

func lib_IntPermutation(values []int, r int) (permutations [][]int) {
	if r == 1 {
		for _, value := range values {
			permutations = append(permutations, []int{value})
		}
		return
	}
	for i := range values {
		newValues := lib_IntRemoveFromSlice(values, i)
		for _, pc := range lib_IntPermutation(newValues, r-1) {
			newC := append(pc, values[i])
			permutations = append(permutations, newC)
		}
	}
	return
}

func lib_IntSliceCombination(values [][]int, r int) (combinations [][][]int, err error) {
	if r == 1 {
		for _, value := range values {
			combinations = append(combinations, [][]int{value})
		}
		return
	}

	for i := range values {
		newValues := values
		for j := 0; j <= i; j++ {
			newValues = newValues[1:]
			if err != nil {
				return nil, err
			}
		}
		partialCombinations, err := lib_IntSliceCombination(newValues, r-1)
		if err != nil {
			return nil, err
		}

		for _, pc := range partialCombinations {
			newC := append(pc, values[i])
			combinations = append(combinations, newC)
		}
	}
	return
}

func lib_IntRemoveFromSlice(slice []int, i int) []int {
	n := make([]int, len(slice))
	copy(n, slice)
	return append(n[:i], n[i+1:]...)
}

func lib_TernaryOPInt(ok bool, v1, v2 int) int {
	if ok {
		return v1
	}
	return v2
}

type lib_UnionFindInt struct {
	nodes map[int]int
}

func lib_NewUnionFindInt(values []int) *lib_UnionFindInt {
	m := map[int]int{}
	for _, v := range values {
		m[v] = v
	}
	return &lib_UnionFindInt{nodes: m}
}

func (u *lib_UnionFindInt) GetRoot(value int) (int, int) {
	v := value
	newV := u.nodes[v]
	cnt := 0
	for newV != v {
		cnt++
		oldV := v
		v = newV
		newV = u.nodes[newV]
		u.nodes[oldV] = newV
	}
	return newV, cnt
}

func (u *lib_UnionFindInt) Unite(v1, v2 int) (int, bool) {
	v1Root, v1HopNum := u.GetRoot(v1)
	v2Root, v2HopNum := u.GetRoot(v2)
	if v1Root == v2Root {
		return v1Root, false
	}
	if v1HopNum >= v2HopNum {
		u.nodes[v2Root] = v1Root
		return v1Root, true
	}
	u.nodes[v1Root] = v2Root
	return v2Root, true
}

func (u *lib_UnionFindInt) IsSameGroup(v1, v2 int) bool {
	v1Root, _ := u.GetRoot(v1)
	v2Root, _ := u.GetRoot(v2)
	return v1Root == v2Root
}

func lib_MemoizeInt(f func(v int) int) func(v int) int {
	cache := map[int]int{}
	return func(v int) int {
		if cachedResult, ok := cache[v]; ok {
			return cachedResult
		}
		result := f(v)
		cache[v] = result
		return result
	}
}

func lib_ReduceInt8(values []int8, f func(acc, cur int8) int8, initial int8) (newValue int8) {
	newValue = initial
	for _, value := range values {
		newValue = f(newValue, value)
	}
	return
}

func lib_ReduceInt8Slice(values [][]int8, f func(acc int8, cur []int8) int8, initial int8) (newValue int8) {
	newValue = initial
	for _, value := range values {
		newValue = f(newValue, value)
	}
	return
}

func lib_CopyInt8(values []int8) []int8 {
	dst := make([]int8, len(values))
	copy(dst, values)
	return dst
}

func lib_CopyInt8Slice(values [][]int8) [][]int8 {
	dst := make([][]int8, len(values))
	for i, value := range values {
		dst[i] = lib_CopyInt8(value)
	}
	return dst
}

func lib_ReverseInt8(values []int8) []int8 {
	newValues := lib_CopyInt8(values)
	for i, j := 0, len(values)-1; i < j; i, j = i+1, j-1 {
		newValues[i], newValues[j] = values[j], values[i]
	}
	return newValues
}

func lib_ReverseInt8Slice(values [][]int8) [][]int8 {
	newValues := lib_CopyInt8Slice(values)
	for i, j := 0, len(values)-1; i < j; i, j = i+1, j-1 {
		newValues[i], newValues[j] = values[j], values[i]
	}
	return newValues
}

func lib_MapInt8(values []int8, f func(v int8) int8) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt8Slice(values [][]int8, f func(v []int8) []int8) (newValues [][]int8) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapTypeInt8(values [][]int8, f func(v []int8) int8) (newValues []int8) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_ZipInt8(valuesList ...[]int8) (newValuesList [][]int8, err error) {
	if len(valuesList) == 0 {
		return nil, errors.New("empty values list are given to ZipInt8")
	}
	valuesLen := len(valuesList[0])
	for _, values := range valuesList {
		if (len(values)) != valuesLen {
			return nil, errors.New("different lengths values are given to ZipInt8")
		}
	}

	for i := 0; i < valuesLen; i++ {
		var newValues []int8
		for _, values := range valuesList {
			newValues = append(newValues, values[i])
		}
		newValuesList = append(newValuesList, newValues)
	}
	return
}

func lib_SomeInt8(values []int8, f func(v int8) bool) bool {
	for _, value := range values {
		if f(value) {
			return true
		}
	}
	return false
}

func lib_SomeInt8Slice(valuesList [][]int8, f func(v []int8) bool) bool {
	for _, values := range valuesList {
		if f(values) {
			return true
		}
	}
	return false
}

func lib_EveryInt8(values []int8, f func(v int8) bool) bool {
	for _, value := range values {
		if !f(value) {
			return false
		}
	}
	return true
}

func lib_EveryInt8Slice(valuesList [][]int8, f func(v []int8) bool) bool {
	for _, values := range valuesList {
		if !f(values) {
			return false
		}
	}
	return true
}

func lib_ChunkInt8ByBits(values []int8, bits []bool) (newValues [][]int8, err error) {
	if len(values) != len(bits)+1 {
		return nil, errors.New(fmt.Sprintf("there are different length between values(%d) and bits(%d)", len(values), len(bits)))
	}

	var chunk []int8
	for i, bit := range bits {
		chunk = append(chunk, values[i])
		if bit {
			newValues = append(newValues, chunk)
			chunk = []int8{}
		}
	}
	chunk = append(chunk, values[len(values)-1])
	newValues = append(newValues, chunk)
	return
}

func lib_UnsetInt8(values []int8, i int) ([]int8, error) {
	if i < 0 {
		return nil, fmt.Errorf("negative number index is given: %d", i)
	}

	if i >= len(values) {
		return nil, fmt.Errorf("index(%d) is larger than slice length(%d)", i, len(values))
	}

	if len(values) == 1 {
		return []int8{}, nil
	}

	if i == len(values)-1 {
		return values[:len(values)-1], nil
	}

	newValues := make([]int8, len(values))
	copy(newValues, values)
	return append(newValues[:i], newValues[i+1:]...), nil
}

func lib_Int8Combination(values []int8, r int) (combinations [][]int8, err error) {
	if r == 1 {
		for _, value := range values {
			combinations = append(combinations, []int8{value})
		}
		return
	}

	for i := range values {
		newValues := values
		for j := 0; j <= i; j++ {
			newValues = newValues[1:]
		}
		partialCombinations, err := lib_Int8Combination(newValues, r-1)
		if err != nil {
			return nil, err
		}

		for _, pc := range partialCombinations {
			newC := append(pc, values[i])
			combinations = append(combinations, newC)
		}
	}
	return
}

func lib_Int8Permutation(values []int8, r int) (permutations [][]int8) {
	if r == 1 {
		for _, value := range values {
			permutations = append(permutations, []int8{value})
		}
		return
	}
	for i := range values {
		newValues := lib_Int8RemoveFromSlice(values, i)
		for _, pc := range lib_Int8Permutation(newValues, r-1) {
			newC := append(pc, values[i])
			permutations = append(permutations, newC)
		}
	}
	return
}

func lib_Int8SliceCombination(values [][]int8, r int) (combinations [][][]int8, err error) {
	if r == 1 {
		for _, value := range values {
			combinations = append(combinations, [][]int8{value})
		}
		return
	}

	for i := range values {
		newValues := values
		for j := 0; j <= i; j++ {
			newValues = newValues[1:]
			if err != nil {
				return nil, err
			}
		}
		partialCombinations, err := lib_Int8SliceCombination(newValues, r-1)
		if err != nil {
			return nil, err
		}

		for _, pc := range partialCombinations {
			newC := append(pc, values[i])
			combinations = append(combinations, newC)
		}
	}
	return
}

func lib_Int8RemoveFromSlice(slice []int8, i int) []int8 {
	n := make([]int8, len(slice))
	copy(n, slice)
	return append(n[:i], n[i+1:]...)
}

func lib_TernaryOPInt8(ok bool, v1, v2 int8) int8 {
	if ok {
		return v1
	}
	return v2
}

type lib_UnionFindInt8 struct {
	nodes map[int8]int8
}

func lib_NewUnionFindInt8(values []int8) *lib_UnionFindInt8 {
	m := map[int8]int8{}
	for _, v := range values {
		m[v] = v
	}
	return &lib_UnionFindInt8{nodes: m}
}

func (u *lib_UnionFindInt8) GetRoot(value int8) (int8, int) {
	v := value
	newV := u.nodes[v]
	cnt := 0
	for newV != v {
		cnt++
		oldV := v
		v = newV
		newV = u.nodes[newV]
		u.nodes[oldV] = newV
	}
	return newV, cnt
}

func (u *lib_UnionFindInt8) Unite(v1, v2 int8) (int8, bool) {
	v1Root, v1HopNum := u.GetRoot(v1)
	v2Root, v2HopNum := u.GetRoot(v2)
	if v1Root == v2Root {
		return v1Root, false
	}
	if v1HopNum >= v2HopNum {
		u.nodes[v2Root] = v1Root
		return v1Root, true
	}
	u.nodes[v1Root] = v2Root
	return v2Root, true
}

func (u *lib_UnionFindInt8) IsSameGroup(v1, v2 int8) bool {
	v1Root, _ := u.GetRoot(v1)
	v2Root, _ := u.GetRoot(v2)
	return v1Root == v2Root
}

func lib_MemoizeInt8(f func(v int8) int8) func(v int8) int8 {
	cache := map[int8]int8{}
	return func(v int8) int8 {
		if cachedResult, ok := cache[v]; ok {
			return cachedResult
		}
		result := f(v)
		cache[v] = result
		return result
	}
}

func lib_ReduceInt16(values []int16, f func(acc, cur int16) int16, initial int16) (newValue int16) {
	newValue = initial
	for _, value := range values {
		newValue = f(newValue, value)
	}
	return
}

func lib_ReduceInt16Slice(values [][]int16, f func(acc int16, cur []int16) int16, initial int16) (newValue int16) {
	newValue = initial
	for _, value := range values {
		newValue = f(newValue, value)
	}
	return
}

func lib_CopyInt16(values []int16) []int16 {
	dst := make([]int16, len(values))
	copy(dst, values)
	return dst
}

func lib_CopyInt16Slice(values [][]int16) [][]int16 {
	dst := make([][]int16, len(values))
	for i, value := range values {
		dst[i] = lib_CopyInt16(value)
	}
	return dst
}

func lib_ReverseInt16(values []int16) []int16 {
	newValues := lib_CopyInt16(values)
	for i, j := 0, len(values)-1; i < j; i, j = i+1, j-1 {
		newValues[i], newValues[j] = values[j], values[i]
	}
	return newValues
}

func lib_ReverseInt16Slice(values [][]int16) [][]int16 {
	newValues := lib_CopyInt16Slice(values)
	for i, j := 0, len(values)-1; i < j; i, j = i+1, j-1 {
		newValues[i], newValues[j] = values[j], values[i]
	}
	return newValues
}

func lib_MapInt16(values []int16, f func(v int16) int16) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt16Slice(values [][]int16, f func(v []int16) []int16) (newValues [][]int16) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapTypeInt16(values [][]int16, f func(v []int16) int16) (newValues []int16) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_ZipInt16(valuesList ...[]int16) (newValuesList [][]int16, err error) {
	if len(valuesList) == 0 {
		return nil, errors.New("empty values list are given to ZipInt16")
	}
	valuesLen := len(valuesList[0])
	for _, values := range valuesList {
		if (len(values)) != valuesLen {
			return nil, errors.New("different lengths values are given to ZipInt16")
		}
	}

	for i := 0; i < valuesLen; i++ {
		var newValues []int16
		for _, values := range valuesList {
			newValues = append(newValues, values[i])
		}
		newValuesList = append(newValuesList, newValues)
	}
	return
}

func lib_SomeInt16(values []int16, f func(v int16) bool) bool {
	for _, value := range values {
		if f(value) {
			return true
		}
	}
	return false
}

func lib_SomeInt16Slice(valuesList [][]int16, f func(v []int16) bool) bool {
	for _, values := range valuesList {
		if f(values) {
			return true
		}
	}
	return false
}

func lib_EveryInt16(values []int16, f func(v int16) bool) bool {
	for _, value := range values {
		if !f(value) {
			return false
		}
	}
	return true
}

func lib_EveryInt16Slice(valuesList [][]int16, f func(v []int16) bool) bool {
	for _, values := range valuesList {
		if !f(values) {
			return false
		}
	}
	return true
}

func lib_ChunkInt16ByBits(values []int16, bits []bool) (newValues [][]int16, err error) {
	if len(values) != len(bits)+1 {
		return nil, errors.New(fmt.Sprintf("there are different length between values(%d) and bits(%d)", len(values), len(bits)))
	}

	var chunk []int16
	for i, bit := range bits {
		chunk = append(chunk, values[i])
		if bit {
			newValues = append(newValues, chunk)
			chunk = []int16{}
		}
	}
	chunk = append(chunk, values[len(values)-1])
	newValues = append(newValues, chunk)
	return
}

func lib_UnsetInt16(values []int16, i int) ([]int16, error) {
	if i < 0 {
		return nil, fmt.Errorf("negative number index is given: %d", i)
	}

	if i >= len(values) {
		return nil, fmt.Errorf("index(%d) is larger than slice length(%d)", i, len(values))
	}

	if len(values) == 1 {
		return []int16{}, nil
	}

	if i == len(values)-1 {
		return values[:len(values)-1], nil
	}

	newValues := make([]int16, len(values))
	copy(newValues, values)
	return append(newValues[:i], newValues[i+1:]...), nil
}

func lib_Int16Combination(values []int16, r int) (combinations [][]int16, err error) {
	if r == 1 {
		for _, value := range values {
			combinations = append(combinations, []int16{value})
		}
		return
	}

	for i := range values {
		newValues := values
		for j := 0; j <= i; j++ {
			newValues = newValues[1:]
		}
		partialCombinations, err := lib_Int16Combination(newValues, r-1)
		if err != nil {
			return nil, err
		}

		for _, pc := range partialCombinations {
			newC := append(pc, values[i])
			combinations = append(combinations, newC)
		}
	}
	return
}

func lib_Int16Permutation(values []int16, r int) (permutations [][]int16) {
	if r == 1 {
		for _, value := range values {
			permutations = append(permutations, []int16{value})
		}
		return
	}
	for i := range values {
		newValues := lib_Int16RemoveFromSlice(values, i)
		for _, pc := range lib_Int16Permutation(newValues, r-1) {
			newC := append(pc, values[i])
			permutations = append(permutations, newC)
		}
	}
	return
}

func lib_Int16SliceCombination(values [][]int16, r int) (combinations [][][]int16, err error) {
	if r == 1 {
		for _, value := range values {
			combinations = append(combinations, [][]int16{value})
		}
		return
	}

	for i := range values {
		newValues := values
		for j := 0; j <= i; j++ {
			newValues = newValues[1:]
			if err != nil {
				return nil, err
			}
		}
		partialCombinations, err := lib_Int16SliceCombination(newValues, r-1)
		if err != nil {
			return nil, err
		}

		for _, pc := range partialCombinations {
			newC := append(pc, values[i])
			combinations = append(combinations, newC)
		}
	}
	return
}

func lib_Int16RemoveFromSlice(slice []int16, i int) []int16 {
	n := make([]int16, len(slice))
	copy(n, slice)
	return append(n[:i], n[i+1:]...)
}

func lib_TernaryOPInt16(ok bool, v1, v2 int16) int16 {
	if ok {
		return v1
	}
	return v2
}

type lib_UnionFindInt16 struct {
	nodes map[int16]int16
}

func lib_NewUnionFindInt16(values []int16) *lib_UnionFindInt16 {
	m := map[int16]int16{}
	for _, v := range values {
		m[v] = v
	}
	return &lib_UnionFindInt16{nodes: m}
}

func (u *lib_UnionFindInt16) GetRoot(value int16) (int16, int) {
	v := value
	newV := u.nodes[v]
	cnt := 0
	for newV != v {
		cnt++
		oldV := v
		v = newV
		newV = u.nodes[newV]
		u.nodes[oldV] = newV
	}
	return newV, cnt
}

func (u *lib_UnionFindInt16) Unite(v1, v2 int16) (int16, bool) {
	v1Root, v1HopNum := u.GetRoot(v1)
	v2Root, v2HopNum := u.GetRoot(v2)
	if v1Root == v2Root {
		return v1Root, false
	}
	if v1HopNum >= v2HopNum {
		u.nodes[v2Root] = v1Root
		return v1Root, true
	}
	u.nodes[v1Root] = v2Root
	return v2Root, true
}

func (u *lib_UnionFindInt16) IsSameGroup(v1, v2 int16) bool {
	v1Root, _ := u.GetRoot(v1)
	v2Root, _ := u.GetRoot(v2)
	return v1Root == v2Root
}

func lib_MemoizeInt16(f func(v int16) int16) func(v int16) int16 {
	cache := map[int16]int16{}
	return func(v int16) int16 {
		if cachedResult, ok := cache[v]; ok {
			return cachedResult
		}
		result := f(v)
		cache[v] = result
		return result
	}
}

func lib_ReduceInt32(values []int32, f func(acc, cur int32) int32, initial int32) (newValue int32) {
	newValue = initial
	for _, value := range values {
		newValue = f(newValue, value)
	}
	return
}

func lib_ReduceInt32Slice(values [][]int32, f func(acc int32, cur []int32) int32, initial int32) (newValue int32) {
	newValue = initial
	for _, value := range values {
		newValue = f(newValue, value)
	}
	return
}

func lib_CopyInt32(values []int32) []int32 {
	dst := make([]int32, len(values))
	copy(dst, values)
	return dst
}

func lib_CopyInt32Slice(values [][]int32) [][]int32 {
	dst := make([][]int32, len(values))
	for i, value := range values {
		dst[i] = lib_CopyInt32(value)
	}
	return dst
}

func lib_ReverseInt32(values []int32) []int32 {
	newValues := lib_CopyInt32(values)
	for i, j := 0, len(values)-1; i < j; i, j = i+1, j-1 {
		newValues[i], newValues[j] = values[j], values[i]
	}
	return newValues
}

func lib_ReverseInt32Slice(values [][]int32) [][]int32 {
	newValues := lib_CopyInt32Slice(values)
	for i, j := 0, len(values)-1; i < j; i, j = i+1, j-1 {
		newValues[i], newValues[j] = values[j], values[i]
	}
	return newValues
}

func lib_MapInt32(values []int32, f func(v int32) int32) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt32Slice(values [][]int32, f func(v []int32) []int32) (newValues [][]int32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapTypeInt32(values [][]int32, f func(v []int32) int32) (newValues []int32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_ZipInt32(valuesList ...[]int32) (newValuesList [][]int32, err error) {
	if len(valuesList) == 0 {
		return nil, errors.New("empty values list are given to ZipInt32")
	}
	valuesLen := len(valuesList[0])
	for _, values := range valuesList {
		if (len(values)) != valuesLen {
			return nil, errors.New("different lengths values are given to ZipInt32")
		}
	}

	for i := 0; i < valuesLen; i++ {
		var newValues []int32
		for _, values := range valuesList {
			newValues = append(newValues, values[i])
		}
		newValuesList = append(newValuesList, newValues)
	}
	return
}

func lib_SomeInt32(values []int32, f func(v int32) bool) bool {
	for _, value := range values {
		if f(value) {
			return true
		}
	}
	return false
}

func lib_SomeInt32Slice(valuesList [][]int32, f func(v []int32) bool) bool {
	for _, values := range valuesList {
		if f(values) {
			return true
		}
	}
	return false
}

func lib_EveryInt32(values []int32, f func(v int32) bool) bool {
	for _, value := range values {
		if !f(value) {
			return false
		}
	}
	return true
}

func lib_EveryInt32Slice(valuesList [][]int32, f func(v []int32) bool) bool {
	for _, values := range valuesList {
		if !f(values) {
			return false
		}
	}
	return true
}

func lib_ChunkInt32ByBits(values []int32, bits []bool) (newValues [][]int32, err error) {
	if len(values) != len(bits)+1 {
		return nil, errors.New(fmt.Sprintf("there are different length between values(%d) and bits(%d)", len(values), len(bits)))
	}

	var chunk []int32
	for i, bit := range bits {
		chunk = append(chunk, values[i])
		if bit {
			newValues = append(newValues, chunk)
			chunk = []int32{}
		}
	}
	chunk = append(chunk, values[len(values)-1])
	newValues = append(newValues, chunk)
	return
}

func lib_UnsetInt32(values []int32, i int) ([]int32, error) {
	if i < 0 {
		return nil, fmt.Errorf("negative number index is given: %d", i)
	}

	if i >= len(values) {
		return nil, fmt.Errorf("index(%d) is larger than slice length(%d)", i, len(values))
	}

	if len(values) == 1 {
		return []int32{}, nil
	}

	if i == len(values)-1 {
		return values[:len(values)-1], nil
	}

	newValues := make([]int32, len(values))
	copy(newValues, values)
	return append(newValues[:i], newValues[i+1:]...), nil
}

func lib_Int32Combination(values []int32, r int) (combinations [][]int32, err error) {
	if r == 1 {
		for _, value := range values {
			combinations = append(combinations, []int32{value})
		}
		return
	}

	for i := range values {
		newValues := values
		for j := 0; j <= i; j++ {
			newValues = newValues[1:]
		}
		partialCombinations, err := lib_Int32Combination(newValues, r-1)
		if err != nil {
			return nil, err
		}

		for _, pc := range partialCombinations {
			newC := append(pc, values[i])
			combinations = append(combinations, newC)
		}
	}
	return
}

func lib_Int32Permutation(values []int32, r int) (permutations [][]int32) {
	if r == 1 {
		for _, value := range values {
			permutations = append(permutations, []int32{value})
		}
		return
	}
	for i := range values {
		newValues := lib_Int32RemoveFromSlice(values, i)
		for _, pc := range lib_Int32Permutation(newValues, r-1) {
			newC := append(pc, values[i])
			permutations = append(permutations, newC)
		}
	}
	return
}

func lib_Int32SliceCombination(values [][]int32, r int) (combinations [][][]int32, err error) {
	if r == 1 {
		for _, value := range values {
			combinations = append(combinations, [][]int32{value})
		}
		return
	}

	for i := range values {
		newValues := values
		for j := 0; j <= i; j++ {
			newValues = newValues[1:]
			if err != nil {
				return nil, err
			}
		}
		partialCombinations, err := lib_Int32SliceCombination(newValues, r-1)
		if err != nil {
			return nil, err
		}

		for _, pc := range partialCombinations {
			newC := append(pc, values[i])
			combinations = append(combinations, newC)
		}
	}
	return
}

func lib_Int32RemoveFromSlice(slice []int32, i int) []int32 {
	n := make([]int32, len(slice))
	copy(n, slice)
	return append(n[:i], n[i+1:]...)
}

func lib_TernaryOPInt32(ok bool, v1, v2 int32) int32 {
	if ok {
		return v1
	}
	return v2
}

type lib_UnionFindInt32 struct {
	nodes map[int32]int32
}

func lib_NewUnionFindInt32(values []int32) *lib_UnionFindInt32 {
	m := map[int32]int32{}
	for _, v := range values {
		m[v] = v
	}
	return &lib_UnionFindInt32{nodes: m}
}

func (u *lib_UnionFindInt32) GetRoot(value int32) (int32, int) {
	v := value
	newV := u.nodes[v]
	cnt := 0
	for newV != v {
		cnt++
		oldV := v
		v = newV
		newV = u.nodes[newV]
		u.nodes[oldV] = newV
	}
	return newV, cnt
}

func (u *lib_UnionFindInt32) Unite(v1, v2 int32) (int32, bool) {
	v1Root, v1HopNum := u.GetRoot(v1)
	v2Root, v2HopNum := u.GetRoot(v2)
	if v1Root == v2Root {
		return v1Root, false
	}
	if v1HopNum >= v2HopNum {
		u.nodes[v2Root] = v1Root
		return v1Root, true
	}
	u.nodes[v1Root] = v2Root
	return v2Root, true
}

func (u *lib_UnionFindInt32) IsSameGroup(v1, v2 int32) bool {
	v1Root, _ := u.GetRoot(v1)
	v2Root, _ := u.GetRoot(v2)
	return v1Root == v2Root
}

func lib_MemoizeInt32(f func(v int32) int32) func(v int32) int32 {
	cache := map[int32]int32{}
	return func(v int32) int32 {
		if cachedResult, ok := cache[v]; ok {
			return cachedResult
		}
		result := f(v)
		cache[v] = result
		return result
	}
}

func lib_ReduceInt64(values []int64, f func(acc, cur int64) int64, initial int64) (newValue int64) {
	newValue = initial
	for _, value := range values {
		newValue = f(newValue, value)
	}
	return
}

func lib_ReduceInt64Slice(values [][]int64, f func(acc int64, cur []int64) int64, initial int64) (newValue int64) {
	newValue = initial
	for _, value := range values {
		newValue = f(newValue, value)
	}
	return
}

func lib_CopyInt64(values []int64) []int64 {
	dst := make([]int64, len(values))
	copy(dst, values)
	return dst
}

func lib_CopyInt64Slice(values [][]int64) [][]int64 {
	dst := make([][]int64, len(values))
	for i, value := range values {
		dst[i] = lib_CopyInt64(value)
	}
	return dst
}

func lib_ReverseInt64(values []int64) []int64 {
	newValues := lib_CopyInt64(values)
	for i, j := 0, len(values)-1; i < j; i, j = i+1, j-1 {
		newValues[i], newValues[j] = values[j], values[i]
	}
	return newValues
}

func lib_ReverseInt64Slice(values [][]int64) [][]int64 {
	newValues := lib_CopyInt64Slice(values)
	for i, j := 0, len(values)-1; i < j; i, j = i+1, j-1 {
		newValues[i], newValues[j] = values[j], values[i]
	}
	return newValues
}

func lib_MapInt64(values []int64, f func(v int64) int64) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapInt64Slice(values [][]int64, f func(v []int64) []int64) (newValues [][]int64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapTypeInt64(values [][]int64, f func(v []int64) int64) (newValues []int64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_ZipInt64(valuesList ...[]int64) (newValuesList [][]int64, err error) {
	if len(valuesList) == 0 {
		return nil, errors.New("empty values list are given to ZipInt64")
	}
	valuesLen := len(valuesList[0])
	for _, values := range valuesList {
		if (len(values)) != valuesLen {
			return nil, errors.New("different lengths values are given to ZipInt64")
		}
	}

	for i := 0; i < valuesLen; i++ {
		var newValues []int64
		for _, values := range valuesList {
			newValues = append(newValues, values[i])
		}
		newValuesList = append(newValuesList, newValues)
	}
	return
}

func lib_SomeInt64(values []int64, f func(v int64) bool) bool {
	for _, value := range values {
		if f(value) {
			return true
		}
	}
	return false
}

func lib_SomeInt64Slice(valuesList [][]int64, f func(v []int64) bool) bool {
	for _, values := range valuesList {
		if f(values) {
			return true
		}
	}
	return false
}

func lib_EveryInt64(values []int64, f func(v int64) bool) bool {
	for _, value := range values {
		if !f(value) {
			return false
		}
	}
	return true
}

func lib_EveryInt64Slice(valuesList [][]int64, f func(v []int64) bool) bool {
	for _, values := range valuesList {
		if !f(values) {
			return false
		}
	}
	return true
}

func lib_ChunkInt64ByBits(values []int64, bits []bool) (newValues [][]int64, err error) {
	if len(values) != len(bits)+1 {
		return nil, errors.New(fmt.Sprintf("there are different length between values(%d) and bits(%d)", len(values), len(bits)))
	}

	var chunk []int64
	for i, bit := range bits {
		chunk = append(chunk, values[i])
		if bit {
			newValues = append(newValues, chunk)
			chunk = []int64{}
		}
	}
	chunk = append(chunk, values[len(values)-1])
	newValues = append(newValues, chunk)
	return
}

func lib_UnsetInt64(values []int64, i int) ([]int64, error) {
	if i < 0 {
		return nil, fmt.Errorf("negative number index is given: %d", i)
	}

	if i >= len(values) {
		return nil, fmt.Errorf("index(%d) is larger than slice length(%d)", i, len(values))
	}

	if len(values) == 1 {
		return []int64{}, nil
	}

	if i == len(values)-1 {
		return values[:len(values)-1], nil
	}

	newValues := make([]int64, len(values))
	copy(newValues, values)
	return append(newValues[:i], newValues[i+1:]...), nil
}

func lib_Int64Combination(values []int64, r int) (combinations [][]int64, err error) {
	if r == 1 {
		for _, value := range values {
			combinations = append(combinations, []int64{value})
		}
		return
	}

	for i := range values {
		newValues := values
		for j := 0; j <= i; j++ {
			newValues = newValues[1:]
		}
		partialCombinations, err := lib_Int64Combination(newValues, r-1)
		if err != nil {
			return nil, err
		}

		for _, pc := range partialCombinations {
			newC := append(pc, values[i])
			combinations = append(combinations, newC)
		}
	}
	return
}

func lib_Int64Permutation(values []int64, r int) (permutations [][]int64) {
	if r == 1 {
		for _, value := range values {
			permutations = append(permutations, []int64{value})
		}
		return
	}
	for i := range values {
		newValues := lib_Int64RemoveFromSlice(values, i)
		for _, pc := range lib_Int64Permutation(newValues, r-1) {
			newC := append(pc, values[i])
			permutations = append(permutations, newC)
		}
	}
	return
}

func lib_Int64SliceCombination(values [][]int64, r int) (combinations [][][]int64, err error) {
	if r == 1 {
		for _, value := range values {
			combinations = append(combinations, [][]int64{value})
		}
		return
	}

	for i := range values {
		newValues := values
		for j := 0; j <= i; j++ {
			newValues = newValues[1:]
			if err != nil {
				return nil, err
			}
		}
		partialCombinations, err := lib_Int64SliceCombination(newValues, r-1)
		if err != nil {
			return nil, err
		}

		for _, pc := range partialCombinations {
			newC := append(pc, values[i])
			combinations = append(combinations, newC)
		}
	}
	return
}

func lib_Int64RemoveFromSlice(slice []int64, i int) []int64 {
	n := make([]int64, len(slice))
	copy(n, slice)
	return append(n[:i], n[i+1:]...)
}

func lib_TernaryOPInt64(ok bool, v1, v2 int64) int64 {
	if ok {
		return v1
	}
	return v2
}

type lib_UnionFindInt64 struct {
	nodes map[int64]int64
}

func lib_NewUnionFindInt64(values []int64) *lib_UnionFindInt64 {
	m := map[int64]int64{}
	for _, v := range values {
		m[v] = v
	}
	return &lib_UnionFindInt64{nodes: m}
}

func (u *lib_UnionFindInt64) GetRoot(value int64) (int64, int) {
	v := value
	newV := u.nodes[v]
	cnt := 0
	for newV != v {
		cnt++
		oldV := v
		v = newV
		newV = u.nodes[newV]
		u.nodes[oldV] = newV
	}
	return newV, cnt
}

func (u *lib_UnionFindInt64) Unite(v1, v2 int64) (int64, bool) {
	v1Root, v1HopNum := u.GetRoot(v1)
	v2Root, v2HopNum := u.GetRoot(v2)
	if v1Root == v2Root {
		return v1Root, false
	}
	if v1HopNum >= v2HopNum {
		u.nodes[v2Root] = v1Root
		return v1Root, true
	}
	u.nodes[v1Root] = v2Root
	return v2Root, true
}

func (u *lib_UnionFindInt64) IsSameGroup(v1, v2 int64) bool {
	v1Root, _ := u.GetRoot(v1)
	v2Root, _ := u.GetRoot(v2)
	return v1Root == v2Root
}

func lib_MemoizeInt64(f func(v int64) int64) func(v int64) int64 {
	cache := map[int64]int64{}
	return func(v int64) int64 {
		if cachedResult, ok := cache[v]; ok {
			return cachedResult
		}
		result := f(v)
		cache[v] = result
		return result
	}
}

func lib_ReduceFloat32(values []float32, f func(acc, cur float32) float32, initial float32) (newValue float32) {
	newValue = initial
	for _, value := range values {
		newValue = f(newValue, value)
	}
	return
}

func lib_ReduceFloat32Slice(values [][]float32, f func(acc float32, cur []float32) float32, initial float32) (newValue float32) {
	newValue = initial
	for _, value := range values {
		newValue = f(newValue, value)
	}
	return
}

func lib_CopyFloat32(values []float32) []float32 {
	dst := make([]float32, len(values))
	copy(dst, values)
	return dst
}

func lib_CopyFloat32Slice(values [][]float32) [][]float32 {
	dst := make([][]float32, len(values))
	for i, value := range values {
		dst[i] = lib_CopyFloat32(value)
	}
	return dst
}

func lib_ReverseFloat32(values []float32) []float32 {
	newValues := lib_CopyFloat32(values)
	for i, j := 0, len(values)-1; i < j; i, j = i+1, j-1 {
		newValues[i], newValues[j] = values[j], values[i]
	}
	return newValues
}

func lib_ReverseFloat32Slice(values [][]float32) [][]float32 {
	newValues := lib_CopyFloat32Slice(values)
	for i, j := 0, len(values)-1; i < j; i, j = i+1, j-1 {
		newValues[i], newValues[j] = values[j], values[i]
	}
	return newValues
}

func lib_MapFloat32(values []float32, f func(v float32) float32) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapFloat32Slice(values [][]float32, f func(v []float32) []float32) (newValues [][]float32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapTypeFloat32(values [][]float32, f func(v []float32) float32) (newValues []float32) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_ZipFloat32(valuesList ...[]float32) (newValuesList [][]float32, err error) {
	if len(valuesList) == 0 {
		return nil, errors.New("empty values list are given to ZipFloat32")
	}
	valuesLen := len(valuesList[0])
	for _, values := range valuesList {
		if (len(values)) != valuesLen {
			return nil, errors.New("different lengths values are given to ZipFloat32")
		}
	}

	for i := 0; i < valuesLen; i++ {
		var newValues []float32
		for _, values := range valuesList {
			newValues = append(newValues, values[i])
		}
		newValuesList = append(newValuesList, newValues)
	}
	return
}

func lib_SomeFloat32(values []float32, f func(v float32) bool) bool {
	for _, value := range values {
		if f(value) {
			return true
		}
	}
	return false
}

func lib_SomeFloat32Slice(valuesList [][]float32, f func(v []float32) bool) bool {
	for _, values := range valuesList {
		if f(values) {
			return true
		}
	}
	return false
}

func lib_EveryFloat32(values []float32, f func(v float32) bool) bool {
	for _, value := range values {
		if !f(value) {
			return false
		}
	}
	return true
}

func lib_EveryFloat32Slice(valuesList [][]float32, f func(v []float32) bool) bool {
	for _, values := range valuesList {
		if !f(values) {
			return false
		}
	}
	return true
}

func lib_ChunkFloat32ByBits(values []float32, bits []bool) (newValues [][]float32, err error) {
	if len(values) != len(bits)+1 {
		return nil, errors.New(fmt.Sprintf("there are different length between values(%d) and bits(%d)", len(values), len(bits)))
	}

	var chunk []float32
	for i, bit := range bits {
		chunk = append(chunk, values[i])
		if bit {
			newValues = append(newValues, chunk)
			chunk = []float32{}
		}
	}
	chunk = append(chunk, values[len(values)-1])
	newValues = append(newValues, chunk)
	return
}

func lib_UnsetFloat32(values []float32, i int) ([]float32, error) {
	if i < 0 {
		return nil, fmt.Errorf("negative number index is given: %d", i)
	}

	if i >= len(values) {
		return nil, fmt.Errorf("index(%d) is larger than slice length(%d)", i, len(values))
	}

	if len(values) == 1 {
		return []float32{}, nil
	}

	if i == len(values)-1 {
		return values[:len(values)-1], nil
	}

	newValues := make([]float32, len(values))
	copy(newValues, values)
	return append(newValues[:i], newValues[i+1:]...), nil
}

func lib_Float32Combination(values []float32, r int) (combinations [][]float32, err error) {
	if r == 1 {
		for _, value := range values {
			combinations = append(combinations, []float32{value})
		}
		return
	}

	for i := range values {
		newValues := values
		for j := 0; j <= i; j++ {
			newValues = newValues[1:]
		}
		partialCombinations, err := lib_Float32Combination(newValues, r-1)
		if err != nil {
			return nil, err
		}

		for _, pc := range partialCombinations {
			newC := append(pc, values[i])
			combinations = append(combinations, newC)
		}
	}
	return
}

func lib_Float32Permutation(values []float32, r int) (permutations [][]float32) {
	if r == 1 {
		for _, value := range values {
			permutations = append(permutations, []float32{value})
		}
		return
	}
	for i := range values {
		newValues := lib_Float32RemoveFromSlice(values, i)
		for _, pc := range lib_Float32Permutation(newValues, r-1) {
			newC := append(pc, values[i])
			permutations = append(permutations, newC)
		}
	}
	return
}

func lib_Float32SliceCombination(values [][]float32, r int) (combinations [][][]float32, err error) {
	if r == 1 {
		for _, value := range values {
			combinations = append(combinations, [][]float32{value})
		}
		return
	}

	for i := range values {
		newValues := values
		for j := 0; j <= i; j++ {
			newValues = newValues[1:]
			if err != nil {
				return nil, err
			}
		}
		partialCombinations, err := lib_Float32SliceCombination(newValues, r-1)
		if err != nil {
			return nil, err
		}

		for _, pc := range partialCombinations {
			newC := append(pc, values[i])
			combinations = append(combinations, newC)
		}
	}
	return
}

func lib_Float32RemoveFromSlice(slice []float32, i int) []float32 {
	n := make([]float32, len(slice))
	copy(n, slice)
	return append(n[:i], n[i+1:]...)
}

func lib_TernaryOPFloat32(ok bool, v1, v2 float32) float32 {
	if ok {
		return v1
	}
	return v2
}

type lib_UnionFindFloat32 struct {
	nodes map[float32]float32
}

func lib_NewUnionFindFloat32(values []float32) *lib_UnionFindFloat32 {
	m := map[float32]float32{}
	for _, v := range values {
		m[v] = v
	}
	return &lib_UnionFindFloat32{nodes: m}
}

func (u *lib_UnionFindFloat32) GetRoot(value float32) (float32, int) {
	v := value
	newV := u.nodes[v]
	cnt := 0
	for newV != v {
		cnt++
		oldV := v
		v = newV
		newV = u.nodes[newV]
		u.nodes[oldV] = newV
	}
	return newV, cnt
}

func (u *lib_UnionFindFloat32) Unite(v1, v2 float32) (float32, bool) {
	v1Root, v1HopNum := u.GetRoot(v1)
	v2Root, v2HopNum := u.GetRoot(v2)
	if v1Root == v2Root {
		return v1Root, false
	}
	if v1HopNum >= v2HopNum {
		u.nodes[v2Root] = v1Root
		return v1Root, true
	}
	u.nodes[v1Root] = v2Root
	return v2Root, true
}

func (u *lib_UnionFindFloat32) IsSameGroup(v1, v2 float32) bool {
	v1Root, _ := u.GetRoot(v1)
	v2Root, _ := u.GetRoot(v2)
	return v1Root == v2Root
}

func lib_MemoizeFloat32(f func(v float32) float32) func(v float32) float32 {
	cache := map[float32]float32{}
	return func(v float32) float32 {
		if cachedResult, ok := cache[v]; ok {
			return cachedResult
		}
		result := f(v)
		cache[v] = result
		return result
	}
}

func lib_ReduceFloat64(values []float64, f func(acc, cur float64) float64, initial float64) (newValue float64) {
	newValue = initial
	for _, value := range values {
		newValue = f(newValue, value)
	}
	return
}

func lib_ReduceFloat64Slice(values [][]float64, f func(acc float64, cur []float64) float64, initial float64) (newValue float64) {
	newValue = initial
	for _, value := range values {
		newValue = f(newValue, value)
	}
	return
}

func lib_CopyFloat64(values []float64) []float64 {
	dst := make([]float64, len(values))
	copy(dst, values)
	return dst
}

func lib_CopyFloat64Slice(values [][]float64) [][]float64 {
	dst := make([][]float64, len(values))
	for i, value := range values {
		dst[i] = lib_CopyFloat64(value)
	}
	return dst
}

func lib_ReverseFloat64(values []float64) []float64 {
	newValues := lib_CopyFloat64(values)
	for i, j := 0, len(values)-1; i < j; i, j = i+1, j-1 {
		newValues[i], newValues[j] = values[j], values[i]
	}
	return newValues
}

func lib_ReverseFloat64Slice(values [][]float64) [][]float64 {
	newValues := lib_CopyFloat64Slice(values)
	for i, j := 0, len(values)-1; i < j; i, j = i+1, j-1 {
		newValues[i], newValues[j] = values[j], values[i]
	}
	return newValues
}

func lib_MapFloat64(values []float64, f func(v float64) float64) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapFloat64Slice(values [][]float64, f func(v []float64) []float64) (newValues [][]float64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_MapTypeFloat64(values [][]float64, f func(v []float64) float64) (newValues []float64) {
	for _, value := range values {
		newValues = append(newValues, f(value))
	}
	return
}

func lib_ZipFloat64(valuesList ...[]float64) (newValuesList [][]float64, err error) {
	if len(valuesList) == 0 {
		return nil, errors.New("empty values list are given to ZipFloat64")
	}
	valuesLen := len(valuesList[0])
	for _, values := range valuesList {
		if (len(values)) != valuesLen {
			return nil, errors.New("different lengths values are given to ZipFloat64")
		}
	}

	for i := 0; i < valuesLen; i++ {
		var newValues []float64
		for _, values := range valuesList {
			newValues = append(newValues, values[i])
		}
		newValuesList = append(newValuesList, newValues)
	}
	return
}

func lib_SomeFloat64(values []float64, f func(v float64) bool) bool {
	for _, value := range values {
		if f(value) {
			return true
		}
	}
	return false
}

func lib_SomeFloat64Slice(valuesList [][]float64, f func(v []float64) bool) bool {
	for _, values := range valuesList {
		if f(values) {
			return true
		}
	}
	return false
}

func lib_EveryFloat64(values []float64, f func(v float64) bool) bool {
	for _, value := range values {
		if !f(value) {
			return false
		}
	}
	return true
}

func lib_EveryFloat64Slice(valuesList [][]float64, f func(v []float64) bool) bool {
	for _, values := range valuesList {
		if !f(values) {
			return false
		}
	}
	return true
}

func lib_ChunkFloat64ByBits(values []float64, bits []bool) (newValues [][]float64, err error) {
	if len(values) != len(bits)+1 {
		return nil, errors.New(fmt.Sprintf("there are different length between values(%d) and bits(%d)", len(values), len(bits)))
	}

	var chunk []float64
	for i, bit := range bits {
		chunk = append(chunk, values[i])
		if bit {
			newValues = append(newValues, chunk)
			chunk = []float64{}
		}
	}
	chunk = append(chunk, values[len(values)-1])
	newValues = append(newValues, chunk)
	return
}

func lib_UnsetFloat64(values []float64, i int) ([]float64, error) {
	if i < 0 {
		return nil, fmt.Errorf("negative number index is given: %d", i)
	}

	if i >= len(values) {
		return nil, fmt.Errorf("index(%d) is larger than slice length(%d)", i, len(values))
	}

	if len(values) == 1 {
		return []float64{}, nil
	}

	if i == len(values)-1 {
		return values[:len(values)-1], nil
	}

	newValues := make([]float64, len(values))
	copy(newValues, values)
	return append(newValues[:i], newValues[i+1:]...), nil
}

func lib_Float64Combination(values []float64, r int) (combinations [][]float64, err error) {
	if r == 1 {
		for _, value := range values {
			combinations = append(combinations, []float64{value})
		}
		return
	}

	for i := range values {
		newValues := values
		for j := 0; j <= i; j++ {
			newValues = newValues[1:]
		}
		partialCombinations, err := lib_Float64Combination(newValues, r-1)
		if err != nil {
			return nil, err
		}

		for _, pc := range partialCombinations {
			newC := append(pc, values[i])
			combinations = append(combinations, newC)
		}
	}
	return
}

func lib_Float64Permutation(values []float64, r int) (permutations [][]float64) {
	if r == 1 {
		for _, value := range values {
			permutations = append(permutations, []float64{value})
		}
		return
	}
	for i := range values {
		newValues := lib_Float64RemoveFromSlice(values, i)
		for _, pc := range lib_Float64Permutation(newValues, r-1) {
			newC := append(pc, values[i])
			permutations = append(permutations, newC)
		}
	}
	return
}

func lib_Float64SliceCombination(values [][]float64, r int) (combinations [][][]float64, err error) {
	if r == 1 {
		for _, value := range values {
			combinations = append(combinations, [][]float64{value})
		}
		return
	}

	for i := range values {
		newValues := values
		for j := 0; j <= i; j++ {
			newValues = newValues[1:]
			if err != nil {
				return nil, err
			}
		}
		partialCombinations, err := lib_Float64SliceCombination(newValues, r-1)
		if err != nil {
			return nil, err
		}

		for _, pc := range partialCombinations {
			newC := append(pc, values[i])
			combinations = append(combinations, newC)
		}
	}
	return
}

func lib_Float64RemoveFromSlice(slice []float64, i int) []float64 {
	n := make([]float64, len(slice))
	copy(n, slice)
	return append(n[:i], n[i+1:]...)
}

func lib_TernaryOPFloat64(ok bool, v1, v2 float64) float64 {
	if ok {
		return v1
	}
	return v2
}

type lib_UnionFindFloat64 struct {
	nodes map[float64]float64
}

func lib_NewUnionFindFloat64(values []float64) *lib_UnionFindFloat64 {
	m := map[float64]float64{}
	for _, v := range values {
		m[v] = v
	}
	return &lib_UnionFindFloat64{nodes: m}
}

func (u *lib_UnionFindFloat64) GetRoot(value float64) (float64, int) {
	v := value
	newV := u.nodes[v]
	cnt := 0
	for newV != v {
		cnt++
		oldV := v
		v = newV
		newV = u.nodes[newV]
		u.nodes[oldV] = newV
	}
	return newV, cnt
}

func (u *lib_UnionFindFloat64) Unite(v1, v2 float64) (float64, bool) {
	v1Root, v1HopNum := u.GetRoot(v1)
	v2Root, v2HopNum := u.GetRoot(v2)
	if v1Root == v2Root {
		return v1Root, false
	}
	if v1HopNum >= v2HopNum {
		u.nodes[v2Root] = v1Root
		return v1Root, true
	}
	u.nodes[v1Root] = v2Root
	return v2Root, true
}

func (u *lib_UnionFindFloat64) IsSameGroup(v1, v2 float64) bool {
	v1Root, _ := u.GetRoot(v1)
	v2Root, _ := u.GetRoot(v2)
	return v1Root == v2Root
}

func lib_MemoizeFloat64(f func(v float64) float64) func(v float64) float64 {
	cache := map[float64]float64{}
	return func(v float64) float64 {
		if cachedResult, ok := cache[v]; ok {
			return cachedResult
		}
		result := f(v)
		cache[v] = result
		return result
	}
}

func lib_MemoizeRune2ToRune(f func(v1, v2 rune) rune) func(v1, v2 rune) rune {
	cache := map[rune]map[rune]rune{}

	return func(v1, v2 rune) rune {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[rune]rune{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeRune5ToRune(f func(v1, v2, v3, v4, v5 rune) rune) func(v1, v2, v3, v4, v5 rune) rune {
	cache := map[rune]map[rune]map[rune]map[rune]map[rune]rune{}

	return func(v1, v2, v3, v4, v5 rune) rune {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[rune]map[rune]map[rune]map[rune]rune{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[rune]map[rune]map[rune]rune{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[rune]map[rune]rune{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[rune]rune{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeRune2ToString(f func(v1, v2 rune) string) func(v1, v2 rune) string {
	cache := map[rune]map[rune]string{}

	return func(v1, v2 rune) string {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[rune]string{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeRune5ToString(f func(v1, v2, v3, v4, v5 rune) string) func(v1, v2, v3, v4, v5 rune) string {
	cache := map[rune]map[rune]map[rune]map[rune]map[rune]string{}

	return func(v1, v2, v3, v4, v5 rune) string {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[rune]map[rune]map[rune]map[rune]string{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[rune]map[rune]map[rune]string{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[rune]map[rune]string{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[rune]string{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeRune2ToInt(f func(v1, v2 rune) int) func(v1, v2 rune) int {
	cache := map[rune]map[rune]int{}

	return func(v1, v2 rune) int {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[rune]int{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeRune5ToInt(f func(v1, v2, v3, v4, v5 rune) int) func(v1, v2, v3, v4, v5 rune) int {
	cache := map[rune]map[rune]map[rune]map[rune]map[rune]int{}

	return func(v1, v2, v3, v4, v5 rune) int {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[rune]map[rune]map[rune]map[rune]int{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[rune]map[rune]map[rune]int{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[rune]map[rune]int{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[rune]int{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeRune2ToInt8(f func(v1, v2 rune) int8) func(v1, v2 rune) int8 {
	cache := map[rune]map[rune]int8{}

	return func(v1, v2 rune) int8 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[rune]int8{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeRune5ToInt8(f func(v1, v2, v3, v4, v5 rune) int8) func(v1, v2, v3, v4, v5 rune) int8 {
	cache := map[rune]map[rune]map[rune]map[rune]map[rune]int8{}

	return func(v1, v2, v3, v4, v5 rune) int8 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[rune]map[rune]map[rune]map[rune]int8{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[rune]map[rune]map[rune]int8{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[rune]map[rune]int8{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[rune]int8{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeRune2ToInt16(f func(v1, v2 rune) int16) func(v1, v2 rune) int16 {
	cache := map[rune]map[rune]int16{}

	return func(v1, v2 rune) int16 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[rune]int16{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeRune5ToInt16(f func(v1, v2, v3, v4, v5 rune) int16) func(v1, v2, v3, v4, v5 rune) int16 {
	cache := map[rune]map[rune]map[rune]map[rune]map[rune]int16{}

	return func(v1, v2, v3, v4, v5 rune) int16 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[rune]map[rune]map[rune]map[rune]int16{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[rune]map[rune]map[rune]int16{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[rune]map[rune]int16{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[rune]int16{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeRune2ToInt32(f func(v1, v2 rune) int32) func(v1, v2 rune) int32 {
	cache := map[rune]map[rune]int32{}

	return func(v1, v2 rune) int32 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[rune]int32{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeRune5ToInt32(f func(v1, v2, v3, v4, v5 rune) int32) func(v1, v2, v3, v4, v5 rune) int32 {
	cache := map[rune]map[rune]map[rune]map[rune]map[rune]int32{}

	return func(v1, v2, v3, v4, v5 rune) int32 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[rune]map[rune]map[rune]map[rune]int32{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[rune]map[rune]map[rune]int32{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[rune]map[rune]int32{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[rune]int32{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeRune2ToInt64(f func(v1, v2 rune) int64) func(v1, v2 rune) int64 {
	cache := map[rune]map[rune]int64{}

	return func(v1, v2 rune) int64 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[rune]int64{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeRune5ToInt64(f func(v1, v2, v3, v4, v5 rune) int64) func(v1, v2, v3, v4, v5 rune) int64 {
	cache := map[rune]map[rune]map[rune]map[rune]map[rune]int64{}

	return func(v1, v2, v3, v4, v5 rune) int64 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[rune]map[rune]map[rune]map[rune]int64{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[rune]map[rune]map[rune]int64{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[rune]map[rune]int64{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[rune]int64{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeRune2ToFloat32(f func(v1, v2 rune) float32) func(v1, v2 rune) float32 {
	cache := map[rune]map[rune]float32{}

	return func(v1, v2 rune) float32 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[rune]float32{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeRune5ToFloat32(f func(v1, v2, v3, v4, v5 rune) float32) func(v1, v2, v3, v4, v5 rune) float32 {
	cache := map[rune]map[rune]map[rune]map[rune]map[rune]float32{}

	return func(v1, v2, v3, v4, v5 rune) float32 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[rune]map[rune]map[rune]map[rune]float32{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[rune]map[rune]map[rune]float32{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[rune]map[rune]float32{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[rune]float32{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeRune2ToFloat64(f func(v1, v2 rune) float64) func(v1, v2 rune) float64 {
	cache := map[rune]map[rune]float64{}

	return func(v1, v2 rune) float64 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[rune]float64{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeRune5ToFloat64(f func(v1, v2, v3, v4, v5 rune) float64) func(v1, v2, v3, v4, v5 rune) float64 {
	cache := map[rune]map[rune]map[rune]map[rune]map[rune]float64{}

	return func(v1, v2, v3, v4, v5 rune) float64 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[rune]map[rune]map[rune]map[rune]float64{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[rune]map[rune]map[rune]float64{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[rune]map[rune]float64{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[rune]float64{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeString2ToRune(f func(v1, v2 string) rune) func(v1, v2 string) rune {
	cache := map[string]map[string]rune{}

	return func(v1, v2 string) rune {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[string]rune{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeString5ToRune(f func(v1, v2, v3, v4, v5 string) rune) func(v1, v2, v3, v4, v5 string) rune {
	cache := map[string]map[string]map[string]map[string]map[string]rune{}

	return func(v1, v2, v3, v4, v5 string) rune {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[string]map[string]map[string]map[string]rune{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[string]map[string]map[string]rune{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[string]map[string]rune{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[string]rune{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeString2ToString(f func(v1, v2 string) string) func(v1, v2 string) string {
	cache := map[string]map[string]string{}

	return func(v1, v2 string) string {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[string]string{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeString5ToString(f func(v1, v2, v3, v4, v5 string) string) func(v1, v2, v3, v4, v5 string) string {
	cache := map[string]map[string]map[string]map[string]map[string]string{}

	return func(v1, v2, v3, v4, v5 string) string {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[string]map[string]map[string]map[string]string{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[string]map[string]map[string]string{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[string]map[string]string{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[string]string{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeString2ToInt(f func(v1, v2 string) int) func(v1, v2 string) int {
	cache := map[string]map[string]int{}

	return func(v1, v2 string) int {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[string]int{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeString5ToInt(f func(v1, v2, v3, v4, v5 string) int) func(v1, v2, v3, v4, v5 string) int {
	cache := map[string]map[string]map[string]map[string]map[string]int{}

	return func(v1, v2, v3, v4, v5 string) int {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[string]map[string]map[string]map[string]int{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[string]map[string]map[string]int{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[string]map[string]int{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[string]int{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeString2ToInt8(f func(v1, v2 string) int8) func(v1, v2 string) int8 {
	cache := map[string]map[string]int8{}

	return func(v1, v2 string) int8 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[string]int8{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeString5ToInt8(f func(v1, v2, v3, v4, v5 string) int8) func(v1, v2, v3, v4, v5 string) int8 {
	cache := map[string]map[string]map[string]map[string]map[string]int8{}

	return func(v1, v2, v3, v4, v5 string) int8 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[string]map[string]map[string]map[string]int8{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[string]map[string]map[string]int8{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[string]map[string]int8{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[string]int8{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeString2ToInt16(f func(v1, v2 string) int16) func(v1, v2 string) int16 {
	cache := map[string]map[string]int16{}

	return func(v1, v2 string) int16 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[string]int16{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeString5ToInt16(f func(v1, v2, v3, v4, v5 string) int16) func(v1, v2, v3, v4, v5 string) int16 {
	cache := map[string]map[string]map[string]map[string]map[string]int16{}

	return func(v1, v2, v3, v4, v5 string) int16 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[string]map[string]map[string]map[string]int16{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[string]map[string]map[string]int16{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[string]map[string]int16{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[string]int16{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeString2ToInt32(f func(v1, v2 string) int32) func(v1, v2 string) int32 {
	cache := map[string]map[string]int32{}

	return func(v1, v2 string) int32 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[string]int32{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeString5ToInt32(f func(v1, v2, v3, v4, v5 string) int32) func(v1, v2, v3, v4, v5 string) int32 {
	cache := map[string]map[string]map[string]map[string]map[string]int32{}

	return func(v1, v2, v3, v4, v5 string) int32 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[string]map[string]map[string]map[string]int32{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[string]map[string]map[string]int32{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[string]map[string]int32{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[string]int32{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeString2ToInt64(f func(v1, v2 string) int64) func(v1, v2 string) int64 {
	cache := map[string]map[string]int64{}

	return func(v1, v2 string) int64 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[string]int64{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeString5ToInt64(f func(v1, v2, v3, v4, v5 string) int64) func(v1, v2, v3, v4, v5 string) int64 {
	cache := map[string]map[string]map[string]map[string]map[string]int64{}

	return func(v1, v2, v3, v4, v5 string) int64 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[string]map[string]map[string]map[string]int64{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[string]map[string]map[string]int64{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[string]map[string]int64{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[string]int64{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeString2ToFloat32(f func(v1, v2 string) float32) func(v1, v2 string) float32 {
	cache := map[string]map[string]float32{}

	return func(v1, v2 string) float32 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[string]float32{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeString5ToFloat32(f func(v1, v2, v3, v4, v5 string) float32) func(v1, v2, v3, v4, v5 string) float32 {
	cache := map[string]map[string]map[string]map[string]map[string]float32{}

	return func(v1, v2, v3, v4, v5 string) float32 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[string]map[string]map[string]map[string]float32{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[string]map[string]map[string]float32{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[string]map[string]float32{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[string]float32{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeString2ToFloat64(f func(v1, v2 string) float64) func(v1, v2 string) float64 {
	cache := map[string]map[string]float64{}

	return func(v1, v2 string) float64 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[string]float64{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeString5ToFloat64(f func(v1, v2, v3, v4, v5 string) float64) func(v1, v2, v3, v4, v5 string) float64 {
	cache := map[string]map[string]map[string]map[string]map[string]float64{}

	return func(v1, v2, v3, v4, v5 string) float64 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[string]map[string]map[string]map[string]float64{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[string]map[string]map[string]float64{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[string]map[string]float64{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[string]float64{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt2ToRune(f func(v1, v2 int) rune) func(v1, v2 int) rune {
	cache := map[int]map[int]rune{}

	return func(v1, v2 int) rune {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int]rune{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt5ToRune(f func(v1, v2, v3, v4, v5 int) rune) func(v1, v2, v3, v4, v5 int) rune {
	cache := map[int]map[int]map[int]map[int]map[int]rune{}

	return func(v1, v2, v3, v4, v5 int) rune {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int]map[int]map[int]map[int]rune{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int]map[int]map[int]rune{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int]map[int]rune{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int]rune{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt2ToString(f func(v1, v2 int) string) func(v1, v2 int) string {
	cache := map[int]map[int]string{}

	return func(v1, v2 int) string {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int]string{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt5ToString(f func(v1, v2, v3, v4, v5 int) string) func(v1, v2, v3, v4, v5 int) string {
	cache := map[int]map[int]map[int]map[int]map[int]string{}

	return func(v1, v2, v3, v4, v5 int) string {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int]map[int]map[int]map[int]string{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int]map[int]map[int]string{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int]map[int]string{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int]string{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt2ToInt(f func(v1, v2 int) int) func(v1, v2 int) int {
	cache := map[int]map[int]int{}

	return func(v1, v2 int) int {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int]int{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt5ToInt(f func(v1, v2, v3, v4, v5 int) int) func(v1, v2, v3, v4, v5 int) int {
	cache := map[int]map[int]map[int]map[int]map[int]int{}

	return func(v1, v2, v3, v4, v5 int) int {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int]map[int]map[int]map[int]int{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int]map[int]map[int]int{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int]map[int]int{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int]int{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt2ToInt8(f func(v1, v2 int) int8) func(v1, v2 int) int8 {
	cache := map[int]map[int]int8{}

	return func(v1, v2 int) int8 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int]int8{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt5ToInt8(f func(v1, v2, v3, v4, v5 int) int8) func(v1, v2, v3, v4, v5 int) int8 {
	cache := map[int]map[int]map[int]map[int]map[int]int8{}

	return func(v1, v2, v3, v4, v5 int) int8 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int]map[int]map[int]map[int]int8{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int]map[int]map[int]int8{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int]map[int]int8{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int]int8{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt2ToInt16(f func(v1, v2 int) int16) func(v1, v2 int) int16 {
	cache := map[int]map[int]int16{}

	return func(v1, v2 int) int16 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int]int16{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt5ToInt16(f func(v1, v2, v3, v4, v5 int) int16) func(v1, v2, v3, v4, v5 int) int16 {
	cache := map[int]map[int]map[int]map[int]map[int]int16{}

	return func(v1, v2, v3, v4, v5 int) int16 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int]map[int]map[int]map[int]int16{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int]map[int]map[int]int16{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int]map[int]int16{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int]int16{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt2ToInt32(f func(v1, v2 int) int32) func(v1, v2 int) int32 {
	cache := map[int]map[int]int32{}

	return func(v1, v2 int) int32 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int]int32{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt5ToInt32(f func(v1, v2, v3, v4, v5 int) int32) func(v1, v2, v3, v4, v5 int) int32 {
	cache := map[int]map[int]map[int]map[int]map[int]int32{}

	return func(v1, v2, v3, v4, v5 int) int32 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int]map[int]map[int]map[int]int32{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int]map[int]map[int]int32{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int]map[int]int32{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int]int32{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt2ToInt64(f func(v1, v2 int) int64) func(v1, v2 int) int64 {
	cache := map[int]map[int]int64{}

	return func(v1, v2 int) int64 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int]int64{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt5ToInt64(f func(v1, v2, v3, v4, v5 int) int64) func(v1, v2, v3, v4, v5 int) int64 {
	cache := map[int]map[int]map[int]map[int]map[int]int64{}

	return func(v1, v2, v3, v4, v5 int) int64 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int]map[int]map[int]map[int]int64{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int]map[int]map[int]int64{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int]map[int]int64{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int]int64{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt2ToFloat32(f func(v1, v2 int) float32) func(v1, v2 int) float32 {
	cache := map[int]map[int]float32{}

	return func(v1, v2 int) float32 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int]float32{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt5ToFloat32(f func(v1, v2, v3, v4, v5 int) float32) func(v1, v2, v3, v4, v5 int) float32 {
	cache := map[int]map[int]map[int]map[int]map[int]float32{}

	return func(v1, v2, v3, v4, v5 int) float32 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int]map[int]map[int]map[int]float32{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int]map[int]map[int]float32{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int]map[int]float32{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int]float32{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt2ToFloat64(f func(v1, v2 int) float64) func(v1, v2 int) float64 {
	cache := map[int]map[int]float64{}

	return func(v1, v2 int) float64 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int]float64{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt5ToFloat64(f func(v1, v2, v3, v4, v5 int) float64) func(v1, v2, v3, v4, v5 int) float64 {
	cache := map[int]map[int]map[int]map[int]map[int]float64{}

	return func(v1, v2, v3, v4, v5 int) float64 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int]map[int]map[int]map[int]float64{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int]map[int]map[int]float64{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int]map[int]float64{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int]float64{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt82ToRune(f func(v1, v2 int8) rune) func(v1, v2 int8) rune {
	cache := map[int8]map[int8]rune{}

	return func(v1, v2 int8) rune {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int8]rune{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt85ToRune(f func(v1, v2, v3, v4, v5 int8) rune) func(v1, v2, v3, v4, v5 int8) rune {
	cache := map[int8]map[int8]map[int8]map[int8]map[int8]rune{}

	return func(v1, v2, v3, v4, v5 int8) rune {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int8]map[int8]map[int8]map[int8]rune{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int8]map[int8]map[int8]rune{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int8]map[int8]rune{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int8]rune{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt82ToString(f func(v1, v2 int8) string) func(v1, v2 int8) string {
	cache := map[int8]map[int8]string{}

	return func(v1, v2 int8) string {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int8]string{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt85ToString(f func(v1, v2, v3, v4, v5 int8) string) func(v1, v2, v3, v4, v5 int8) string {
	cache := map[int8]map[int8]map[int8]map[int8]map[int8]string{}

	return func(v1, v2, v3, v4, v5 int8) string {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int8]map[int8]map[int8]map[int8]string{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int8]map[int8]map[int8]string{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int8]map[int8]string{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int8]string{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt82ToInt(f func(v1, v2 int8) int) func(v1, v2 int8) int {
	cache := map[int8]map[int8]int{}

	return func(v1, v2 int8) int {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int8]int{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt85ToInt(f func(v1, v2, v3, v4, v5 int8) int) func(v1, v2, v3, v4, v5 int8) int {
	cache := map[int8]map[int8]map[int8]map[int8]map[int8]int{}

	return func(v1, v2, v3, v4, v5 int8) int {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int8]map[int8]map[int8]map[int8]int{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int8]map[int8]map[int8]int{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int8]map[int8]int{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int8]int{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt82ToInt8(f func(v1, v2 int8) int8) func(v1, v2 int8) int8 {
	cache := map[int8]map[int8]int8{}

	return func(v1, v2 int8) int8 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int8]int8{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt85ToInt8(f func(v1, v2, v3, v4, v5 int8) int8) func(v1, v2, v3, v4, v5 int8) int8 {
	cache := map[int8]map[int8]map[int8]map[int8]map[int8]int8{}

	return func(v1, v2, v3, v4, v5 int8) int8 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int8]map[int8]map[int8]map[int8]int8{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int8]map[int8]map[int8]int8{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int8]map[int8]int8{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int8]int8{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt82ToInt16(f func(v1, v2 int8) int16) func(v1, v2 int8) int16 {
	cache := map[int8]map[int8]int16{}

	return func(v1, v2 int8) int16 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int8]int16{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt85ToInt16(f func(v1, v2, v3, v4, v5 int8) int16) func(v1, v2, v3, v4, v5 int8) int16 {
	cache := map[int8]map[int8]map[int8]map[int8]map[int8]int16{}

	return func(v1, v2, v3, v4, v5 int8) int16 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int8]map[int8]map[int8]map[int8]int16{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int8]map[int8]map[int8]int16{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int8]map[int8]int16{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int8]int16{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt82ToInt32(f func(v1, v2 int8) int32) func(v1, v2 int8) int32 {
	cache := map[int8]map[int8]int32{}

	return func(v1, v2 int8) int32 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int8]int32{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt85ToInt32(f func(v1, v2, v3, v4, v5 int8) int32) func(v1, v2, v3, v4, v5 int8) int32 {
	cache := map[int8]map[int8]map[int8]map[int8]map[int8]int32{}

	return func(v1, v2, v3, v4, v5 int8) int32 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int8]map[int8]map[int8]map[int8]int32{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int8]map[int8]map[int8]int32{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int8]map[int8]int32{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int8]int32{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt82ToInt64(f func(v1, v2 int8) int64) func(v1, v2 int8) int64 {
	cache := map[int8]map[int8]int64{}

	return func(v1, v2 int8) int64 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int8]int64{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt85ToInt64(f func(v1, v2, v3, v4, v5 int8) int64) func(v1, v2, v3, v4, v5 int8) int64 {
	cache := map[int8]map[int8]map[int8]map[int8]map[int8]int64{}

	return func(v1, v2, v3, v4, v5 int8) int64 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int8]map[int8]map[int8]map[int8]int64{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int8]map[int8]map[int8]int64{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int8]map[int8]int64{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int8]int64{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt82ToFloat32(f func(v1, v2 int8) float32) func(v1, v2 int8) float32 {
	cache := map[int8]map[int8]float32{}

	return func(v1, v2 int8) float32 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int8]float32{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt85ToFloat32(f func(v1, v2, v3, v4, v5 int8) float32) func(v1, v2, v3, v4, v5 int8) float32 {
	cache := map[int8]map[int8]map[int8]map[int8]map[int8]float32{}

	return func(v1, v2, v3, v4, v5 int8) float32 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int8]map[int8]map[int8]map[int8]float32{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int8]map[int8]map[int8]float32{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int8]map[int8]float32{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int8]float32{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt82ToFloat64(f func(v1, v2 int8) float64) func(v1, v2 int8) float64 {
	cache := map[int8]map[int8]float64{}

	return func(v1, v2 int8) float64 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int8]float64{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt85ToFloat64(f func(v1, v2, v3, v4, v5 int8) float64) func(v1, v2, v3, v4, v5 int8) float64 {
	cache := map[int8]map[int8]map[int8]map[int8]map[int8]float64{}

	return func(v1, v2, v3, v4, v5 int8) float64 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int8]map[int8]map[int8]map[int8]float64{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int8]map[int8]map[int8]float64{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int8]map[int8]float64{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int8]float64{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt162ToRune(f func(v1, v2 int16) rune) func(v1, v2 int16) rune {
	cache := map[int16]map[int16]rune{}

	return func(v1, v2 int16) rune {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int16]rune{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt165ToRune(f func(v1, v2, v3, v4, v5 int16) rune) func(v1, v2, v3, v4, v5 int16) rune {
	cache := map[int16]map[int16]map[int16]map[int16]map[int16]rune{}

	return func(v1, v2, v3, v4, v5 int16) rune {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int16]map[int16]map[int16]map[int16]rune{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int16]map[int16]map[int16]rune{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int16]map[int16]rune{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int16]rune{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt162ToString(f func(v1, v2 int16) string) func(v1, v2 int16) string {
	cache := map[int16]map[int16]string{}

	return func(v1, v2 int16) string {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int16]string{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt165ToString(f func(v1, v2, v3, v4, v5 int16) string) func(v1, v2, v3, v4, v5 int16) string {
	cache := map[int16]map[int16]map[int16]map[int16]map[int16]string{}

	return func(v1, v2, v3, v4, v5 int16) string {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int16]map[int16]map[int16]map[int16]string{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int16]map[int16]map[int16]string{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int16]map[int16]string{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int16]string{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt162ToInt(f func(v1, v2 int16) int) func(v1, v2 int16) int {
	cache := map[int16]map[int16]int{}

	return func(v1, v2 int16) int {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int16]int{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt165ToInt(f func(v1, v2, v3, v4, v5 int16) int) func(v1, v2, v3, v4, v5 int16) int {
	cache := map[int16]map[int16]map[int16]map[int16]map[int16]int{}

	return func(v1, v2, v3, v4, v5 int16) int {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int16]map[int16]map[int16]map[int16]int{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int16]map[int16]map[int16]int{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int16]map[int16]int{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int16]int{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt162ToInt8(f func(v1, v2 int16) int8) func(v1, v2 int16) int8 {
	cache := map[int16]map[int16]int8{}

	return func(v1, v2 int16) int8 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int16]int8{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt165ToInt8(f func(v1, v2, v3, v4, v5 int16) int8) func(v1, v2, v3, v4, v5 int16) int8 {
	cache := map[int16]map[int16]map[int16]map[int16]map[int16]int8{}

	return func(v1, v2, v3, v4, v5 int16) int8 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int16]map[int16]map[int16]map[int16]int8{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int16]map[int16]map[int16]int8{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int16]map[int16]int8{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int16]int8{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt162ToInt16(f func(v1, v2 int16) int16) func(v1, v2 int16) int16 {
	cache := map[int16]map[int16]int16{}

	return func(v1, v2 int16) int16 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int16]int16{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt165ToInt16(f func(v1, v2, v3, v4, v5 int16) int16) func(v1, v2, v3, v4, v5 int16) int16 {
	cache := map[int16]map[int16]map[int16]map[int16]map[int16]int16{}

	return func(v1, v2, v3, v4, v5 int16) int16 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int16]map[int16]map[int16]map[int16]int16{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int16]map[int16]map[int16]int16{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int16]map[int16]int16{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int16]int16{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt162ToInt32(f func(v1, v2 int16) int32) func(v1, v2 int16) int32 {
	cache := map[int16]map[int16]int32{}

	return func(v1, v2 int16) int32 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int16]int32{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt165ToInt32(f func(v1, v2, v3, v4, v5 int16) int32) func(v1, v2, v3, v4, v5 int16) int32 {
	cache := map[int16]map[int16]map[int16]map[int16]map[int16]int32{}

	return func(v1, v2, v3, v4, v5 int16) int32 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int16]map[int16]map[int16]map[int16]int32{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int16]map[int16]map[int16]int32{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int16]map[int16]int32{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int16]int32{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt162ToInt64(f func(v1, v2 int16) int64) func(v1, v2 int16) int64 {
	cache := map[int16]map[int16]int64{}

	return func(v1, v2 int16) int64 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int16]int64{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt165ToInt64(f func(v1, v2, v3, v4, v5 int16) int64) func(v1, v2, v3, v4, v5 int16) int64 {
	cache := map[int16]map[int16]map[int16]map[int16]map[int16]int64{}

	return func(v1, v2, v3, v4, v5 int16) int64 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int16]map[int16]map[int16]map[int16]int64{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int16]map[int16]map[int16]int64{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int16]map[int16]int64{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int16]int64{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt162ToFloat32(f func(v1, v2 int16) float32) func(v1, v2 int16) float32 {
	cache := map[int16]map[int16]float32{}

	return func(v1, v2 int16) float32 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int16]float32{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt165ToFloat32(f func(v1, v2, v3, v4, v5 int16) float32) func(v1, v2, v3, v4, v5 int16) float32 {
	cache := map[int16]map[int16]map[int16]map[int16]map[int16]float32{}

	return func(v1, v2, v3, v4, v5 int16) float32 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int16]map[int16]map[int16]map[int16]float32{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int16]map[int16]map[int16]float32{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int16]map[int16]float32{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int16]float32{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt162ToFloat64(f func(v1, v2 int16) float64) func(v1, v2 int16) float64 {
	cache := map[int16]map[int16]float64{}

	return func(v1, v2 int16) float64 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int16]float64{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt165ToFloat64(f func(v1, v2, v3, v4, v5 int16) float64) func(v1, v2, v3, v4, v5 int16) float64 {
	cache := map[int16]map[int16]map[int16]map[int16]map[int16]float64{}

	return func(v1, v2, v3, v4, v5 int16) float64 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int16]map[int16]map[int16]map[int16]float64{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int16]map[int16]map[int16]float64{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int16]map[int16]float64{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int16]float64{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt322ToRune(f func(v1, v2 int32) rune) func(v1, v2 int32) rune {
	cache := map[int32]map[int32]rune{}

	return func(v1, v2 int32) rune {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int32]rune{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt325ToRune(f func(v1, v2, v3, v4, v5 int32) rune) func(v1, v2, v3, v4, v5 int32) rune {
	cache := map[int32]map[int32]map[int32]map[int32]map[int32]rune{}

	return func(v1, v2, v3, v4, v5 int32) rune {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int32]map[int32]map[int32]map[int32]rune{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int32]map[int32]map[int32]rune{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int32]map[int32]rune{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int32]rune{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt322ToString(f func(v1, v2 int32) string) func(v1, v2 int32) string {
	cache := map[int32]map[int32]string{}

	return func(v1, v2 int32) string {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int32]string{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt325ToString(f func(v1, v2, v3, v4, v5 int32) string) func(v1, v2, v3, v4, v5 int32) string {
	cache := map[int32]map[int32]map[int32]map[int32]map[int32]string{}

	return func(v1, v2, v3, v4, v5 int32) string {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int32]map[int32]map[int32]map[int32]string{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int32]map[int32]map[int32]string{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int32]map[int32]string{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int32]string{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt322ToInt(f func(v1, v2 int32) int) func(v1, v2 int32) int {
	cache := map[int32]map[int32]int{}

	return func(v1, v2 int32) int {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int32]int{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt325ToInt(f func(v1, v2, v3, v4, v5 int32) int) func(v1, v2, v3, v4, v5 int32) int {
	cache := map[int32]map[int32]map[int32]map[int32]map[int32]int{}

	return func(v1, v2, v3, v4, v5 int32) int {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int32]map[int32]map[int32]map[int32]int{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int32]map[int32]map[int32]int{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int32]map[int32]int{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int32]int{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt322ToInt8(f func(v1, v2 int32) int8) func(v1, v2 int32) int8 {
	cache := map[int32]map[int32]int8{}

	return func(v1, v2 int32) int8 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int32]int8{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt325ToInt8(f func(v1, v2, v3, v4, v5 int32) int8) func(v1, v2, v3, v4, v5 int32) int8 {
	cache := map[int32]map[int32]map[int32]map[int32]map[int32]int8{}

	return func(v1, v2, v3, v4, v5 int32) int8 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int32]map[int32]map[int32]map[int32]int8{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int32]map[int32]map[int32]int8{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int32]map[int32]int8{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int32]int8{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt322ToInt16(f func(v1, v2 int32) int16) func(v1, v2 int32) int16 {
	cache := map[int32]map[int32]int16{}

	return func(v1, v2 int32) int16 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int32]int16{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt325ToInt16(f func(v1, v2, v3, v4, v5 int32) int16) func(v1, v2, v3, v4, v5 int32) int16 {
	cache := map[int32]map[int32]map[int32]map[int32]map[int32]int16{}

	return func(v1, v2, v3, v4, v5 int32) int16 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int32]map[int32]map[int32]map[int32]int16{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int32]map[int32]map[int32]int16{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int32]map[int32]int16{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int32]int16{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt322ToInt32(f func(v1, v2 int32) int32) func(v1, v2 int32) int32 {
	cache := map[int32]map[int32]int32{}

	return func(v1, v2 int32) int32 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int32]int32{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt325ToInt32(f func(v1, v2, v3, v4, v5 int32) int32) func(v1, v2, v3, v4, v5 int32) int32 {
	cache := map[int32]map[int32]map[int32]map[int32]map[int32]int32{}

	return func(v1, v2, v3, v4, v5 int32) int32 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int32]map[int32]map[int32]map[int32]int32{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int32]map[int32]map[int32]int32{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int32]map[int32]int32{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int32]int32{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt322ToInt64(f func(v1, v2 int32) int64) func(v1, v2 int32) int64 {
	cache := map[int32]map[int32]int64{}

	return func(v1, v2 int32) int64 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int32]int64{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt325ToInt64(f func(v1, v2, v3, v4, v5 int32) int64) func(v1, v2, v3, v4, v5 int32) int64 {
	cache := map[int32]map[int32]map[int32]map[int32]map[int32]int64{}

	return func(v1, v2, v3, v4, v5 int32) int64 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int32]map[int32]map[int32]map[int32]int64{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int32]map[int32]map[int32]int64{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int32]map[int32]int64{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int32]int64{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt322ToFloat32(f func(v1, v2 int32) float32) func(v1, v2 int32) float32 {
	cache := map[int32]map[int32]float32{}

	return func(v1, v2 int32) float32 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int32]float32{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt325ToFloat32(f func(v1, v2, v3, v4, v5 int32) float32) func(v1, v2, v3, v4, v5 int32) float32 {
	cache := map[int32]map[int32]map[int32]map[int32]map[int32]float32{}

	return func(v1, v2, v3, v4, v5 int32) float32 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int32]map[int32]map[int32]map[int32]float32{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int32]map[int32]map[int32]float32{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int32]map[int32]float32{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int32]float32{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt322ToFloat64(f func(v1, v2 int32) float64) func(v1, v2 int32) float64 {
	cache := map[int32]map[int32]float64{}

	return func(v1, v2 int32) float64 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int32]float64{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt325ToFloat64(f func(v1, v2, v3, v4, v5 int32) float64) func(v1, v2, v3, v4, v5 int32) float64 {
	cache := map[int32]map[int32]map[int32]map[int32]map[int32]float64{}

	return func(v1, v2, v3, v4, v5 int32) float64 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int32]map[int32]map[int32]map[int32]float64{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int32]map[int32]map[int32]float64{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int32]map[int32]float64{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int32]float64{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt642ToRune(f func(v1, v2 int64) rune) func(v1, v2 int64) rune {
	cache := map[int64]map[int64]rune{}

	return func(v1, v2 int64) rune {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int64]rune{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt645ToRune(f func(v1, v2, v3, v4, v5 int64) rune) func(v1, v2, v3, v4, v5 int64) rune {
	cache := map[int64]map[int64]map[int64]map[int64]map[int64]rune{}

	return func(v1, v2, v3, v4, v5 int64) rune {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int64]map[int64]map[int64]map[int64]rune{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int64]map[int64]map[int64]rune{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int64]map[int64]rune{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int64]rune{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt642ToString(f func(v1, v2 int64) string) func(v1, v2 int64) string {
	cache := map[int64]map[int64]string{}

	return func(v1, v2 int64) string {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int64]string{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt645ToString(f func(v1, v2, v3, v4, v5 int64) string) func(v1, v2, v3, v4, v5 int64) string {
	cache := map[int64]map[int64]map[int64]map[int64]map[int64]string{}

	return func(v1, v2, v3, v4, v5 int64) string {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int64]map[int64]map[int64]map[int64]string{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int64]map[int64]map[int64]string{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int64]map[int64]string{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int64]string{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt642ToInt(f func(v1, v2 int64) int) func(v1, v2 int64) int {
	cache := map[int64]map[int64]int{}

	return func(v1, v2 int64) int {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int64]int{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt645ToInt(f func(v1, v2, v3, v4, v5 int64) int) func(v1, v2, v3, v4, v5 int64) int {
	cache := map[int64]map[int64]map[int64]map[int64]map[int64]int{}

	return func(v1, v2, v3, v4, v5 int64) int {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int64]map[int64]map[int64]map[int64]int{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int64]map[int64]map[int64]int{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int64]map[int64]int{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int64]int{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt642ToInt8(f func(v1, v2 int64) int8) func(v1, v2 int64) int8 {
	cache := map[int64]map[int64]int8{}

	return func(v1, v2 int64) int8 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int64]int8{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt645ToInt8(f func(v1, v2, v3, v4, v5 int64) int8) func(v1, v2, v3, v4, v5 int64) int8 {
	cache := map[int64]map[int64]map[int64]map[int64]map[int64]int8{}

	return func(v1, v2, v3, v4, v5 int64) int8 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int64]map[int64]map[int64]map[int64]int8{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int64]map[int64]map[int64]int8{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int64]map[int64]int8{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int64]int8{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt642ToInt16(f func(v1, v2 int64) int16) func(v1, v2 int64) int16 {
	cache := map[int64]map[int64]int16{}

	return func(v1, v2 int64) int16 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int64]int16{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt645ToInt16(f func(v1, v2, v3, v4, v5 int64) int16) func(v1, v2, v3, v4, v5 int64) int16 {
	cache := map[int64]map[int64]map[int64]map[int64]map[int64]int16{}

	return func(v1, v2, v3, v4, v5 int64) int16 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int64]map[int64]map[int64]map[int64]int16{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int64]map[int64]map[int64]int16{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int64]map[int64]int16{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int64]int16{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt642ToInt32(f func(v1, v2 int64) int32) func(v1, v2 int64) int32 {
	cache := map[int64]map[int64]int32{}

	return func(v1, v2 int64) int32 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int64]int32{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt645ToInt32(f func(v1, v2, v3, v4, v5 int64) int32) func(v1, v2, v3, v4, v5 int64) int32 {
	cache := map[int64]map[int64]map[int64]map[int64]map[int64]int32{}

	return func(v1, v2, v3, v4, v5 int64) int32 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int64]map[int64]map[int64]map[int64]int32{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int64]map[int64]map[int64]int32{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int64]map[int64]int32{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int64]int32{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt642ToInt64(f func(v1, v2 int64) int64) func(v1, v2 int64) int64 {
	cache := map[int64]map[int64]int64{}

	return func(v1, v2 int64) int64 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int64]int64{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt645ToInt64(f func(v1, v2, v3, v4, v5 int64) int64) func(v1, v2, v3, v4, v5 int64) int64 {
	cache := map[int64]map[int64]map[int64]map[int64]map[int64]int64{}

	return func(v1, v2, v3, v4, v5 int64) int64 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int64]map[int64]map[int64]map[int64]int64{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int64]map[int64]map[int64]int64{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int64]map[int64]int64{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int64]int64{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt642ToFloat32(f func(v1, v2 int64) float32) func(v1, v2 int64) float32 {
	cache := map[int64]map[int64]float32{}

	return func(v1, v2 int64) float32 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int64]float32{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt645ToFloat32(f func(v1, v2, v3, v4, v5 int64) float32) func(v1, v2, v3, v4, v5 int64) float32 {
	cache := map[int64]map[int64]map[int64]map[int64]map[int64]float32{}

	return func(v1, v2, v3, v4, v5 int64) float32 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int64]map[int64]map[int64]map[int64]float32{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int64]map[int64]map[int64]float32{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int64]map[int64]float32{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int64]float32{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeInt642ToFloat64(f func(v1, v2 int64) float64) func(v1, v2 int64) float64 {
	cache := map[int64]map[int64]float64{}

	return func(v1, v2 int64) float64 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[int64]float64{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeInt645ToFloat64(f func(v1, v2, v3, v4, v5 int64) float64) func(v1, v2, v3, v4, v5 int64) float64 {
	cache := map[int64]map[int64]map[int64]map[int64]map[int64]float64{}

	return func(v1, v2, v3, v4, v5 int64) float64 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[int64]map[int64]map[int64]map[int64]float64{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[int64]map[int64]map[int64]float64{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[int64]map[int64]float64{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[int64]float64{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeFloat322ToRune(f func(v1, v2 float32) rune) func(v1, v2 float32) rune {
	cache := map[float32]map[float32]rune{}

	return func(v1, v2 float32) rune {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[float32]rune{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeFloat325ToRune(f func(v1, v2, v3, v4, v5 float32) rune) func(v1, v2, v3, v4, v5 float32) rune {
	cache := map[float32]map[float32]map[float32]map[float32]map[float32]rune{}

	return func(v1, v2, v3, v4, v5 float32) rune {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[float32]map[float32]map[float32]map[float32]rune{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[float32]map[float32]map[float32]rune{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[float32]map[float32]rune{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[float32]rune{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeFloat322ToString(f func(v1, v2 float32) string) func(v1, v2 float32) string {
	cache := map[float32]map[float32]string{}

	return func(v1, v2 float32) string {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[float32]string{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeFloat325ToString(f func(v1, v2, v3, v4, v5 float32) string) func(v1, v2, v3, v4, v5 float32) string {
	cache := map[float32]map[float32]map[float32]map[float32]map[float32]string{}

	return func(v1, v2, v3, v4, v5 float32) string {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[float32]map[float32]map[float32]map[float32]string{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[float32]map[float32]map[float32]string{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[float32]map[float32]string{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[float32]string{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeFloat322ToInt(f func(v1, v2 float32) int) func(v1, v2 float32) int {
	cache := map[float32]map[float32]int{}

	return func(v1, v2 float32) int {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[float32]int{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeFloat325ToInt(f func(v1, v2, v3, v4, v5 float32) int) func(v1, v2, v3, v4, v5 float32) int {
	cache := map[float32]map[float32]map[float32]map[float32]map[float32]int{}

	return func(v1, v2, v3, v4, v5 float32) int {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[float32]map[float32]map[float32]map[float32]int{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[float32]map[float32]map[float32]int{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[float32]map[float32]int{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[float32]int{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeFloat322ToInt8(f func(v1, v2 float32) int8) func(v1, v2 float32) int8 {
	cache := map[float32]map[float32]int8{}

	return func(v1, v2 float32) int8 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[float32]int8{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeFloat325ToInt8(f func(v1, v2, v3, v4, v5 float32) int8) func(v1, v2, v3, v4, v5 float32) int8 {
	cache := map[float32]map[float32]map[float32]map[float32]map[float32]int8{}

	return func(v1, v2, v3, v4, v5 float32) int8 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[float32]map[float32]map[float32]map[float32]int8{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[float32]map[float32]map[float32]int8{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[float32]map[float32]int8{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[float32]int8{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeFloat322ToInt16(f func(v1, v2 float32) int16) func(v1, v2 float32) int16 {
	cache := map[float32]map[float32]int16{}

	return func(v1, v2 float32) int16 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[float32]int16{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeFloat325ToInt16(f func(v1, v2, v3, v4, v5 float32) int16) func(v1, v2, v3, v4, v5 float32) int16 {
	cache := map[float32]map[float32]map[float32]map[float32]map[float32]int16{}

	return func(v1, v2, v3, v4, v5 float32) int16 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[float32]map[float32]map[float32]map[float32]int16{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[float32]map[float32]map[float32]int16{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[float32]map[float32]int16{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[float32]int16{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeFloat322ToInt32(f func(v1, v2 float32) int32) func(v1, v2 float32) int32 {
	cache := map[float32]map[float32]int32{}

	return func(v1, v2 float32) int32 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[float32]int32{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeFloat325ToInt32(f func(v1, v2, v3, v4, v5 float32) int32) func(v1, v2, v3, v4, v5 float32) int32 {
	cache := map[float32]map[float32]map[float32]map[float32]map[float32]int32{}

	return func(v1, v2, v3, v4, v5 float32) int32 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[float32]map[float32]map[float32]map[float32]int32{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[float32]map[float32]map[float32]int32{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[float32]map[float32]int32{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[float32]int32{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeFloat322ToInt64(f func(v1, v2 float32) int64) func(v1, v2 float32) int64 {
	cache := map[float32]map[float32]int64{}

	return func(v1, v2 float32) int64 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[float32]int64{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeFloat325ToInt64(f func(v1, v2, v3, v4, v5 float32) int64) func(v1, v2, v3, v4, v5 float32) int64 {
	cache := map[float32]map[float32]map[float32]map[float32]map[float32]int64{}

	return func(v1, v2, v3, v4, v5 float32) int64 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[float32]map[float32]map[float32]map[float32]int64{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[float32]map[float32]map[float32]int64{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[float32]map[float32]int64{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[float32]int64{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeFloat322ToFloat32(f func(v1, v2 float32) float32) func(v1, v2 float32) float32 {
	cache := map[float32]map[float32]float32{}

	return func(v1, v2 float32) float32 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[float32]float32{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeFloat325ToFloat32(f func(v1, v2, v3, v4, v5 float32) float32) func(v1, v2, v3, v4, v5 float32) float32 {
	cache := map[float32]map[float32]map[float32]map[float32]map[float32]float32{}

	return func(v1, v2, v3, v4, v5 float32) float32 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[float32]map[float32]map[float32]map[float32]float32{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[float32]map[float32]map[float32]float32{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[float32]map[float32]float32{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[float32]float32{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeFloat322ToFloat64(f func(v1, v2 float32) float64) func(v1, v2 float32) float64 {
	cache := map[float32]map[float32]float64{}

	return func(v1, v2 float32) float64 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[float32]float64{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeFloat325ToFloat64(f func(v1, v2, v3, v4, v5 float32) float64) func(v1, v2, v3, v4, v5 float32) float64 {
	cache := map[float32]map[float32]map[float32]map[float32]map[float32]float64{}

	return func(v1, v2, v3, v4, v5 float32) float64 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[float32]map[float32]map[float32]map[float32]float64{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[float32]map[float32]map[float32]float64{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[float32]map[float32]float64{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[float32]float64{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeFloat642ToRune(f func(v1, v2 float64) rune) func(v1, v2 float64) rune {
	cache := map[float64]map[float64]rune{}

	return func(v1, v2 float64) rune {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[float64]rune{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeFloat645ToRune(f func(v1, v2, v3, v4, v5 float64) rune) func(v1, v2, v3, v4, v5 float64) rune {
	cache := map[float64]map[float64]map[float64]map[float64]map[float64]rune{}

	return func(v1, v2, v3, v4, v5 float64) rune {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[float64]map[float64]map[float64]map[float64]rune{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[float64]map[float64]map[float64]rune{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[float64]map[float64]rune{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[float64]rune{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeFloat642ToString(f func(v1, v2 float64) string) func(v1, v2 float64) string {
	cache := map[float64]map[float64]string{}

	return func(v1, v2 float64) string {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[float64]string{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeFloat645ToString(f func(v1, v2, v3, v4, v5 float64) string) func(v1, v2, v3, v4, v5 float64) string {
	cache := map[float64]map[float64]map[float64]map[float64]map[float64]string{}

	return func(v1, v2, v3, v4, v5 float64) string {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[float64]map[float64]map[float64]map[float64]string{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[float64]map[float64]map[float64]string{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[float64]map[float64]string{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[float64]string{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeFloat642ToInt(f func(v1, v2 float64) int) func(v1, v2 float64) int {
	cache := map[float64]map[float64]int{}

	return func(v1, v2 float64) int {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[float64]int{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeFloat645ToInt(f func(v1, v2, v3, v4, v5 float64) int) func(v1, v2, v3, v4, v5 float64) int {
	cache := map[float64]map[float64]map[float64]map[float64]map[float64]int{}

	return func(v1, v2, v3, v4, v5 float64) int {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[float64]map[float64]map[float64]map[float64]int{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[float64]map[float64]map[float64]int{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[float64]map[float64]int{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[float64]int{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeFloat642ToInt8(f func(v1, v2 float64) int8) func(v1, v2 float64) int8 {
	cache := map[float64]map[float64]int8{}

	return func(v1, v2 float64) int8 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[float64]int8{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeFloat645ToInt8(f func(v1, v2, v3, v4, v5 float64) int8) func(v1, v2, v3, v4, v5 float64) int8 {
	cache := map[float64]map[float64]map[float64]map[float64]map[float64]int8{}

	return func(v1, v2, v3, v4, v5 float64) int8 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[float64]map[float64]map[float64]map[float64]int8{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[float64]map[float64]map[float64]int8{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[float64]map[float64]int8{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[float64]int8{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeFloat642ToInt16(f func(v1, v2 float64) int16) func(v1, v2 float64) int16 {
	cache := map[float64]map[float64]int16{}

	return func(v1, v2 float64) int16 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[float64]int16{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeFloat645ToInt16(f func(v1, v2, v3, v4, v5 float64) int16) func(v1, v2, v3, v4, v5 float64) int16 {
	cache := map[float64]map[float64]map[float64]map[float64]map[float64]int16{}

	return func(v1, v2, v3, v4, v5 float64) int16 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[float64]map[float64]map[float64]map[float64]int16{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[float64]map[float64]map[float64]int16{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[float64]map[float64]int16{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[float64]int16{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeFloat642ToInt32(f func(v1, v2 float64) int32) func(v1, v2 float64) int32 {
	cache := map[float64]map[float64]int32{}

	return func(v1, v2 float64) int32 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[float64]int32{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeFloat645ToInt32(f func(v1, v2, v3, v4, v5 float64) int32) func(v1, v2, v3, v4, v5 float64) int32 {
	cache := map[float64]map[float64]map[float64]map[float64]map[float64]int32{}

	return func(v1, v2, v3, v4, v5 float64) int32 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[float64]map[float64]map[float64]map[float64]int32{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[float64]map[float64]map[float64]int32{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[float64]map[float64]int32{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[float64]int32{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeFloat642ToInt64(f func(v1, v2 float64) int64) func(v1, v2 float64) int64 {
	cache := map[float64]map[float64]int64{}

	return func(v1, v2 float64) int64 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[float64]int64{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeFloat645ToInt64(f func(v1, v2, v3, v4, v5 float64) int64) func(v1, v2, v3, v4, v5 float64) int64 {
	cache := map[float64]map[float64]map[float64]map[float64]map[float64]int64{}

	return func(v1, v2, v3, v4, v5 float64) int64 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[float64]map[float64]map[float64]map[float64]int64{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[float64]map[float64]map[float64]int64{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[float64]map[float64]int64{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[float64]int64{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeFloat642ToFloat32(f func(v1, v2 float64) float32) func(v1, v2 float64) float32 {
	cache := map[float64]map[float64]float32{}

	return func(v1, v2 float64) float32 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[float64]float32{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeFloat645ToFloat32(f func(v1, v2, v3, v4, v5 float64) float32) func(v1, v2, v3, v4, v5 float64) float32 {
	cache := map[float64]map[float64]map[float64]map[float64]map[float64]float32{}

	return func(v1, v2, v3, v4, v5 float64) float32 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[float64]map[float64]map[float64]map[float64]float32{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[float64]map[float64]map[float64]float32{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[float64]map[float64]float32{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[float64]float32{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

func lib_MemoizeFloat642ToFloat64(f func(v1, v2 float64) float64) func(v1, v2 float64) float64 {
	cache := map[float64]map[float64]float64{}

	return func(v1, v2 float64) float64 {
		if v1Map, ok := cache[v1]; ok {
			if cachedValue, ok := v1Map[v2]; ok {
				return cachedValue
			}
		}

		result := f(v1, v2)
		_, v1Ok := cache[v1]
		if !v1Ok {
			cache[v1] = map[float64]float64{}
		}

		cache[v1][v2] = result
		return result
	}
}

func lib_MemoizeFloat645ToFloat64(f func(v1, v2, v3, v4, v5 float64) float64) func(v1, v2, v3, v4, v5 float64) float64 {
	cache := map[float64]map[float64]map[float64]map[float64]map[float64]float64{}

	return func(v1, v2, v3, v4, v5 float64) float64 {
		if _, ok := cache[v1]; !ok {
			cache[v1] = map[float64]map[float64]map[float64]map[float64]float64{}
		}
		if _, ok := cache[v1][v2]; !ok {
			cache[v1][v2] = map[float64]map[float64]map[float64]float64{}
		}
		if _, ok := cache[v1][v2][v3]; !ok {
			cache[v1][v2][v3] = map[float64]map[float64]float64{}
		}
		if _, ok := cache[v1][v2][v3][v4]; !ok {
			cache[v1][v2][v3][v4] = map[float64]float64{}
		}
		if cachedValue, ok := cache[v1][v2][v3][v4][v5]; ok {
			return cachedValue
		}

		result := f(v1, v2, v3, v4, v5)
		cache[v1][v2][v3][v4][v5] = result
		return result
	}
}

type lib_Graph struct {
	AdjacencyMatrix [][]bool
}

func lib_NewGraph(nodeNum int, edges [][]int, directed bool) (*lib_Graph, error) {
	if nodeNum < 1 {
		return nil, fmt.Errorf("invalid nodeNum: %d", nodeNum)
	}

	var aMatrix [][]bool
	for i := 0; i < nodeNum; i++ {
		line := make([]bool, nodeNum)
		aMatrix = append(aMatrix, line)
	}

	for _, edge := range edges {
		aMatrix[edge[0]][edge[1]] = true
		if !directed {
			aMatrix[edge[1]][edge[0]] = true
		}
	}

	return &lib_Graph{AdjacencyMatrix: aMatrix}, nil
}

func (g *lib_Graph) IsValidPath(path []int) bool {
	for i := 1; i < len(path); i++ {
		if !g.AdjacencyMatrix[path[i-1]][path[i]] {
			return false
		}
	}
	return true
}

func lib_toLines(scanner *bufio.Scanner) [][]string {
	var lines [][]string
	for scanner.Scan() {
		text := lib_TrimSpaceAndNewLineCodeAndTab(scanner.Text())
		if len(text) == 0 {
			lines = append(lines, []string{})
			continue
		}
		line := strings.Split(text, " ")
		lines = append(lines, line)
	}
	return lines
}

func lib_toLinesFromReader(reader *bufio.Reader) (lines [][]string, err error) {
	for {
		chunks, err := lib_readLineAsChunks(reader)
		if err == io.EOF {
			return lines, nil
		}

		if err != nil {
			return nil, fmt.Errorf("failed to read line from reader: %v", err)
		}
		lineStr := lib_TrimSpaceAndNewLineCodeAndTab(strings.Join(chunks, ""))
		line := strings.Split(lineStr, " ")
		lines = append(lines, line)
	}
}

func lib_readLineAsChunks(reader *bufio.Reader) (chunks []string, err error) {
	for {
		chunk, isPrefix, err := reader.ReadLine()
		if err != nil {
			return nil, err
		}
		chunks = append(chunks, string(chunk))
		if !isPrefix {
			return chunks, nil
		}
	}
}

type lib_Input struct {
	lines [][]string
}

func (i *lib_Input) validateColIndex(index int) error {
	if index < 0 {
		return errors.New(fmt.Sprintf("index is under zero: %d", index))
	}

	return nil
}

func (i *lib_Input) validateRowIndex(index int) error {
	if index >= len(i.lines) {
		return errors.New(fmt.Sprintf("index(%d) is larger than lines(%d)", index, len(i.lines)))
	}

	if index < 0 {
		return errors.New(fmt.Sprintf("index is under zero: %d", index))
	}
	return nil
}

func (i *lib_Input) GetLines(startRowIndex, endRowIndex int) ([][]string, error) {
	if err := i.validateRowIndex(startRowIndex); err != nil {
		return nil, fmt.Errorf("invalid start row index: %v", err)
	}
	if err := i.validateRowIndex(endRowIndex - 1); err != nil {
		return nil, fmt.Errorf("invalid end row index: %v", err)
	}
	return i.lines[startRowIndex:endRowIndex], nil
}

func (i *lib_Input) GetStringLinesFrom(fromIndex int) (newLines [][]string, err error) {
	for index := range i.lines {
		if index < fromIndex {
			continue
		}
		newLine, err := i.GetLine(index)
		if err != nil {
			return nil, err
		}
		newLines = append(newLines, newLine)
	}
	return
}

func (i *lib_Input) GetValue(rowIndex, colIndex int) (string, error) {
	line, err := i.GetLine(rowIndex)
	if err != nil {
		return "", err
	}
	if colIndex < 0 || colIndex >= len(line) {
		return "", fmt.Errorf("Invalid col index: %v ", colIndex)
	}
	return line[colIndex], nil
}

func (i *lib_Input) GetFirstValue(rowIndex int) (string, error) {
	return i.GetValue(rowIndex, 0)
}

func (i *lib_Input) GetColLine(colIndex int) (newLine []string, err error) {
	if err := i.validateColIndex(colIndex); err != nil {
		return nil, err
	}

	for i, line := range i.lines {
		if len(line) <= colIndex {
			return nil, errors.New(fmt.Sprintf("col index(%d) is larger than %dth line length(%d)", colIndex, i, len(line)))
		}
		newLine = append(newLine, line[colIndex])
	}

	return newLine, nil
}

func (i *lib_Input) GetLine(index int) ([]string, error) {
	if err := i.validateRowIndex(index); err != nil {
		return nil, err
	}
	return i.lines[index], nil
}

func (i *lib_Input) ReadAsStringGridFrom(fromIndex int) ([][]string, error) {
	lines, err := i.GetStringLinesFrom(fromIndex)
	if err != nil {
		return nil, err
	}

	var m [][]string
	for _, line := range lines {
		if len(line) > 1 {
			return nil, fmt.Errorf("unexpected length line: %v", line)
		}

		var mLine []string
		for _, r := range line[0] {
			mLine = append(mLine, string(r))
		}
		m = append(m, mLine)
	}
	return m, nil
}

func lib_NewInput(scanner *bufio.Scanner) *lib_Input {
	return &lib_Input{
		lines: lib_toLines(scanner),
	}
}

func lib_NewInputFromReader(reader *bufio.Reader) (*lib_Input, error) {
	lines, err := lib_toLinesFromReader(reader)
	if err != nil {
		return nil, fmt.Errorf("failed to create new Input from reader: %v", err)
	}
	return &lib_Input{
		lines: lines,
	}, nil
}

func (i *lib_Input) MustGetIntLines() (newLines [][]int) {
	newLines, err := i.GetIntLines()
	if err != nil {
		panic(err)
	}
	return newLines
}

func (i *lib_Input) MustGetIntLinesFrom(fromIndex int) (newLines [][]int) {
	newLines, err := i.GetIntLinesFrom(fromIndex)
	if err != nil {
		panic(err)
	}
	return newLines
}

func (i *lib_Input) MustGetIntLineRange(fromRowIndex, rangeNum int) (newLines [][]int) {
	newLines, err := i.GetIntLineRange(fromRowIndex, rangeNum)
	if err != nil {
		panic(err)
	}
	return newLines
}

func (i *lib_Input) MustGetIntLine(index int) []int {
	v, err := i.GetIntLine(index)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetIntValue(rowIndex, colIndex int) int {
	v, err := i.GetIntValue(rowIndex, colIndex)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetFirstIntValue(rowIndex int) int {
	v, err := i.GetFirstIntValue(rowIndex)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetColIntLine(colIndex int) (newLine []int) {
	newLine, err := i.GetColIntLine(colIndex)
	if err != nil {
		panic(err)
	}
	return newLine
}

func (i *lib_Input) MustGetInt8Lines() (newLines [][]int8) {
	newLines, err := i.GetInt8Lines()
	if err != nil {
		panic(err)
	}
	return newLines
}

func (i *lib_Input) MustGetInt8LinesFrom(fromIndex int) (newLines [][]int8) {
	newLines, err := i.GetInt8LinesFrom(fromIndex)
	if err != nil {
		panic(err)
	}
	return newLines
}

func (i *lib_Input) MustGetInt8LineRange(fromRowIndex, rangeNum int) (newLines [][]int8) {
	newLines, err := i.GetInt8LineRange(fromRowIndex, rangeNum)
	if err != nil {
		panic(err)
	}
	return newLines
}

func (i *lib_Input) MustGetInt8Line(index int) []int8 {
	v, err := i.GetInt8Line(index)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetInt8Value(rowIndex, colIndex int) int8 {
	v, err := i.GetInt8Value(rowIndex, colIndex)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetFirstInt8Value(rowIndex int) int8 {
	v, err := i.GetFirstInt8Value(rowIndex)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetColInt8Line(colIndex int) (newLine []int8) {
	newLine, err := i.GetColInt8Line(colIndex)
	if err != nil {
		panic(err)
	}
	return newLine
}

func (i *lib_Input) MustGetInt16Lines() (newLines [][]int16) {
	newLines, err := i.GetInt16Lines()
	if err != nil {
		panic(err)
	}
	return newLines
}

func (i *lib_Input) MustGetInt16LinesFrom(fromIndex int) (newLines [][]int16) {
	newLines, err := i.GetInt16LinesFrom(fromIndex)
	if err != nil {
		panic(err)
	}
	return newLines
}

func (i *lib_Input) MustGetInt16LineRange(fromRowIndex, rangeNum int) (newLines [][]int16) {
	newLines, err := i.GetInt16LineRange(fromRowIndex, rangeNum)
	if err != nil {
		panic(err)
	}
	return newLines
}

func (i *lib_Input) MustGetInt16Line(index int) []int16 {
	v, err := i.GetInt16Line(index)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetInt16Value(rowIndex, colIndex int) int16 {
	v, err := i.GetInt16Value(rowIndex, colIndex)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetFirstInt16Value(rowIndex int) int16 {
	v, err := i.GetFirstInt16Value(rowIndex)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetColInt16Line(colIndex int) (newLine []int16) {
	newLine, err := i.GetColInt16Line(colIndex)
	if err != nil {
		panic(err)
	}
	return newLine
}

func (i *lib_Input) MustGetInt32Lines() (newLines [][]int32) {
	newLines, err := i.GetInt32Lines()
	if err != nil {
		panic(err)
	}
	return newLines
}

func (i *lib_Input) MustGetInt32LinesFrom(fromIndex int) (newLines [][]int32) {
	newLines, err := i.GetInt32LinesFrom(fromIndex)
	if err != nil {
		panic(err)
	}
	return newLines
}

func (i *lib_Input) MustGetInt32LineRange(fromRowIndex, rangeNum int) (newLines [][]int32) {
	newLines, err := i.GetInt32LineRange(fromRowIndex, rangeNum)
	if err != nil {
		panic(err)
	}
	return newLines
}

func (i *lib_Input) MustGetInt32Line(index int) []int32 {
	v, err := i.GetInt32Line(index)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetInt32Value(rowIndex, colIndex int) int32 {
	v, err := i.GetInt32Value(rowIndex, colIndex)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetFirstInt32Value(rowIndex int) int32 {
	v, err := i.GetFirstInt32Value(rowIndex)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetColInt32Line(colIndex int) (newLine []int32) {
	newLine, err := i.GetColInt32Line(colIndex)
	if err != nil {
		panic(err)
	}
	return newLine
}

func (i *lib_Input) MustGetInt64Lines() (newLines [][]int64) {
	newLines, err := i.GetInt64Lines()
	if err != nil {
		panic(err)
	}
	return newLines
}

func (i *lib_Input) MustGetInt64LinesFrom(fromIndex int) (newLines [][]int64) {
	newLines, err := i.GetInt64LinesFrom(fromIndex)
	if err != nil {
		panic(err)
	}
	return newLines
}

func (i *lib_Input) MustGetInt64LineRange(fromRowIndex, rangeNum int) (newLines [][]int64) {
	newLines, err := i.GetInt64LineRange(fromRowIndex, rangeNum)
	if err != nil {
		panic(err)
	}
	return newLines
}

func (i *lib_Input) MustGetInt64Line(index int) []int64 {
	v, err := i.GetInt64Line(index)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetInt64Value(rowIndex, colIndex int) int64 {
	v, err := i.GetInt64Value(rowIndex, colIndex)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetFirstInt64Value(rowIndex int) int64 {
	v, err := i.GetFirstInt64Value(rowIndex)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetColInt64Line(colIndex int) (newLine []int64) {
	newLine, err := i.GetColInt64Line(colIndex)
	if err != nil {
		panic(err)
	}
	return newLine
}

func (i *lib_Input) MustGetFloat32Lines() (newLines [][]float32) {
	newLines, err := i.GetFloat32Lines()
	if err != nil {
		panic(err)
	}
	return newLines
}

func (i *lib_Input) MustGetFloat32LinesFrom(fromIndex int) (newLines [][]float32) {
	newLines, err := i.GetFloat32LinesFrom(fromIndex)
	if err != nil {
		panic(err)
	}
	return newLines
}

func (i *lib_Input) MustGetFloat32LineRange(fromRowIndex, rangeNum int) (newLines [][]float32) {
	newLines, err := i.GetFloat32LineRange(fromRowIndex, rangeNum)
	if err != nil {
		panic(err)
	}
	return newLines
}

func (i *lib_Input) MustGetFloat32Line(index int) []float32 {
	v, err := i.GetFloat32Line(index)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetFloat32Value(rowIndex, colIndex int) float32 {
	v, err := i.GetFloat32Value(rowIndex, colIndex)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetFirstFloat32Value(rowIndex int) float32 {
	v, err := i.GetFirstFloat32Value(rowIndex)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetColFloat32Line(colIndex int) (newLine []float32) {
	newLine, err := i.GetColFloat32Line(colIndex)
	if err != nil {
		panic(err)
	}
	return newLine
}

func (i *lib_Input) MustGetFloat64Lines() (newLines [][]float64) {
	newLines, err := i.GetFloat64Lines()
	if err != nil {
		panic(err)
	}
	return newLines
}

func (i *lib_Input) MustGetFloat64LinesFrom(fromIndex int) (newLines [][]float64) {
	newLines, err := i.GetFloat64LinesFrom(fromIndex)
	if err != nil {
		panic(err)
	}
	return newLines
}

func (i *lib_Input) MustGetFloat64LineRange(fromRowIndex, rangeNum int) (newLines [][]float64) {
	newLines, err := i.GetFloat64LineRange(fromRowIndex, rangeNum)
	if err != nil {
		panic(err)
	}
	return newLines
}

func (i *lib_Input) MustGetFloat64Line(index int) []float64 {
	v, err := i.GetFloat64Line(index)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetFloat64Value(rowIndex, colIndex int) float64 {
	v, err := i.GetFloat64Value(rowIndex, colIndex)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetFirstFloat64Value(rowIndex int) float64 {
	v, err := i.GetFirstFloat64Value(rowIndex)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetColFloat64Line(colIndex int) (newLine []float64) {
	newLine, err := i.GetColFloat64Line(colIndex)
	if err != nil {
		panic(err)
	}
	return newLine
}

func lib_MustSubtractIntBy(values1 []int, values2 []int, f func(v int) int) (newValues []int) {
	newValues, err := lib_SubtractIntBy(values1, values2, f)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustSubtractInt(values1 []int, values2 []int) (newValues []int) {
	newValues, err := lib_SubtractInt(values1, values2)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustRDiffIntBy(values []int, f func(v int) int) (newValues []int) {
	newValues, err := lib_RDiffIntBy(values, f)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustRDiffInt(values []int) (newValues []int) {
	newValues, err := lib_RDiffInt(values)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustStringToIntSlice(s string) (ValueLine []int) {
	ValueLine, err := lib_StringToIntSlice(s)
	if err != nil {
		panic(err)
	}
	return ValueLine
}

func lib_MustStringSliceToIntSlice(line []string) (ValueLine []int) {
	ValueLine, err := lib_StringSliceToIntSlice(line)
	if err != nil {
		panic(err)
	}
	return ValueLine
}

func lib_MustMaxInt(values []int) (max int) {
	max, err := lib_MaxInt(values)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxIntVA(values ...int) (max int) {
	max, err := lib_MaxIntVA(values...)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMinInt(values []int) (min int) {
	min, err := lib_MinInt(values)
	if err != nil {
		panic(err)
	}
	return min
}

func lib_MustSubtractInt8By(values1 []int8, values2 []int8, f func(v int8) int8) (newValues []int8) {
	newValues, err := lib_SubtractInt8By(values1, values2, f)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustSubtractInt8(values1 []int8, values2 []int8) (newValues []int8) {
	newValues, err := lib_SubtractInt8(values1, values2)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustRDiffInt8By(values []int8, f func(v int8) int8) (newValues []int8) {
	newValues, err := lib_RDiffInt8By(values, f)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustRDiffInt8(values []int8) (newValues []int8) {
	newValues, err := lib_RDiffInt8(values)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustStringToInt8Slice(s string) (ValueLine []int8) {
	ValueLine, err := lib_StringToInt8Slice(s)
	if err != nil {
		panic(err)
	}
	return ValueLine
}

func lib_MustStringSliceToInt8Slice(line []string) (ValueLine []int8) {
	ValueLine, err := lib_StringSliceToInt8Slice(line)
	if err != nil {
		panic(err)
	}
	return ValueLine
}

func lib_MustMaxInt8(values []int8) (max int8) {
	max, err := lib_MaxInt8(values)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt8VA(values ...int8) (max int8) {
	max, err := lib_MaxInt8VA(values...)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMinInt8(values []int8) (min int8) {
	min, err := lib_MinInt8(values)
	if err != nil {
		panic(err)
	}
	return min
}

func lib_MustSubtractInt16By(values1 []int16, values2 []int16, f func(v int16) int16) (newValues []int16) {
	newValues, err := lib_SubtractInt16By(values1, values2, f)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustSubtractInt16(values1 []int16, values2 []int16) (newValues []int16) {
	newValues, err := lib_SubtractInt16(values1, values2)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustRDiffInt16By(values []int16, f func(v int16) int16) (newValues []int16) {
	newValues, err := lib_RDiffInt16By(values, f)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustRDiffInt16(values []int16) (newValues []int16) {
	newValues, err := lib_RDiffInt16(values)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustStringToInt16Slice(s string) (ValueLine []int16) {
	ValueLine, err := lib_StringToInt16Slice(s)
	if err != nil {
		panic(err)
	}
	return ValueLine
}

func lib_MustStringSliceToInt16Slice(line []string) (ValueLine []int16) {
	ValueLine, err := lib_StringSliceToInt16Slice(line)
	if err != nil {
		panic(err)
	}
	return ValueLine
}

func lib_MustMaxInt16(values []int16) (max int16) {
	max, err := lib_MaxInt16(values)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt16VA(values ...int16) (max int16) {
	max, err := lib_MaxInt16VA(values...)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMinInt16(values []int16) (min int16) {
	min, err := lib_MinInt16(values)
	if err != nil {
		panic(err)
	}
	return min
}

func lib_MustSubtractInt32By(values1 []int32, values2 []int32, f func(v int32) int32) (newValues []int32) {
	newValues, err := lib_SubtractInt32By(values1, values2, f)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustSubtractInt32(values1 []int32, values2 []int32) (newValues []int32) {
	newValues, err := lib_SubtractInt32(values1, values2)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustRDiffInt32By(values []int32, f func(v int32) int32) (newValues []int32) {
	newValues, err := lib_RDiffInt32By(values, f)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustRDiffInt32(values []int32) (newValues []int32) {
	newValues, err := lib_RDiffInt32(values)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustStringToInt32Slice(s string) (ValueLine []int32) {
	ValueLine, err := lib_StringToInt32Slice(s)
	if err != nil {
		panic(err)
	}
	return ValueLine
}

func lib_MustStringSliceToInt32Slice(line []string) (ValueLine []int32) {
	ValueLine, err := lib_StringSliceToInt32Slice(line)
	if err != nil {
		panic(err)
	}
	return ValueLine
}

func lib_MustMaxInt32(values []int32) (max int32) {
	max, err := lib_MaxInt32(values)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt32VA(values ...int32) (max int32) {
	max, err := lib_MaxInt32VA(values...)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMinInt32(values []int32) (min int32) {
	min, err := lib_MinInt32(values)
	if err != nil {
		panic(err)
	}
	return min
}

func lib_MustSubtractInt64By(values1 []int64, values2 []int64, f func(v int64) int64) (newValues []int64) {
	newValues, err := lib_SubtractInt64By(values1, values2, f)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustSubtractInt64(values1 []int64, values2 []int64) (newValues []int64) {
	newValues, err := lib_SubtractInt64(values1, values2)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustRDiffInt64By(values []int64, f func(v int64) int64) (newValues []int64) {
	newValues, err := lib_RDiffInt64By(values, f)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustRDiffInt64(values []int64) (newValues []int64) {
	newValues, err := lib_RDiffInt64(values)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustStringToInt64Slice(s string) (ValueLine []int64) {
	ValueLine, err := lib_StringToInt64Slice(s)
	if err != nil {
		panic(err)
	}
	return ValueLine
}

func lib_MustStringSliceToInt64Slice(line []string) (ValueLine []int64) {
	ValueLine, err := lib_StringSliceToInt64Slice(line)
	if err != nil {
		panic(err)
	}
	return ValueLine
}

func lib_MustMaxInt64(values []int64) (max int64) {
	max, err := lib_MaxInt64(values)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt64VA(values ...int64) (max int64) {
	max, err := lib_MaxInt64VA(values...)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMinInt64(values []int64) (min int64) {
	min, err := lib_MinInt64(values)
	if err != nil {
		panic(err)
	}
	return min
}

func lib_MustSubtractFloat32By(values1 []float32, values2 []float32, f func(v float32) float32) (newValues []float32) {
	newValues, err := lib_SubtractFloat32By(values1, values2, f)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustSubtractFloat32(values1 []float32, values2 []float32) (newValues []float32) {
	newValues, err := lib_SubtractFloat32(values1, values2)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustRDiffFloat32By(values []float32, f func(v float32) float32) (newValues []float32) {
	newValues, err := lib_RDiffFloat32By(values, f)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustRDiffFloat32(values []float32) (newValues []float32) {
	newValues, err := lib_RDiffFloat32(values)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustStringToFloat32Slice(s string) (ValueLine []float32) {
	ValueLine, err := lib_StringToFloat32Slice(s)
	if err != nil {
		panic(err)
	}
	return ValueLine
}

func lib_MustStringSliceToFloat32Slice(line []string) (ValueLine []float32) {
	ValueLine, err := lib_StringSliceToFloat32Slice(line)
	if err != nil {
		panic(err)
	}
	return ValueLine
}

func lib_MustMaxFloat32(values []float32) (max float32) {
	max, err := lib_MaxFloat32(values)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat32VA(values ...float32) (max float32) {
	max, err := lib_MaxFloat32VA(values...)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMinFloat32(values []float32) (min float32) {
	min, err := lib_MinFloat32(values)
	if err != nil {
		panic(err)
	}
	return min
}

func lib_MustSubtractFloat64By(values1 []float64, values2 []float64, f func(v float64) float64) (newValues []float64) {
	newValues, err := lib_SubtractFloat64By(values1, values2, f)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustSubtractFloat64(values1 []float64, values2 []float64) (newValues []float64) {
	newValues, err := lib_SubtractFloat64(values1, values2)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustRDiffFloat64By(values []float64, f func(v float64) float64) (newValues []float64) {
	newValues, err := lib_RDiffFloat64By(values, f)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustRDiffFloat64(values []float64) (newValues []float64) {
	newValues, err := lib_RDiffFloat64(values)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustStringToFloat64Slice(s string) (ValueLine []float64) {
	ValueLine, err := lib_StringToFloat64Slice(s)
	if err != nil {
		panic(err)
	}
	return ValueLine
}

func lib_MustStringSliceToFloat64Slice(line []string) (ValueLine []float64) {
	ValueLine, err := lib_StringSliceToFloat64Slice(line)
	if err != nil {
		panic(err)
	}
	return ValueLine
}

func lib_MustMaxFloat64(values []float64) (max float64) {
	max, err := lib_MaxFloat64(values)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat64VA(values ...float64) (max float64) {
	max, err := lib_MaxFloat64VA(values...)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMinFloat64(values []float64) (min float64) {
	min, err := lib_MinFloat64(values)
	if err != nil {
		panic(err)
	}
	return min
}

func lib_MustMaxIntByIntSlice(values [][]int, f func(vs []int) int) (max int) {
	max, err := lib_MaxIntByIntSlice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxIntByIntSlice2(values [][][]int, f func(vs [][]int) int) (max int) {
	max, err := lib_MaxIntByIntSlice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxIntByInt8Slice(values [][]int8, f func(vs []int8) int) (max int) {
	max, err := lib_MaxIntByInt8Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxIntByInt8Slice2(values [][][]int8, f func(vs [][]int8) int) (max int) {
	max, err := lib_MaxIntByInt8Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxIntByInt16Slice(values [][]int16, f func(vs []int16) int) (max int) {
	max, err := lib_MaxIntByInt16Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxIntByInt16Slice2(values [][][]int16, f func(vs [][]int16) int) (max int) {
	max, err := lib_MaxIntByInt16Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxIntByInt32Slice(values [][]int32, f func(vs []int32) int) (max int) {
	max, err := lib_MaxIntByInt32Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxIntByInt32Slice2(values [][][]int32, f func(vs [][]int32) int) (max int) {
	max, err := lib_MaxIntByInt32Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxIntByInt64Slice(values [][]int64, f func(vs []int64) int) (max int) {
	max, err := lib_MaxIntByInt64Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxIntByInt64Slice2(values [][][]int64, f func(vs [][]int64) int) (max int) {
	max, err := lib_MaxIntByInt64Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxIntByFloat32Slice(values [][]float32, f func(vs []float32) int) (max int) {
	max, err := lib_MaxIntByFloat32Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxIntByFloat32Slice2(values [][][]float32, f func(vs [][]float32) int) (max int) {
	max, err := lib_MaxIntByFloat32Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxIntByFloat64Slice(values [][]float64, f func(vs []float64) int) (max int) {
	max, err := lib_MaxIntByFloat64Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxIntByFloat64Slice2(values [][][]float64, f func(vs [][]float64) int) (max int) {
	max, err := lib_MaxIntByFloat64Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt8ByIntSlice(values [][]int, f func(vs []int) int8) (max int8) {
	max, err := lib_MaxInt8ByIntSlice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt8ByIntSlice2(values [][][]int, f func(vs [][]int) int8) (max int8) {
	max, err := lib_MaxInt8ByIntSlice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt8ByInt8Slice(values [][]int8, f func(vs []int8) int8) (max int8) {
	max, err := lib_MaxInt8ByInt8Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt8ByInt8Slice2(values [][][]int8, f func(vs [][]int8) int8) (max int8) {
	max, err := lib_MaxInt8ByInt8Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt8ByInt16Slice(values [][]int16, f func(vs []int16) int8) (max int8) {
	max, err := lib_MaxInt8ByInt16Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt8ByInt16Slice2(values [][][]int16, f func(vs [][]int16) int8) (max int8) {
	max, err := lib_MaxInt8ByInt16Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt8ByInt32Slice(values [][]int32, f func(vs []int32) int8) (max int8) {
	max, err := lib_MaxInt8ByInt32Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt8ByInt32Slice2(values [][][]int32, f func(vs [][]int32) int8) (max int8) {
	max, err := lib_MaxInt8ByInt32Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt8ByInt64Slice(values [][]int64, f func(vs []int64) int8) (max int8) {
	max, err := lib_MaxInt8ByInt64Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt8ByInt64Slice2(values [][][]int64, f func(vs [][]int64) int8) (max int8) {
	max, err := lib_MaxInt8ByInt64Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt8ByFloat32Slice(values [][]float32, f func(vs []float32) int8) (max int8) {
	max, err := lib_MaxInt8ByFloat32Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt8ByFloat32Slice2(values [][][]float32, f func(vs [][]float32) int8) (max int8) {
	max, err := lib_MaxInt8ByFloat32Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt8ByFloat64Slice(values [][]float64, f func(vs []float64) int8) (max int8) {
	max, err := lib_MaxInt8ByFloat64Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt8ByFloat64Slice2(values [][][]float64, f func(vs [][]float64) int8) (max int8) {
	max, err := lib_MaxInt8ByFloat64Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt16ByIntSlice(values [][]int, f func(vs []int) int16) (max int16) {
	max, err := lib_MaxInt16ByIntSlice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt16ByIntSlice2(values [][][]int, f func(vs [][]int) int16) (max int16) {
	max, err := lib_MaxInt16ByIntSlice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt16ByInt8Slice(values [][]int8, f func(vs []int8) int16) (max int16) {
	max, err := lib_MaxInt16ByInt8Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt16ByInt8Slice2(values [][][]int8, f func(vs [][]int8) int16) (max int16) {
	max, err := lib_MaxInt16ByInt8Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt16ByInt16Slice(values [][]int16, f func(vs []int16) int16) (max int16) {
	max, err := lib_MaxInt16ByInt16Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt16ByInt16Slice2(values [][][]int16, f func(vs [][]int16) int16) (max int16) {
	max, err := lib_MaxInt16ByInt16Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt16ByInt32Slice(values [][]int32, f func(vs []int32) int16) (max int16) {
	max, err := lib_MaxInt16ByInt32Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt16ByInt32Slice2(values [][][]int32, f func(vs [][]int32) int16) (max int16) {
	max, err := lib_MaxInt16ByInt32Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt16ByInt64Slice(values [][]int64, f func(vs []int64) int16) (max int16) {
	max, err := lib_MaxInt16ByInt64Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt16ByInt64Slice2(values [][][]int64, f func(vs [][]int64) int16) (max int16) {
	max, err := lib_MaxInt16ByInt64Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt16ByFloat32Slice(values [][]float32, f func(vs []float32) int16) (max int16) {
	max, err := lib_MaxInt16ByFloat32Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt16ByFloat32Slice2(values [][][]float32, f func(vs [][]float32) int16) (max int16) {
	max, err := lib_MaxInt16ByFloat32Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt16ByFloat64Slice(values [][]float64, f func(vs []float64) int16) (max int16) {
	max, err := lib_MaxInt16ByFloat64Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt16ByFloat64Slice2(values [][][]float64, f func(vs [][]float64) int16) (max int16) {
	max, err := lib_MaxInt16ByFloat64Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt32ByIntSlice(values [][]int, f func(vs []int) int32) (max int32) {
	max, err := lib_MaxInt32ByIntSlice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt32ByIntSlice2(values [][][]int, f func(vs [][]int) int32) (max int32) {
	max, err := lib_MaxInt32ByIntSlice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt32ByInt8Slice(values [][]int8, f func(vs []int8) int32) (max int32) {
	max, err := lib_MaxInt32ByInt8Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt32ByInt8Slice2(values [][][]int8, f func(vs [][]int8) int32) (max int32) {
	max, err := lib_MaxInt32ByInt8Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt32ByInt16Slice(values [][]int16, f func(vs []int16) int32) (max int32) {
	max, err := lib_MaxInt32ByInt16Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt32ByInt16Slice2(values [][][]int16, f func(vs [][]int16) int32) (max int32) {
	max, err := lib_MaxInt32ByInt16Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt32ByInt32Slice(values [][]int32, f func(vs []int32) int32) (max int32) {
	max, err := lib_MaxInt32ByInt32Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt32ByInt32Slice2(values [][][]int32, f func(vs [][]int32) int32) (max int32) {
	max, err := lib_MaxInt32ByInt32Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt32ByInt64Slice(values [][]int64, f func(vs []int64) int32) (max int32) {
	max, err := lib_MaxInt32ByInt64Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt32ByInt64Slice2(values [][][]int64, f func(vs [][]int64) int32) (max int32) {
	max, err := lib_MaxInt32ByInt64Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt32ByFloat32Slice(values [][]float32, f func(vs []float32) int32) (max int32) {
	max, err := lib_MaxInt32ByFloat32Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt32ByFloat32Slice2(values [][][]float32, f func(vs [][]float32) int32) (max int32) {
	max, err := lib_MaxInt32ByFloat32Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt32ByFloat64Slice(values [][]float64, f func(vs []float64) int32) (max int32) {
	max, err := lib_MaxInt32ByFloat64Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt32ByFloat64Slice2(values [][][]float64, f func(vs [][]float64) int32) (max int32) {
	max, err := lib_MaxInt32ByFloat64Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt64ByIntSlice(values [][]int, f func(vs []int) int64) (max int64) {
	max, err := lib_MaxInt64ByIntSlice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt64ByIntSlice2(values [][][]int, f func(vs [][]int) int64) (max int64) {
	max, err := lib_MaxInt64ByIntSlice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt64ByInt8Slice(values [][]int8, f func(vs []int8) int64) (max int64) {
	max, err := lib_MaxInt64ByInt8Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt64ByInt8Slice2(values [][][]int8, f func(vs [][]int8) int64) (max int64) {
	max, err := lib_MaxInt64ByInt8Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt64ByInt16Slice(values [][]int16, f func(vs []int16) int64) (max int64) {
	max, err := lib_MaxInt64ByInt16Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt64ByInt16Slice2(values [][][]int16, f func(vs [][]int16) int64) (max int64) {
	max, err := lib_MaxInt64ByInt16Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt64ByInt32Slice(values [][]int32, f func(vs []int32) int64) (max int64) {
	max, err := lib_MaxInt64ByInt32Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt64ByInt32Slice2(values [][][]int32, f func(vs [][]int32) int64) (max int64) {
	max, err := lib_MaxInt64ByInt32Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt64ByInt64Slice(values [][]int64, f func(vs []int64) int64) (max int64) {
	max, err := lib_MaxInt64ByInt64Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt64ByInt64Slice2(values [][][]int64, f func(vs [][]int64) int64) (max int64) {
	max, err := lib_MaxInt64ByInt64Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt64ByFloat32Slice(values [][]float32, f func(vs []float32) int64) (max int64) {
	max, err := lib_MaxInt64ByFloat32Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt64ByFloat32Slice2(values [][][]float32, f func(vs [][]float32) int64) (max int64) {
	max, err := lib_MaxInt64ByFloat32Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt64ByFloat64Slice(values [][]float64, f func(vs []float64) int64) (max int64) {
	max, err := lib_MaxInt64ByFloat64Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxInt64ByFloat64Slice2(values [][][]float64, f func(vs [][]float64) int64) (max int64) {
	max, err := lib_MaxInt64ByFloat64Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat32ByIntSlice(values [][]int, f func(vs []int) float32) (max float32) {
	max, err := lib_MaxFloat32ByIntSlice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat32ByIntSlice2(values [][][]int, f func(vs [][]int) float32) (max float32) {
	max, err := lib_MaxFloat32ByIntSlice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat32ByInt8Slice(values [][]int8, f func(vs []int8) float32) (max float32) {
	max, err := lib_MaxFloat32ByInt8Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat32ByInt8Slice2(values [][][]int8, f func(vs [][]int8) float32) (max float32) {
	max, err := lib_MaxFloat32ByInt8Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat32ByInt16Slice(values [][]int16, f func(vs []int16) float32) (max float32) {
	max, err := lib_MaxFloat32ByInt16Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat32ByInt16Slice2(values [][][]int16, f func(vs [][]int16) float32) (max float32) {
	max, err := lib_MaxFloat32ByInt16Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat32ByInt32Slice(values [][]int32, f func(vs []int32) float32) (max float32) {
	max, err := lib_MaxFloat32ByInt32Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat32ByInt32Slice2(values [][][]int32, f func(vs [][]int32) float32) (max float32) {
	max, err := lib_MaxFloat32ByInt32Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat32ByInt64Slice(values [][]int64, f func(vs []int64) float32) (max float32) {
	max, err := lib_MaxFloat32ByInt64Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat32ByInt64Slice2(values [][][]int64, f func(vs [][]int64) float32) (max float32) {
	max, err := lib_MaxFloat32ByInt64Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat32ByFloat32Slice(values [][]float32, f func(vs []float32) float32) (max float32) {
	max, err := lib_MaxFloat32ByFloat32Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat32ByFloat32Slice2(values [][][]float32, f func(vs [][]float32) float32) (max float32) {
	max, err := lib_MaxFloat32ByFloat32Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat32ByFloat64Slice(values [][]float64, f func(vs []float64) float32) (max float32) {
	max, err := lib_MaxFloat32ByFloat64Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat32ByFloat64Slice2(values [][][]float64, f func(vs [][]float64) float32) (max float32) {
	max, err := lib_MaxFloat32ByFloat64Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat64ByIntSlice(values [][]int, f func(vs []int) float64) (max float64) {
	max, err := lib_MaxFloat64ByIntSlice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat64ByIntSlice2(values [][][]int, f func(vs [][]int) float64) (max float64) {
	max, err := lib_MaxFloat64ByIntSlice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat64ByInt8Slice(values [][]int8, f func(vs []int8) float64) (max float64) {
	max, err := lib_MaxFloat64ByInt8Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat64ByInt8Slice2(values [][][]int8, f func(vs [][]int8) float64) (max float64) {
	max, err := lib_MaxFloat64ByInt8Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat64ByInt16Slice(values [][]int16, f func(vs []int16) float64) (max float64) {
	max, err := lib_MaxFloat64ByInt16Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat64ByInt16Slice2(values [][][]int16, f func(vs [][]int16) float64) (max float64) {
	max, err := lib_MaxFloat64ByInt16Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat64ByInt32Slice(values [][]int32, f func(vs []int32) float64) (max float64) {
	max, err := lib_MaxFloat64ByInt32Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat64ByInt32Slice2(values [][][]int32, f func(vs [][]int32) float64) (max float64) {
	max, err := lib_MaxFloat64ByInt32Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat64ByInt64Slice(values [][]int64, f func(vs []int64) float64) (max float64) {
	max, err := lib_MaxFloat64ByInt64Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat64ByInt64Slice2(values [][][]int64, f func(vs [][]int64) float64) (max float64) {
	max, err := lib_MaxFloat64ByInt64Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat64ByFloat32Slice(values [][]float32, f func(vs []float32) float64) (max float64) {
	max, err := lib_MaxFloat64ByFloat32Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat64ByFloat32Slice2(values [][][]float32, f func(vs [][]float32) float64) (max float64) {
	max, err := lib_MaxFloat64ByFloat32Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat64ByFloat64Slice(values [][]float64, f func(vs []float64) float64) (max float64) {
	max, err := lib_MaxFloat64ByFloat64Slice(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustMaxFloat64ByFloat64Slice2(values [][][]float64, f func(vs [][]float64) float64) (max float64) {
	max, err := lib_MaxFloat64ByFloat64Slice2(values, f)
	if err != nil {
		panic(err)
	}
	return max
}

func lib_MustZipRune(valuesList ...[]rune) (newValuesList [][]rune) {
	newValuesList, err := lib_ZipRune(valuesList...)
	if err != nil {
		panic(err)
	}
	return newValuesList
}

func lib_MustChunkRuneByBits(values []rune, bits []bool) (newValues [][]rune) {
	newValues, err := lib_ChunkRuneByBits(values, bits)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustUnsetRune(values []rune, i int) []rune {
	v, err := lib_UnsetRune(values, i)
	if err != nil {
		panic(err)
	}
	return v
}

func lib_MustRuneCombination(values []rune, r int) (combinations [][]rune) {
	combinations, err := lib_RuneCombination(values, r)
	if err != nil {
		panic(err)
	}
	return combinations
}

func lib_MustRuneSliceCombination(values [][]rune, r int) (combinations [][][]rune) {
	combinations, err := lib_RuneSliceCombination(values, r)
	if err != nil {
		panic(err)
	}
	return combinations
}

func lib_MustZipString(valuesList ...[]string) (newValuesList [][]string) {
	newValuesList, err := lib_ZipString(valuesList...)
	if err != nil {
		panic(err)
	}
	return newValuesList
}

func lib_MustChunkStringByBits(values []string, bits []bool) (newValues [][]string) {
	newValues, err := lib_ChunkStringByBits(values, bits)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustUnsetString(values []string, i int) []string {
	v, err := lib_UnsetString(values, i)
	if err != nil {
		panic(err)
	}
	return v
}

func lib_MustStringCombination(values []string, r int) (combinations [][]string) {
	combinations, err := lib_StringCombination(values, r)
	if err != nil {
		panic(err)
	}
	return combinations
}

func lib_MustStringSliceCombination(values [][]string, r int) (combinations [][][]string) {
	combinations, err := lib_StringSliceCombination(values, r)
	if err != nil {
		panic(err)
	}
	return combinations
}

func lib_MustZipInt(valuesList ...[]int) (newValuesList [][]int) {
	newValuesList, err := lib_ZipInt(valuesList...)
	if err != nil {
		panic(err)
	}
	return newValuesList
}

func lib_MustChunkIntByBits(values []int, bits []bool) (newValues [][]int) {
	newValues, err := lib_ChunkIntByBits(values, bits)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustUnsetInt(values []int, i int) []int {
	v, err := lib_UnsetInt(values, i)
	if err != nil {
		panic(err)
	}
	return v
}

func lib_MustIntCombination(values []int, r int) (combinations [][]int) {
	combinations, err := lib_IntCombination(values, r)
	if err != nil {
		panic(err)
	}
	return combinations
}

func lib_MustIntSliceCombination(values [][]int, r int) (combinations [][][]int) {
	combinations, err := lib_IntSliceCombination(values, r)
	if err != nil {
		panic(err)
	}
	return combinations
}

func lib_MustZipInt8(valuesList ...[]int8) (newValuesList [][]int8) {
	newValuesList, err := lib_ZipInt8(valuesList...)
	if err != nil {
		panic(err)
	}
	return newValuesList
}

func lib_MustChunkInt8ByBits(values []int8, bits []bool) (newValues [][]int8) {
	newValues, err := lib_ChunkInt8ByBits(values, bits)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustUnsetInt8(values []int8, i int) []int8 {
	v, err := lib_UnsetInt8(values, i)
	if err != nil {
		panic(err)
	}
	return v
}

func lib_MustInt8Combination(values []int8, r int) (combinations [][]int8) {
	combinations, err := lib_Int8Combination(values, r)
	if err != nil {
		panic(err)
	}
	return combinations
}

func lib_MustInt8SliceCombination(values [][]int8, r int) (combinations [][][]int8) {
	combinations, err := lib_Int8SliceCombination(values, r)
	if err != nil {
		panic(err)
	}
	return combinations
}

func lib_MustZipInt16(valuesList ...[]int16) (newValuesList [][]int16) {
	newValuesList, err := lib_ZipInt16(valuesList...)
	if err != nil {
		panic(err)
	}
	return newValuesList
}

func lib_MustChunkInt16ByBits(values []int16, bits []bool) (newValues [][]int16) {
	newValues, err := lib_ChunkInt16ByBits(values, bits)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustUnsetInt16(values []int16, i int) []int16 {
	v, err := lib_UnsetInt16(values, i)
	if err != nil {
		panic(err)
	}
	return v
}

func lib_MustInt16Combination(values []int16, r int) (combinations [][]int16) {
	combinations, err := lib_Int16Combination(values, r)
	if err != nil {
		panic(err)
	}
	return combinations
}

func lib_MustInt16SliceCombination(values [][]int16, r int) (combinations [][][]int16) {
	combinations, err := lib_Int16SliceCombination(values, r)
	if err != nil {
		panic(err)
	}
	return combinations
}

func lib_MustZipInt32(valuesList ...[]int32) (newValuesList [][]int32) {
	newValuesList, err := lib_ZipInt32(valuesList...)
	if err != nil {
		panic(err)
	}
	return newValuesList
}

func lib_MustChunkInt32ByBits(values []int32, bits []bool) (newValues [][]int32) {
	newValues, err := lib_ChunkInt32ByBits(values, bits)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustUnsetInt32(values []int32, i int) []int32 {
	v, err := lib_UnsetInt32(values, i)
	if err != nil {
		panic(err)
	}
	return v
}

func lib_MustInt32Combination(values []int32, r int) (combinations [][]int32) {
	combinations, err := lib_Int32Combination(values, r)
	if err != nil {
		panic(err)
	}
	return combinations
}

func lib_MustInt32SliceCombination(values [][]int32, r int) (combinations [][][]int32) {
	combinations, err := lib_Int32SliceCombination(values, r)
	if err != nil {
		panic(err)
	}
	return combinations
}

func lib_MustZipInt64(valuesList ...[]int64) (newValuesList [][]int64) {
	newValuesList, err := lib_ZipInt64(valuesList...)
	if err != nil {
		panic(err)
	}
	return newValuesList
}

func lib_MustChunkInt64ByBits(values []int64, bits []bool) (newValues [][]int64) {
	newValues, err := lib_ChunkInt64ByBits(values, bits)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustUnsetInt64(values []int64, i int) []int64 {
	v, err := lib_UnsetInt64(values, i)
	if err != nil {
		panic(err)
	}
	return v
}

func lib_MustInt64Combination(values []int64, r int) (combinations [][]int64) {
	combinations, err := lib_Int64Combination(values, r)
	if err != nil {
		panic(err)
	}
	return combinations
}

func lib_MustInt64SliceCombination(values [][]int64, r int) (combinations [][][]int64) {
	combinations, err := lib_Int64SliceCombination(values, r)
	if err != nil {
		panic(err)
	}
	return combinations
}

func lib_MustZipFloat32(valuesList ...[]float32) (newValuesList [][]float32) {
	newValuesList, err := lib_ZipFloat32(valuesList...)
	if err != nil {
		panic(err)
	}
	return newValuesList
}

func lib_MustChunkFloat32ByBits(values []float32, bits []bool) (newValues [][]float32) {
	newValues, err := lib_ChunkFloat32ByBits(values, bits)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustUnsetFloat32(values []float32, i int) []float32 {
	v, err := lib_UnsetFloat32(values, i)
	if err != nil {
		panic(err)
	}
	return v
}

func lib_MustFloat32Combination(values []float32, r int) (combinations [][]float32) {
	combinations, err := lib_Float32Combination(values, r)
	if err != nil {
		panic(err)
	}
	return combinations
}

func lib_MustFloat32SliceCombination(values [][]float32, r int) (combinations [][][]float32) {
	combinations, err := lib_Float32SliceCombination(values, r)
	if err != nil {
		panic(err)
	}
	return combinations
}

func lib_MustZipFloat64(valuesList ...[]float64) (newValuesList [][]float64) {
	newValuesList, err := lib_ZipFloat64(valuesList...)
	if err != nil {
		panic(err)
	}
	return newValuesList
}

func lib_MustChunkFloat64ByBits(values []float64, bits []bool) (newValues [][]float64) {
	newValues, err := lib_ChunkFloat64ByBits(values, bits)
	if err != nil {
		panic(err)
	}
	return newValues
}

func lib_MustUnsetFloat64(values []float64, i int) []float64 {
	v, err := lib_UnsetFloat64(values, i)
	if err != nil {
		panic(err)
	}
	return v
}

func lib_MustFloat64Combination(values []float64, r int) (combinations [][]float64) {
	combinations, err := lib_Float64Combination(values, r)
	if err != nil {
		panic(err)
	}
	return combinations
}

func lib_MustFloat64SliceCombination(values [][]float64, r int) (combinations [][][]float64) {
	combinations, err := lib_Float64SliceCombination(values, r)
	if err != nil {
		panic(err)
	}
	return combinations
}

func lib_MustNewGraph(nodeNum int, edges [][]int, directed bool) *lib_Graph {
	v, err := lib_NewGraph(nodeNum, edges, directed)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetLines(startRowIndex, endRowIndex int) [][]string {
	v, err := i.GetLines(startRowIndex, endRowIndex)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetStringLinesFrom(fromIndex int) (newLines [][]string) {
	newLines, err := i.GetStringLinesFrom(fromIndex)
	if err != nil {
		panic(err)
	}
	return newLines
}

func (i *lib_Input) MustGetValue(rowIndex, colIndex int) string {
	v, err := i.GetValue(rowIndex, colIndex)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetFirstValue(rowIndex int) string {
	v, err := i.GetFirstValue(rowIndex)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustGetColLine(colIndex int) (newLine []string) {
	newLine, err := i.GetColLine(colIndex)
	if err != nil {
		panic(err)
	}
	return newLine
}

func (i *lib_Input) MustGetLine(index int) []string {
	v, err := i.GetLine(index)
	if err != nil {
		panic(err)
	}
	return v
}

func (i *lib_Input) MustReadAsStringGridFrom(fromIndex int) [][]string {
	v, err := i.ReadAsStringGridFrom(fromIndex)
	if err != nil {
		panic(err)
	}
	return v
}

func lib_MustNewInputFromReader(reader *bufio.Reader) *lib_Input {
	v, err := lib_NewInputFromReader(reader)
	if err != nil {
		panic(err)
	}
	return v
}

func lib_MustCombination(n, r int64) int64 {
	v, err := lib_Combination(n, r)
	if err != nil {
		panic(err)
	}
	return v
}

func lib_MustBigCombination(n, r int) *big.Int {
	v, err := lib_BigCombination(n, r)
	if err != nil {
		panic(err)
	}
	return v
}

func lib_MustParallelBigCombination(n, r int) *big.Int {
	v, err := lib_ParallelBigCombination(n, r)
	if err != nil {
		panic(err)
	}
	return v
}

func lib_MustMemoizedCombination(n, r int) int {
	v, err := lib_MemoizedCombination(n, r)
	if err != nil {
		panic(err)
	}
	return v
}

func lib_MustMemoizedBigCombination(n, r int) *big.Int {
	v, err := lib_MemoizedBigCombination(n, r)
	if err != nil {
		panic(err)
	}
	return v
}

func lib_MustRangeFactorial(n, num int64) (f int64) {
	f, err := lib_RangeFactorial(n, num)
	if err != nil {
		panic(err)
	}
	return f
}

func lib_MustFactorial(n int64) (f int64) {
	f, err := lib_Factorial(n)
	if err != nil {
		panic(err)
	}
	return f
}

func lib_MustMemoizedFactorial(n int, cache map[int]int) int {
	v, err := lib_MemoizedFactorial(n, cache)
	if err != nil {
		panic(err)
	}
	return v
}

func lib_toSpecificBitIntLine(line []string, bitSize int) (intLine []int64, err error) {
	for j, v := range line {
		intV, err := strconv.ParseInt(v, 10, bitSize)
		if err != nil {
			return nil, fmt.Errorf(fmt.Sprintf("%dth value: %v", j, err.Error()))
		}
		intLine = append(intLine, intV)
	}
	return intLine, nil
}

func lib_BitEnumeration(digits uint) (enums [][]bool) {
	if digits == 0 {
		return [][]bool{}
	}

	for i := 0; i < 1<<digits; i++ {
		e := []bool{}
		for d := uint(0); d < digits; d++ {
			e = append(e, i>>d&1 == 1)
		}
		enums = append(enums, e)
	}
	return
}

func lib_Combination(n, r int64) (int64, error) {
	if n < r {
		return 0, fmt.Errorf("r(%d) is larger than n(%d)", r, n)
	}

	if n == r {
		return 1, nil
	}

	rRangeFac, err := lib_RangeFactorial(n, r)
	if err != nil {
		return 0, fmt.Errorf("failed in Combination: %v", err)
	}
	rFac, err := lib_Factorial(r)
	if err != nil {
		return 0, fmt.Errorf("failed in Combination: %v", err)
	}
	return rRangeFac / rFac, nil
}

func lib_BigCombination(n, r int) (*big.Int, error) {
	if n < r {
		return nil, fmt.Errorf("r(%d) is larger than n(%d)", r, n)
	}

	if n == r {
		return big.NewInt(1), nil
	}

	rFac := lib_BigFactorial(r)
	nFac := lib_BigFactorial(n)
	nrFac := lib_BigFactorial(n - r)
	return nFac.Div(nFac, rFac.Mul(rFac, nrFac)), nil
}

func lib_ParallelBigCombination(n, r int) (*big.Int, error) {
	if n < r {
		return nil, fmt.Errorf("r(%d) is larger than n(%d)", r, n)
	}

	if n == r {
		return big.NewInt(1), nil
	}

	rChan := make(chan *big.Int)
	nChan := make(chan *big.Int)
	nrChan := make(chan *big.Int)
	go func(r int) {
		rChan <- lib_BigFactorial(r)
	}(r)
	go func(n int) {
		nChan <- lib_BigFactorial(n)
	}(n)
	go func(nr int) {
		nrChan <- lib_BigFactorial(nr)
	}(n - r)

	rFac, nFac, nrFac := <-rChan, <-nChan, <-nrChan
	return nFac.Div(nFac, rFac.Mul(rFac, nrFac)), nil
}

func lib_MemoizedCombination(n, r int) (int, error) {
	if n < r {
		return 0, fmt.Errorf("r(%d) is larger than n(%d)", r, n)
	}

	if n == r {
		return 1, nil
	}

	cache := map[int]int{}
	rFac, err := lib_MemoizedFactorial(r, cache)
	if err != nil {
		return 0, fmt.Errorf("too large r: %s", err)
	}
	nFac, err := lib_MemoizedFactorial(n, cache)
	if err != nil {
		return 0, fmt.Errorf("too large n: %s", err)
	}
	nrFac, err := lib_MemoizedFactorial(n-r, cache)
	if err != nil {
		return 0, fmt.Errorf("too large n - r: %s", err)
	}
	return nFac / (rFac * nrFac), nil
}

func lib_MemoizedBigCombination(n, r int) (*big.Int, error) {
	if n < r {
		return nil, fmt.Errorf("r(%d) is larger than n(%d)", r, n)
	}

	if n == r {
		return big.NewInt(1), nil
	}

	cache := map[int]*big.Int{}
	rFac := lib_MemoizedBigFactorial(r, cache)
	nFac := lib_MemoizedBigFactorial(n, cache)
	nrFac := lib_MemoizedBigFactorial(n-r, cache)
	return nFac.Div(nFac, rFac.Mul(rFac, nrFac)), nil
}

func lib_RangeFactorial(n, num int64) (f int64, err error) {
	f = 1
	for i := int64(0); i < num; i++ {
		f *= n - i
	}
	return
}

func lib_Factorial(n int64) (f int64, err error) {
	if n > 20 { // FIXME Consider 32bit architecture
		return 0, fmt.Errorf("too large Factorical n: %d", n)
	}

	f = 1
	for i := int64(2); i <= n; i++ {
		f = f * i
	}
	return
}

func lib_BigFactorial(n int) *big.Int {
	result := big.NewInt(1)
	for i := 2; i <= n; i++ {
		result = result.Mul(result, big.NewInt(int64(i)))
	}
	return result
}

func lib_MemoizedFactorial(n int, cache map[int]int) (int, error) {
	if n > 20 { // FIXME Consider 32bit architecture
		return 0, fmt.Errorf("too large n: %d", n)
	}

	if cachedResult, ok := cache[n]; ok {
		return cachedResult, nil
	}

	if n == 1 {
		return 1, nil
	}

	beforeResult, err := lib_MemoizedFactorial(n-1, cache)
	if err != nil {
		return 0, err
	}
	result := n * beforeResult
	cache[n] = result
	return result, nil
}

func lib_MemoizedBigFactorial(n int, cache map[int]*big.Int) *big.Int {
	if cachedResult, ok := cache[n]; ok {
		return cachedResult
	}

	if n == 1 {
		return big.NewInt(1)
	}

	beforeResult := lib_MemoizedBigFactorial(n-1, cache)
	bigN := big.NewInt(int64(n))
	result := bigN.Mul(bigN, beforeResult)
	cache[n] = result
	return result
}

func lib_FindPosFromStringGrid(m [][]string, s string) (int, int) {
	for rowIndex, row := range m {
		for colIndex, p := range row {
			if p == s {
				return rowIndex, colIndex
			}
		}
	}
	panic(s + " not found")
}

func lib_ToYesNo(yes bool) string {
	return lib_TernaryOPString(yes, "Yes", "No")
}

func lib_ReverseStr(s string) string {
	runes := []rune(s)
	for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
		runes[i], runes[j] = runes[j], runes[i]
	}
	return string(runes)
}

func lib_PanicIfErrorExist(err error) {
	if err != nil {
		panic(err)
	}
}

func lib_TrimSpaceAndNewLineCodeAndTab(s string) string {
	return strings.TrimFunc(s, func(r rune) bool {
		return r == ' ' || r == '\r' || r == '\n' || r == '\t'
	})
}
